


h1. chapter 5<br>Garbage Collection


h2. Execution time program image

This chapter will abruptly subject the reader to a discussion
of various low level issues.&nbsp&nbsp First,&nbsp the Ruby 'C' program
memory structure,&nbsp followed by the Memory Structure supporting
the actual Ruby Language execution.&nbsp&nbsp This may be tough going for some readers,&nbsp but this chapter is important to understanding later chapters.


h3. C&nbsp Program Memory Structure

A general a 'C'&nbsp  program has the following basic memory structure.

<pre class="greenlist">
1. Program Code Space
2. Constants, Static variables, and global variables
3. Machine stack
4. Heap,&nbsp;also refered to a <i>Free Store</i>.
</pre
 
Items 1 and 2 are generally contained in the load image.&nbsp&nbsp Items 3 an 4 are setup by program initialization.
 


Once a 'C' program is initialized,&nbsp  it contains at least three seperate 
memory segments.&nbsp&nbsp  Program Code,&nbsp  Globals,&nbsp  and static variables are 
generally in the load image stored in Text Memory.&nbsp&nbsp  Arguments and local
variables of functions are stored on the Machine Stack.&nbsp Lastly,&nbsp  the program can also
acquire additional memory from the Free Store (also refered to as the <i>Heap</i>).



The third item should to well known to most programmers.&nbsp&nbsp The <i>Machine Stack</i>
is implemented by the processor hosting Ruby.&nbsp&nbsp 
In Figure 1a.&nbsp the stack is shown growing toward higher addresses.&nbsp&nbsp This is not universal,&nbsp  the X86 Memory Stack,&nbsp Figure 1b,&nbsp  grows toward the lower addresses.



<img src="images/ch_gc_macstack_2a.jpg" alt="(Macstack)"><br>
<br>Figure 1: Machine Stacks



 The Ruby language program uses the
the Machine Stack to handle it's stack operations.&nbsp&nbsp The small items, like Integers and arguments are pushed onto the Machine Stack by the underlying code generated by the
'C' Compiler.

As we will see, the ruby interpreter pushes larger blocks of data onto the Machine Stack.&nbsp&nbsp These blocks are called a <i>Stack Frames</i>.&nbsp&nbsp The Stack Frame is a predefine memory block that allows Ruby push structured data onto the Machine Stack.&nbsp&nbsp Ruby also pushes various other structured and unstructured data onto the stack.



The <i>Stack Frame</i> corresponds to a <i>Ruby Function Call</i>.&nbsp&nbsp When the function returns,&nbsp  the Stack Frame is poped from the Machine Stack!&nbsp&nbsp The left side of&nbsp Figure 2 shows the  stack after the Ruby Function 'D' is called.&nbsp&nbsp The right shows the stack after returning from the functions 'D' & 'C'. 


<img src="images/ch_gc_nalloca.jpg" alt="(Macstack)"><br>
<br>Figure 2: Machine Stack - Using native alloca 


h3.  Alloca() vs Malloc() 

 
The <b>malloc()</b>&nbsp function returns a pointer to a block of memory of the
size requested, of a Null pointer to indicate an error.&nbsp&nbsp The memory block
is obtained from the <i>Heap</i>.&nbsp&nbsp Memory Blocks acquired using malloc() must eventually be returned to the Heap via <b>Free()</b>&nbsp function.


The <b>Native alloca()</b>&nbsp function is a different animal.&nbsp&nbsp This function is a very low level function without many safeguards!&nbsp&nbsp This function is
generally implemented as in-line function generated by the complier.&nbsp&nbsp The requested memory block is allocated on the Machine Stack.&nbsp&nbsp Thus,&nbsp  when the function that called alloca() returns the memory block evaporates.&nbsp&nbsp The inlined code is generally a single instruction adjusting the stack pointer,&nbsp 
it does not check for stack overflow,&nbsp  and there is no NULL error return.

 
 

 
The use of <b>Native alloca()</b>&nbsp is good in the respect that is simple and
can improve execution times when used appropriately.
 

 
Now for the "fly in the ointment"!&nbsp&nbsp The sad fact is that <b>Native alloc()</b>&nbsp is not supported by all host systems and compilers used to execute the Ruby Language Program (i.e.&nbsp the Ruby Interpreter).&nbsp&nbsp The parts of the
Ruby interpreter that use <i>alloca()</i>&nbsp determine which implementation of
alloca() to use. 
 
 
The <b>Alloca() Emulation</b>&nbsp code is provided by <i>missing/alloca.c</i>.
 

 
The <b>alloca emulation</b>&nbsp function uses a linked list to manage the allocation and release of the acquired memory.&nbsp&nbsp Each entry in the linked list consists of a header and a block of memory.&nbsp&nbsp Each Header contains a pointer to the next entry (if any)&nbsp  and the current Machine Stack location.&nbsp&nbsp A <i>List Element</i>&nbsp is made up of a <i>Header</i> (described above) followed by a <i>Size</i>&nbsp block of memory.
 



<img src="images/ch_gc_calloca_list_full.jpg" alt="(Calloca)"><br>
Figure 3: Alloca Emulation linked list diagram

 
This list and it's operations are controlled by one function,&nbsp alloca()&nbsp&nbsp   This is necessary to maintain compatibility with Native Alloca.&nbsp&nbsp 


 When a user calls alloca(),&nbsp  the function performs Garbage Collection.&nbsp&nbsp The Garbage Collector steps backward through the linked List removing all List Elements where the recorded depth is deeper in stack than the current Machine Stack pointer.&nbsp&nbsp After garbage collection is finished, a new List Element is created and placed a the top of the linked list.&nbsp&nbsp


If the <i>size</i>&nbsp is zero, the function returns after the garbage collection is perfomed and does not create a List Element
 
This is important to remember that until the next alloca() call the linked
list remains untouched.&nbsp While a List Element may exist beyond the point
where calling function returns,&nbsp it will evaporate the next time the alloca() function is called. 

The Figure below shows the results after the return of 'D' and 'C' and the next garbage collection cycle caused by a alloca() call.&nbsp&nbsp The figure below does not show creation of the next List Element,&nbsp  if any.
 

<img src="images/ch_gc_calloca_list.jpg" alt="(Calloca)"><br>
Figure 4: Alloca Emulation linked list diagram

 
The <b>missing/alloca.c</b>&nbsp function emulates the Native Alloca()&nbsp on host systems or compilers that do not support the native alloca().
 

h2. GC ... Explanation

 
We have discussed the underlying support for stack resident memory allocation and it's emulation for those host systems and compilers that do not have Native alloca support.&nbsp The balance of this chapter will be the
management of the Heap.
 
</pre>
h3. GC
 
Normally,&nbsp  objects reside in memory and at the conclusion of the program these memory resident objects are released along the other memory resources used by the program.&nbsp&nbsp  As long as the memory space is large enough to provide all the memory requested, things work fine!&nbsp&nbsp 
 
 
In actuallity,&nbsp  <i>memory is always a limited resource</i>.&nbsp&nbsp Even if the user has access to all them memory available,&nbspeven  small amounts of discarded memory add up to very large values for long running programs.&nbsp&nbsp Almost all programs will acquire blocks of heap memory.&nbsp&nbsp When these resources are not released properly,&nbsp the accumlation of this memory debris is called a <i>Memory Leak</i>.
 
 
The control of the memory resources is always a available to the programmer by using <b>malloc()</b>&nbsp, and <b>free()</b>.&nbsp&nbsp In Object Oriented programs knowing when to release objects from memory can become
difficult due to complex object references.
 Ruby relieves the programmer of much of this complexity by managing object memory allocation and release automatically.&nbsp&nbsp Ruby handles this task,&nbsp as many other languages do,&nbsp  by using a <i>Garbage Collection</i>&nbsp  Scheme.
 

 
Ruby uses a modified version of the <i>Boehm-Demers-Weiser garbage collector </i>,&nbsp  generally known as simply <i>Boehm GC</i>.&nbsp&nbsp With this function there is no need release the memory allocated for Ruby objects and other automatically allocated memory.&nbsp&nbsp The Ruby Garbage Collector,&nbsp  hereafter refered to as just GC,&nbsp  manages both the allocation and release of these memory resources.
  

 
The issue of <i>Heap Memory Compaction</i> arises in many discussions of the various implementations of Boehm GC.&nbsp&nbsp Many programs that the use a 
Garbage Collector,&nbsp  often face issues of memory fragmentation.&nbsp&nbsp Ruby does not implement memory compaction,&nbsp  but does not generally suffer from crippling heap fragmentation.&nbsp&nbsp 

One reason for this is that the basic object structures are all the same size.&nbsp&nbsp It is also true that some objects,&nbsp  strings leap to mind,&nbsp  allocate additional memory to hold the string value.&nbsp&nbsp 
The <i>free store</i>&nbsp or <i>heap</i>&nbsp storage algorithm is controll at a low level by the
<i>malloc</i> functiion.&nbsp This, and other issues concernint the Ruby GC will be covered in a later section.

 
The Boehm GC has been used successfully in many systems.&nbsp&nbsp More information on Boehm GC is available at: <b>http://www.hpl.hp.com/personal/Hans_Boehm/gc</b>.

Recent languages such as Java and Perl, Python, C#, and Eiffel use Garbage Collection.&nbsp The rest of this chapter will be devoted to the details of Ruby's Garbage Collector.
 

h3. What is Garbage Collection?

 
The first question is what is GC trying accomplish.&nbsp&nbsp The GC allocates memory from the
 <i>heap</i>&nbsp for <i>objects</i> and memory controlled by Objects.&nbsp&nbsp Additionally, and
most importantly,&nbsp  it manages this resource and reclaims the allocated memory from the program when it is
no longer in use.&nbsp&nbsp This releaves the programmer of the task of keeping track of allocated memory and releasing it when no longer needed.

Ruby's GC is,&nbsp as are most Garbage Collectors,
&nbsp is composed of three  main sections.&nbsp&nbsp The first is <i>Memory 
Allocation</i>,&nbsp the second is <i>Garbage Detection</i>,&nbsp and the last is <i>Garbage Reclarmation</i>.
  
<i>Memory Allocation</i>&nbsp functions control access to the memory set aside for GC functions.
&nbsp&nbsp This memory is initially allocated from Heap Memory at program initialization.&nbsp When this
initial allocation of memory is exhausted, Ruby will perform Garbage Collection.&nbsp&nbsp If there is
still not enougth memory to satisfy the allocation request,&nbsp  another block of memory is requested and added to the memory controlled by the Garbage Collector.
 
 
The various memory
allocation functions return blocks of memory of the requested sizes.&nbsp&nbsp These functions also
maintain lists of memory that is allocated and memory that is available for allocation.&nbsp&nbsp  In addition to being used by memory allocation functions, these lists are
also updated  by the <i>Garbage Reclarmation</i>&nbsp processing.
 
 
<i>Garbage Detection</i> is the process of determining which objects are still in use.&nbsp These objects
are <i>Live Objects</i>&nbsp and will be preserved. &nbsp&nbsp Conversely,&nbspall other objects are considered "Dead" and no longer
viable.&nbsp&nbsp These objects, called <i>garbage</i>,&nbsp are processed by the <i>Garbage Reclarmation</i>&nbsp section.
  
<i>Garbage Reclarmation</i> section of GC attempts to find all the memory being used by the so 
called <i>Garbage Objects</i> and returns it
to the <i>Memory Allocation</i> functions by updating the lists of available memory.&nbsp&nbsp
The memory returned is not just the object itself,&nbsp  but any addtional memory attached to the basic 
object.&nbsp&nbsp In Ruby for example, <b>Fixnum,&nbsp true,&nbsp and false</b>&nbsp are all completely contained the basic object structure.
&nbsp&nbsp <b>Strings</b>,&nbsp on the other hand,&nbsp allocate additional memory to hold the actual
character string. 
 

h3. Survey of garbage collector types
 
The following sections discuss several general methods for performing<i>Garbage Collection</i>.&nbsp&nbsp   
We briefing discuss the major types,&nbsp their weaknesses and strengths.&nbsp&nbsp Bear in mind the <i>Mark and Sweep</i>&nbsp is the type used by Ruby.
 

h3. Mark & sweep

 
The <b>Mark phase</b> finds <i>live</i> objects and <i>marks</i>&nbsp them to prevent the
GC from deallocating the associated memory.&nbsp&nbsp It performs this task by defining a <i>Root Set</i>&nbsp of known viable objects and tracing their connections to other objects.&nbsp&nbsp 

 
The <i>Root Set</i>&nbsp are objects referenced by:

# Ruby Global Variables and Constants 
# Ruby live Local Variables
# The machine stack
# Objects referenced by 'C' Global Variables registered by  <b>rb_gc_register_address()</b>

 

<img src="images/ch_gc_gcimage.jpg" alt="(Gcimage)"><br>
Figure 5: Root Set trace of live objects


The set of objects found by the sweep phase that are not <i><b>marked</b></i>&nbsp  are considered <i>dead objects</i>,&nbsp
also called <i>garbage.</i>

 
<b>Mark and Sweep Merits:</b><br>

# While Mark & Sweep GC's normally have problems with memory fragmentation, Ruby GC is somewhat
immune to this problem because the common size of Ruby Objects.
# One other advantage is that Mark & Sweep can release a <i>cycle</i>.&nbsp&nbsp See the section on Reference Counting for a discussion of this problem. 

 
 
<b>Mark and Sweep Deficiencies</b><br>

# The minimum time it takes to run one Mark and Sweep Cycle is directly proportional to the
number of Managed Objects.&nbsp&nbsp Each object must be 'touched' at least once.&nbsp&nbsp All live objects must be <i>marked</i> and all garbage objects must be <i>collected</i>.
# Because the Mark and Sweep cycle locks out other processing while it runs,&nbsp the GC can make a noticable dent in a programs performace.

 


h3. Stop & copy
 
This method is a modification of the Mark and Sweep Garbage Collector.&nbsp&nbsp The managed heap space is divided into two sections.&nbsp&nbsp One is the current active heap and the other is empty, call them A and B.&nbsp&nbsp Any any one time, only one these heaps  will be active!&nbsp&nbsp The GC allocates new objects in the active heap.
 

<img src="images/ch_gc_stop2.jpg" alt="(Stop2)"><br>
Figure 6: Stop & copy (1)

 
When the GC Runs, it transverses  all active objects in the same way as Mark and Sweep.&nbsp&nbsp However, the live objects are transferred to the inactive heap instead marking them.&nbsp&nbsp When the Mark phase is complete, the inactive heap is made the active heap.&nbsp&nbsp The freshly inactivated heap only contains garbage objects and thus they are implicitly collected.&nbsp&nbsp This is, the inactive area is <i>considered</i> empty! 
 


<img src="images/ch_gc_stop3.jpg" alt="(Stop3)"><br>
Figure 7: Stop & copy (2)


 
<b>Stop and Copy Merits:</b><br>

# The live objects are essentially compacted during the Garbage Collection cycle.
# This additonally improves the <i>locality</i> of live objects.&nbsp&nbsp Since they are all located near each other, they reduce memory paging in a virtual memory system.&nbsp&nbsp There is a much higher probabilty that referneces will be in the memory cache.
# Like it's cousin Mark and Sweep, this method also is able to collect <i>cycles</i>.

 
 
<b>Stop and Copy Deficiencies</b><br>

# The time to copy objects to the inactive heap takes longer than simply marking a live object.
# The position of the objects change.&nbsp&nbsp The relocation of references may take a signigicant amount of processing.

 

h3. Reference counting
 
A Reference Counting Garbage Collector is different from the other types of GC's we have discussed so far.&nbsp&nbsp In this method,&nbsp  each object has a <i>reference counter</i>&nbsp associate with it.&nbsp&nbsp This counter is incremented by one each tiem a new reference pointer is created that points to a particular object.&nbsp&nbsp For example, when a pointer is copied from one place to another by an assignment statement.
 
 
When a referece to an object is removed, the counter is decremented by one.&nbsp&nbsp When the reference counter becomes zero,&nbsp the object is collected,&nbsp e.g.,&nbsp the memory allocated for the object is reclaimed.
 

<img src="images/ch_gc_refcnt.jpg" alt="(Refcnt)"><br>
Figure 8: Reference counting example

<b>Reference Counting Merits:</b><br>

# The processing load imposed by the Garbage Collector is distributed across the whole execution of the program.&nbsp&nbsp 
# Objects are, theorically, released the moment they can no longer be reached by the program.

 
 
<b>Reference Counting Deficiencies</b><br>

# The most serious problem with reference counting is that is it not always <i>effective.</i>&nbsp&nbsp&nbsp The inability to handle <i>cycles</i>&nbsp is discussed below.
# Reference counting is very hard to make <i>efficient.</i>&nbsp&nbsp Since every time a refernce to an object is created or destroyed, a reference counter must be incremented or decremented.&nbsp&nbsp This adds more overhead to the processing of objects and references.
# Additionally, if the reference counter for a large complex object structure becomes zero, it can cascade through references finding other referneces becoming zero.&nbsp&nbsp In some cases this may cause a noticable performace hit.

 
 
As mentioned above, a major deficiency of reference counting is handling <i>cycles.</i>&nbsp&nbspThese are a group of objects that form a circular structure.&nbsp A simple example is shown below:  
 

<img src="images/ch_gc_cycle.jpg" alt="(Cycle)"><br>
Figure 9: Cycle

 
As you can see, even if such a structure loses the last reference from an external object,&nbsp  the counters will never reach zero. 
 


h2. Management of Ruby objects
 
The Ruby GC only manages <i>Ruby Objects</i> and other memory blocks <i>controlled</i>&nbsp by Ruby Objects.&nbsp&nbsp Ruby Objects often acquire addtional memory to provide storage for a variety of purposes.&nbsp&nbsp These include buffers to hold character strings,&nbsp memory to hold numeric values,&nbspmemory to hold arrays and hashes.
 
While memory can be allocated directly from the heap by calling 'C' language functions,&nbsp this memory will not be managed by the  Ruby GC.&nbsp&nbsp It is the Users resposibility to release any memory acquired in this manner.&nbsp Failure to release memory will result in a <i>memory leak</i>&nbsp , as shown below:
<br>
<pre class="graylist">
Void not_ok ()
{
    Malloc (1024);     /* Possible Memory Leak! */
}
</pre>

In the following case,&nbsp the user allocates memory for a Ruby object using the <i>Ruby API.</i>&nbsp&nbsp Ruby will manage this block on memory automatically and release it when it is no longer in use.
 
<pre class="graylist">
Void this_is_ok ()
{
    Rb_ary_new ();    /* Object managed by the Ruby GC */
away, *
}
</pre>


h3.  Struct RVALUE 

 
As we stated the Ruby GC only manages Ruby Objects.&nbsp&nbsp This control is accomplished
using the basic Ruby object structure.&nbsp&nbsp Ruby objects are always addressed with a
reference pointer of type RVALUE.

The struct RVALUE a union of Object Structures and System Structures.&nbsp&nbsp There is one object structure for each ruby object type( object,&nbsp  klass,&nbsp  string,&nbsp ...),&nbsp and additonal objects to support the Ruby interpreter operations.

<pre class="graylist">

typedef struct RVALUE {
    union {
  struct {
      unsigned long flags;  /* always 0 for freed obj */
      struct RVALUE *next;
  } free;
  struct RBasic  basic;
  struct RObject object;
  struct RClass  klass;
  struct RFloat  flonum;
  struct RString string;
  struct RArray  array;
  struct RRegexp regexp;
  struct RHash   hash;
  struct RData   data;
  struct RStruct rstruct;
  struct RBignum bignum;
  struct RFile   file;
  struct RNode   node;
  struct RMatch  match;
  struct RVarmap varmap;
  struct SCOPE   scope;
    } as;
#ifdef GC_DEBUG
    char *file;            /* Internal Debugging Feature */
    int   line;
#endif
} RVALUE;

(Gc.C)
</pre>
 
Ruby GC managed memory contains two distinct types of data.&nbsp&nbsp The first is the actual Ruby Objects,&nbsp which are always exactly 20 Bytes(40 Bytes on 64 bit Processors).&nbsp&nbsp The other type is the additional memory allocated and referenced by these objects.&nbsp&nbsp This memory is used to store data and table references.  
 

 
Of the RVALUE Structures listed above,&nbsp only the ones itemized below represent the structures that implement Ruby Objects. 
 
<pre class="greenlist">
<i>Struct</i> <b>RBasic </b>   - Preamble for all Structures(flags & Klass ptr)<br>
<i>Struct</i> <b>RObject</b>   - General Object - For things not applicable below
<i>Struct</i> <b>RClass </b>   - Class objects
<i>Struct</i> <b>RFloat </b>   - Integer Decimals (small & medium)
<i>Struct</i> <b>RString</b>   - Character strings
<i>Struct</i> <b>RArray </b>   - Arrays
<i>Struct</i> <b>RRegexp</b>   - Regular expression
<i>Struct</i> <b>RHash  </b>   - Hash table
<i>Struct</i> <b>RFile  </b>   - IO File,&nbsp Socket,&nbsp And so on
<i>Struct</i> <b>RData  </b>   - Class for describing everything for 'C' level
<i>Struct</i> <b>RStruct</b>   - The structure of Ruby Struct Class
<i>Struct</i> <b>RBignum</b>   - Big integer
</pre>

 
The importance of the&nbsp <b>RVALUE Structure</b> can not by over emphasized.&nbsp&nbsp This is the core of the Ruby Interpreter.&nbsp&nbsp It not only expresses all Ruby objects,&nbsp but it also contains structures used by the Interpter itself.&nbsp&nbsp All of these structures are same length and share a common preamble, the <b>RBasic Structure</b>.&nbsp&nbsp 
 

The Structure Definition of RBasic is as follows:

<pre class="graylist">
  struct RBasic {
  unsigned long flags;
  VALUE klass;
  };

(ruby.h)
</pre>
The two structures most important to the operation of the Ruby GC are:
<pre class="greenlist">
1)  <i>Struct</i> <b>RBasic</b>   
2)  <i>Struct</i> <b>as.free</b>   
</pre>
 
As you will remember,&nbsp  most of the RVALUE structures contain <b>RBasic</b>,&nbsp The only exceptions are <b>RNode</b>&nbsp and <b>SCOPE</b>.&nbsp&nbsp In the case of <b>as.free</b>,&nbsp it reinterprets <b>RBasic</b> enteries only for the purpose of linking RVALUE blocks into the <b>*freelst</b>.
 
<pre class="greenlist">
<b>as.free</b>
unsigned long flags;   -- Always zero when added to the *freelist
struct RVALUE *next;   -- Points at next entry in the *freelist
</pre>
 
The construction of the <b>*freelist</b>&nbsp;will be  discussed shortly.
 
 
The <i>flags</i>&nbsp word in <b>RBasic</b>,&nbsp as explained in Chapter 02,&nbsp contains all the state information for a Ruby Object.
 

h3. Free Store Mapping

 
Due to the way the <i>malloc()</i>&nbsp functions,&nbsp the <i>free store</i>&nbsp memory is not always allocated in contiguous fashion.
&nbsp&nbsp This is because malloc allocates  memory in various locations depending on the size
of the requested block.&nbsp&nbsp Exactly where memory allocations will take place is beyond the scope of the document and is dependent on the exact implementation of <i>malloc()</i>!&nbsp&nbsp However, since Ruby make one or more  very large allocations (<i>Ruby heap's)</i>&nbsp  and many smaller allocations during object creation and Interpreter processing,&nbsp this generally results in only two primary locations for memory allocation.
 
 
The following is a plausible memory map for many processors running Ruby. 
 

<img src="images/ch_gc_mem_map.png" alt="(Memory Allocation Map)"><br>
<br>
Figure 10: Memory allocation map




h3. Ruby object heaps

 
The Ruby Interpreter implements  a specialized memory management system for <i>Ruby Objects</i>&nbsp 
on top of the more general <i>Free Store</i>&nbsp management scheme provided by &nbsp  <b>malloc()</b>,&nbsp <b>realloc()</b>,&nbsp and <b>free()</b>&nbsp functions.&nbsp&nbsp Since Ruby Objects are fixed in size,&nbsp  the Ruby GC can optimize their management.
 
 
The Ruby Object Heap,&nbsp hereafter called an Object Heap,&nbsp  is implemented using two interrelated arrays. The array <b>heaps[&nbsp]</b>&nbsp is the root structure.&nbsp&nbsp Each element contains a <b>heaps_slot</b> structure.&nbsp&nbsp Initially only the first elment of <b>heaps[&nbsp]</b>&nbsp is instantiated.
 
 
The following code fragment show the important defines,&nbsp  arrays,&nbsp  and structures that support Object Heap contruction and management. 
 


<pre class="graylist">
#define HEAPS_INCREMENT 10

#define HEAP_MIN_SLOTS 10000
static int heap_slots = HEAP_MIN_SLOTS;

static struct heaps_slot {
    void *membase;
    RVALUE *slot;
    int limit;
} *heaps;

static int heaps_length = 0;
static int heaps_used = 0;

(gc.c)
</pre>
 
The <b>heaps_slot</b>&nbsp structure contains three elements that describe an allocated array.&nbsp&nbsp This array is often refered to as the <b>heap</b>.&nbsp&nbsp 
It is made up of&nbsp  <b>heap_slots</b>&nbsp number of elements,&nbsp refered to as a <b>slot</b>.&nbsp&nbsp Each of these <b>slots</b>&nbsp is RVALUE sized.&nbsp&nbsp In other words, each <b>slot</b> is an empty <i>object-sized</i>&nbsp block of memory that has been set to zero.
 
 
The last sentence above is important.&nbsp&nbsp These <b>slots</b>&nbsp will eventully become <i>Ruby Objects</i>! 
 

 
The three elements the <b>heap_slots</b>&nbsp structure  are: 
 
<pre class="greenlist">
1) *membase - Points to the origin of the allocated memory block.
2) *slot    - The first properly "aligned" slot location in the heap.
              (*membase and *slot MAY or MAY NOT be the same address) 
3) limit    - The total number of available "slots" in the heap. 
                 
</pre>

<img src="images/ch_gc_heapslot.png" alt="(Heapitems)"><br><br>
Figure 11: Relationship between the <b>heaps_slot</b> structure  and the <b>heap</b> it describes

 
The <b>*slot</b>&nbsp value is necessary because the starting address of the <b>heap</b>&nbsp <i>must</i>&nbsp be evenly divisible by the size of RVALUE.&nbsp&nbsp When this is not the case,&nbsp  the nearest evenly divisible address thats greater than <b>*membase</b>&nbsp is used.
 
 
The <b>heaps</b>&nbsp structure is a array of <b>heaps_slot</b> elements. The variables
that control it's usage are: 
 
<pre class="greenlist">
1) *heaps       - Base address  of an array of <b>heaps_slot</b> elements.
2) heaps_length - The number of elements in the <b>heaps</b> array.
3) heaps_used   - The number of elements in <b>heaps</b> array being used.
</pre>

<img src="images/ch_gc_heaps_all.png" alt="(Heapitems)"><br><br>
Figure 12: The <i>complete</i> <b>heaps</b> structure


h3.  Freelist 
 
The <b>*freelist</b> is the repository of <i>object-sized</i>&nbsp memory blocks that will be
used to create new objects.&nbsp&nbsp The list is created or extended by the <b>add_heap()</b>
 function by linking all the elements in a new heap into the <b>*freelist</b>.
 
 
Also remember, as objects are reclaimed during the <i>sweep phase</i>&nbsp these objects are also added to the <b>*freelist</b>. 
 

 
This accomplished by steping through each element in the new heap and  perfoming the following actions until the array of new elements is exhausted.
<pre class="greenlist">
1) The heap element  is referenced through the <b>as.free</b>&nbsp structure.
2) The <b>as.flags</b> word is zero indicating it is a empty object, <b>as.*next</b>&nbsp 
   is set to the contents of the <b>*freelist</b>.
3) The <b>*freelist</b> is set to the address of the current heap element.
</pre>

 

<img src="images/ch_gc_free_linking.jpg" alt="(*freelist linking)"><br><br>
Figure 13: Freelist construction order


 
When the Ruby GC sweeps memory each object that is not <i>marked</i>&nbsp is added to the <i>free list</i>.&nbsp&nbsp Any memory referenced by the object is simply freed and returned to free stote.&nbsp&nbsp The <b>as.free</b>&nbsp entry is used to construct the <b>*freelist</b>.&nbsp&nbsp The <b>as.flags</b>&nbsp word is cleared to indicate that the object is "free",&nbsp and the <b>as.*next</b>&nbsp entry is used to link the object into the <b>*freelist</b>&nbsp as shown above.
 



h3.  Add_heap () 

▼  Add_heap () (Concise edition)
<pre class="graylist">
Static void
add_heap()
{
    RVALUE *p, *pend;

// Section 1 -- Extend the length of Heaps Array (if necessary)
//
    if (heaps_used == heaps_length) {
  /* Realloc heaps */
  struct heaps_slot *p;
  int length;

  heaps_length += HEAPS_INCREMENT;
  length = heaps_length*sizeof(struct heaps_slot);
  RUBY_CRITICAL(
      if (heaps_used > 0) {
    p = (struct heaps_slot *)realloc(heaps, length);
    if (p) heaps = p;
      }
      else {
    p = heaps = (struct heaps_slot *)malloc(length);
      });
  if (p == 0) rb_memerror();
    }

// Section 2 - Create new Heap Array and compute Heap_slots values
//
    for (;;) {
  RUBY_CRITICAL(p = 
           (RVALUE*)malloc(sizeof(RVALUE)*(heap_slots+1)));
  if (p == 0) {
      if (heap_slots == HEAP_MIN_SLOTS) {
    rb_memerror();
      }
      heap_slots = HEAP_MIN_SLOTS;
      continue;
  }
        heaps[heaps_used].membase = p;
        if ((VALUE)p % sizeof(RVALUE) == 0)
            heap_slots += 1;
        else
            p = (RVALUE*)((VALUE)p + sizeof(RVALUE) - 
                   ((VALUE)p % sizeof(RVALUE)));
        heaps[heaps_used].slot = p;
        heaps[heaps_used].limit = heap_slots;
  break;
    }

// Section 3 - Compute Begin/End of Heap and Adjust Parameters
//
    pend = p + heap_slots;
    if (lomem == 0 || lomem > p) lomem = p;
    if (himem < pend) himem = pend;
    heaps_used++;
    heap_slots *= 1.8;
    if (heap_slots <= 0) heap_slots = HEAP_MIN_SLOTS;

// Section 4 - Add all new Slots to *freelist
//
    while (p < pend) {
  p->as.free.flags = 0;
  p->as.free.next = freelist;
  freelist = p;
  p++;
    }
}

(gc.c)
</pre>
 
The following discussion covers the sections noted in the code block above. 
 

 
<b><i>Section 1:</i></b><BR>
When the initial allotted elements in the <b>heaps</b>&nbsp array has been exhausted, the
array must be expanded to hold additional elements.&nbsp&nbsp The special case of initialization
is handled by the same code,&nbsp since the size <b>heaps_used</b>&nbsp and <b>heaps_length</b>&nbsp are both initially zero.
 
 
The length of the <b>heaps</b>  array is initially set to the value of the HEAP_MIN_SLOTS constant.&nbsp&nbsp Thereafter, it is exapanded by the same value.
 

 
<b><i>Section 2:</i></b><BR>
This section attempts to allocate a new <b>heap</b>.&nbsp&nbsp If allocation fails and the <b>heap_slots</b>&nbsp value is greater than the HEAP_MIN_SLOTS constant value,&nbsp an attempt is made to to allocate just HEAP_MIN_SLOTS.&nbsp&nbsp If this also fails, Ruby aborts with memory failure.
 
If memory allocation is sucessful, the values for the <b>heaps_slot</b>&nbsp element are computed.&nbsp&nbsp The <b>*membase</b> value is the address returned by the malloc function.&nbsp&nbsp If this value can not be evenly divided by the size of RVALUE, the next heighest address that is evenly divisable is used for the <b>*slot</b>&nbsp value. Otherwise, the <b>*membase</b>&nbsp value is used for <b>*slot</b>.
  
 
<b><i>Section 3:</i></b><BR>
This section computes the beginning and end addresses for the new <b>heap</b>.&nbsp&nbsp Next,&nbsp the number of <b>heaps_used</b>&nbsp is incremented.&nbsp&nbsp Finally,&nbsp  <b>heap_slots</b>&nbsp variable is multiplied by the constant '1.8'.&nbsp&nbsp This means that each new <b>heap</b>&nbsp will be '1.8'&nbsp times larger that the last.&nbsp&nbsp This is done to reduce the number times that the GC is called for programs with large numbers of objects.
 

 
<b><i>Section 4:</i></b><BR>
The last step is to link each element of the <b>heap</b> into the <b>*freelist</b>.&nbsp&nbsp This provides Ruby with a large number of new "empty" objects to be used.
 

h3.  Rb_newobj () 

▼  rb_newobj () 
<pre class="graylist">

VALUE
rb_newobj()
{
    VALUE obj;

    if (!freelist) garbage_collect();

    obj = (VALUE)freelist;
    freelist = freelist->as.free.next;

    MEMZERO((void*)obj, RVALUE, 1);
    return obj;
}

(gc.c)
</pre>
 
When Ruby needs to create a new object,&nbsp  the <b>rb_newobj()</b>&nbsp function is called.&nbsp&nbsp This function performs the following basic operations:

<pre class="greenlist">
1) If the <b>*freelist</b> is empty, garbage collection is performed.
2) A new object is extracted from the <b>*freelist</b>.
3) The new object is cleared and returned to the caller.
</pre>

h2. Marking
 
This process is performed by marking that following objects and their descendants:
 
<pre class="greenlist">
1) global variables and constants in Ruby.
2) live local variables in Ruby
3) the machine stack
4) objects referenced by C global variables
   registerd by rb_gc_register_address()
</pre>

h3.  Rb_gc_mark () 


 rb_gc_mark()  - Simply Calls <b>gc_mark()</b>.

<pre class="graylist">
void
rb_gc_mark(ptr)
    VALUE ptr;
{
    gc_mark(ptr, 0);
}
</pre>
<pre class="greenlist">
The separation of   rb_gc_mark()  into two functions is a result of 
<i>refactoring</i>. This allows the core processing functions of gc_mark() to
be modified for reuse in different contexts.  This is example of the 
continuing work being done to not only add new functionality,&nbsp but to 
improve the underlying code of the Ruby Interpreter.
</pre> 

 
 gc_mark()  -  Recursively marks all live objects 
 

<pre class="graylist">
static void
gc_mark(ptr, lev)
    VALUE ptr;
    int lev;
{
    register RVALUE *obj;

    obj = RANY(ptr);
    if (rb_special_const_p(ptr)) return; /* special const not marked */
    if (obj->as.basic.flags == 0) return;       /* free cell */
    if (obj->as.basic.flags & FL_MARK) return;  /* already marked */
    obj->as.basic.flags |= FL_MARK;

    if (lev > GC_LEVEL_MAX || (lev == 0 && ruby_stack_check())) {
      if (!mark_stack_overflow) {
        if (mark_stack_ptr - mark_stack < MARK_STACK_MAX) {
          *mark_stack_ptr = ptr;
          mark_stack_ptr++;   
        }
        else {
         mark_stack_overflow = 1;
        }
      }
      return;
   }
   gc_mark_children(ptr, lev+1);
}

</pre>
 
The RANY definition allows the reference of <i>any</i>&nbsp object.&nbsp&nbsp For this particular function,&nbsp  it's purpose to reference the <b>flags</b>&nbsp word of each object processed.&nbsp&nbsp  It's definition
is shown below: 
 
<pre class="graylist">
    #define RANY(o) ((RVALUE*)(o))

(gc.c)
</pre>

 
If the object is a special constant,&nbsp already <i>marked</i>,&nbsp or a 'free' object no further processing is performed.&nbsp&nbsp Otherwise, the object is <i>marked</i> and further processing is required.
 
 
After the object being <i>marked</i>,&nbsp a bit of special processing takes place.&nbsp&nbsp For purposes of program stability,&nbsp the depth of recursion during object tracing is limited.&nbsp&nbsp When this depth is reached, an attempt is made to place the current object pointer onto a special axuillary stack, the <b>mark_stack</b>.
 
 
If the <b>mark stack</b>&nbsp is full, the the <b>mark_stack_overflow</b>&nbsp marker is checked.&nbsp&nbsp If it is set, when the marking phase is finished,&nbsp all viable objects in all the heaps are marked.&nbsp&nbsp This is necessary to insure that all 'live' objects will be <i>marked!</i> 
 
 
If the <b>mark_stack_overflow</b>&nbsp marker is not set,&nbsp then all the objects on the <b>mark_stack</b> are passed to <i>gc_mark_children</i>.&nbsp&nbsp When complete, the Ruby GC starts the <i>sweep</i>&nbsp phase.
 


h3.  gc_mark_children () 
 
The following is a abbreviated version of the source code for <b>Gc_mark_children()</b>.&nbsp&nbsp The code contains two main sections.&nbsp&nbsp The first processes the T_NODE Objects.&nbsp&nbsp The second processes the standard Object Nodes.
 
▼  gc_mark_children () 
<pre class="graylist">

static void
gc_mark_children(ptr, lev)
    VALUE ptr;
    int lev;
{
#ifdef ENABLE_DBG
if (mute_flag != 0) {
printf("<gc.c>  gc_mark_children(...) at (923)\n");
}
#endif
    register RVALUE *obj = RANY(ptr);

    goto marking;   /* skip */

  again:
    obj = RANY(ptr);
    if (rb_special_const_p(ptr)) return; /* special const not marked */
    if (obj->as.basic.flags == 0) return;       /* free cell */
    if (obj->as.basic.flags & FL_MARK) return;  /* already marked */
    obj->as.basic.flags |= FL_MARK;

  marking:
    if (FL_TEST(obj, FL_EXIVAR)) {
  rb_mark_generic_ivar(ptr);
    }

    switch (obj->as.basic.flags & T_MASK) {
      case T_NIL:
      case T_FIXNUM:
  rb_bug("rb_gc_mark() called for broken object");
  break;

      case T_NODE:
  mark_source_filename(obj->as.node.nd_file);
  switch (nd_type(obj)) {
    case NODE_IF:   /* 1,2,3 */
    case NODE_FOR:
    case NODE_ITER:
         
          /*............ abbreviation............ */
  }
  return;     /* no need to mark class. */
  }

    gc_mark(obj->as.basic.klass, lev);
    switch (obj->as.basic.flags & T_MASK) {
      case T_ICLASS:
      case T_CLASS:
      case T_MODULE:
  mark_tbl(obj->as.klass.m_tbl, lev);
  mark_tbl(obj->as.klass.iv_tbl, lev);
  ptr = obj->as.klass.super;
  goto again;

      case T_ARRAY:
  if (FL_TEST(obj, ELTS_SHARED)) {
      ptr = obj->as.array.aux.shared;
      goto again;
  }
  else {
      long i, len = obj->as.array.len;
      VALUE *ptr = obj->as.array.ptr;

      for (i=0; i < len; i++) {
    gc_mark(*ptr++, lev);
      }
  }
  break;

          /*............ abbreviation............ */
  
      default:
  rb_bug("rb_gc_mark(): unknown data type 0x%x(0x%x) %s",
         obj->as.basic.flags & T_MASK, obj,
         is_pointer_to_heap(obj) ? 
                            "corrupted object" : "non object");
    }
}

(gc.c)
</pre>
 
<b>Gc_mark_children()</b>&nbsp tries to find all the objects that can be reached from the input object.&nbsp&nbsp As we will see in this and following sections,&nbsp this is a endeavor that involves detailed processing.&nbsp&nbsp What do we mean? &nbsp&nbsp Consider the following simple array:&nbsp&nbsp "ary = [ 1, 2]"

<img src="images/ch_gc_node_tree.png" alt="(node tree)"><br>
<br>Figure 14: Objects for&nbsp&nbsp  "ary = [ 1&nbsp;, 2 ]"

The Gray structures(See Below) indicate the extent of the basic input object,&nbsp  that is the part of the object that has already been marked.&nbsp&nbsp This is the object that was processed by <b>gc_mark()</b>.&nbsp&nbsp It has been passed to this routine to do what?&nbsp&nbsp To mark all of it's childern!&nbsp&nbsp  The array structure itself is not marked,&nbsp  it is considered part of the input object and it will deleted when it's object is destroyed.&nbsp&nbsp This is true of all auxillary memory used by objects.
 
 
The blue structures are the <i>children</i>&nbsp of the input object,&nbsp&nbsp They are the <i>reachable</i>&nbsp  objects.&nbsp&nbsp These are the objects that <b>gc_mark_children()</b> will <i>Mark</i>&nbsp if they are not already marked.
 
 
As you can see,&nbsp  these are the constructs that represent the <i>objects and data</i> created by the programmer.&nbsp&nbsp However,&nbsp  there are another set of objects supported by the Ruby Interpreter.&nbsp&nbsp These are <b>T_NODES</b>.&nbsp&nbsp These are the objects that represent the program code inside Ruby.&nbsp&nbsp Each <i>source line</i>&nbsp is converted into a tree of&nbsp  T_NODES.


T_NODES will be discussed in some detail in Secton II.&nbsp&nbsp For now,&nbsp T_NODES are shown just to illustrate the processing in first section of <b>gc_mark_children()</b>.&nbsp&nbsp  The following T_NODE Tree is created for the source line "x = 5 + 1":
 

<img src="images/ch_gc_tnode_tree.png" alt="(tnode tree)"><br>
<br>Figure 15: T_NODES Generated for&nbsp&nbsp "x = 5 + 1"

 
As before the gray structures illustrate the input object processed by <b>gc_mark()</b> and the Blue structures represent the objects that are "reachable" by <b>gc_mark_children()</b>.
 


This pairing of <b>gc_mark</b>&nbsp and <b>gc_mark_children()</b>&nbsp work recursively to trace
the objects.&nbsp&nbsp The trace depth variable <i>lev</i>&nbsp and the <i>mark_stack</i> work to
prevent run-away recursion.&nbsp&nbsp These features breaks very deep traces into smaller chucks to
ease processing.&nbsp&nbsp It is important to know that while these features sometimes fail,&nbsp 
the program does not crash.&nbsp It simply marks ALL of the ojbects.&nbsp&nbsp While this mary appear
crude, it will allow Ruby to continue to run until the processor memory is exhausted.
 
 

 

 
In the case of T_DATA Objects,&nbsp if a <i>Marking Function</i>&nbsp is present, it is executed.&nbsp&nbsp Ruby has no way of knowing what the structure of a T_DATA Object represents,&nbsp  thus we can not process this object any further. 
 
<pre class="graylist">
 case T_DATA:
   if (obj-> As.Data.Dmark) (*obj-> As.Data.Dmark) (DATA_PTR (obj));
 break;

(gc.c)
</pre>
h3.  Rb_gc () 
 
The function <b>rb_gc()</b>&nbsp simply calls the function <b>garbage_collect()</b>&nbsp and on completion calls <b>rb_gc_finalize_deferred()</b>.
 

</pre>
<pre class="graylist">
void
rb_gc()
{
    garbage_collect();
    rb_gc_finalize_deferred();
}

(gc.c)
</pre>
 
The function&nbsp <b>garbage_collect()</b>&nbsp attempts to reclaim the space allocated to <i>non-live</i>&nbsp objects before adding another heap.&nbsp&nbsp The reclaimation process is  performed by two main tasks.&nbsp&nbsp The first task is performed by calling <b>gc_mark()</b>&nbsp  for the <i>root set</i>&nbsp of objects.&nbsp&nbsp These are:

 
# global variables and constants in Ruby.
# live local variables in Ruby
# the machine stack
# objects referenced by C global variables registerd by rb_gc_register_address()


Second,&nbsp  the function <b>gc_sweep</b>&nbsp is then called called to reclaim all objects that were not <i>marked</i>&nbsp by the marking functions.&nbsp&nbsp  That is,&nbsp  all objects that were not reachable from the <i>root set</i>&nbsp of objects.

 
The function <b>rb_gc_finalize_deferred()</b>&nbsp is called to perform any actions that have be performed before an object is destroyed.&nbsp&nbsp There three instances when this must be done.
 

#  When an object was placed on the <i>deferred_final_list</i>&nbsp by calling the method <i>ObjectSpace.define_finalizer</i>,&nbsp&nbsp This method stores a <i>proc</i>&nbsp that <b>rb_gc_finalize_deferred()</b>&nbsp will execute before deleting the target object.
#  When a T_DATA Object has a <i>dfree</i>&nbsp function specified.
#  When a T_FILE Object is destroyed, any open I/O channels must be closed.


h3. Ruby stack and object lists

The following section of code,&nbsp from <b>garbage_collect(),</b>&nbsp traces objects found in Ruby stack structures and certain lists of objects.&nbsp&nbsp These include Local Variables,&nbsp Nodes in Stack Frames,&nbsp Scope Objects, in-block Variables, and any finalizer objects.&nbsp&nbsp 
 

<pre class="graylist">
   gc_mark((VALUE)ruby_current_node, 0);

    /* mark frame stack */
    for (frame = ruby_frame; frame; frame = frame->prev) {
  rb_gc_mark_frame(frame);
  if (frame->tmp) {
      struct FRAME *tmp = frame->tmp;
      while (tmp) {
    rb_gc_mark_frame(tmp);
    tmp = tmp->prev;
      }
  }
    }
    gc_mark((VALUE)ruby_scope, 0);
    gc_mark((VALUE)ruby_dyna_vars, 0);
    if (finalizer_table) {
  mark_tbl(finalizer_table, 0);
    }

(gc.c)
</pre>
 
The variable <i>ruby_current_node</i>&nbsp points to the current node on the Abstract Syntax Tree(AST).&nbsp&nbsp As usual, marking this node also marks all nodes reachable from this node.
 
 
Each Stack Frame contains a pointer to an AST Node,&nbsp which is marked!&nbsp&nbsp Additionally, a Stack Frame may contain a sub-list of Stack Frames, which also have their Nodes marked.&nbsp&nbsp  
 
 
Marking <i>ruby_scope</i>&nbsp marks all local variables in the current Scope. 
 
 
Marking <i>ruby_dyna_vars</i>&nbsp marks all in-block Variables in the current Scope. 
 
 
Finally, if a <i>finalizer_table</i>&nbsp is present,&nbsp  all objects contained in the table are marked. 
 





h3. Registers and the Stack

The <b>GC</b>&nbsp also has to worry about objects referenced from machine registers and the stack.&nbsp&nbsp For registers, this presents a problem for the interpreter.&nbsp&nbsp When you attempt to examine register contents,&nbsp knowledge of the underlying architecture is required.&nbsp&nbsp This presents some difficulties.&nbsp&nbsp This will be obvious when examining the code.&nbsp&nbsp For the purposes of this document,&nbsp will examine only the <i>X86 Processor</i>.

The following code example is for the X86 Processor ( both 32 & 64 bit).&nbsp&nbsp The <b>FLUSH_REGISTER _WINDOWS</b> definition is not used by the X86.&nbsp&nbsp A <b>setjmp()</b>&nbsp function is used to store the machine registers in a known location.&nbsp&nbsp Then function <b>mark_locations_array()</b>&nbsp then marks any objects referenced from the saved registers.&nbsp&nbsp This function will be discussed shortly.

 
Now the registers have been marked,&nbsp attempt is made to find all apparent object references on the full stack.&nbsp&nbsp These references unlike others are more tentative in nature.&nbsp&nbsp All we know about the references on the stack is that they point an object in an active heap.&nbsp&nbsp When found, these objects are marked.

The only problem we have is that the object may be a "dead" object.&nbsp&nbsp We just don't know for certain!&nbsp&nbsp The reference may never be used.&nbsp  This is yet another  example of why GC is called a <i>conservative</i> garbage collector.&nbsp&nbsp When we are uncertain about whether an object is alive or dead,&nbsp  we err on the side of caution and mark it!
 
  
 


<pre class="graylist">

    FLUSH_REGISTER_WINDOWS;     /* "((void)0)" for X86 Architecture */

    setjmp(save_regs_gc_mark);  /* Save registers in local array */
  
    mark_locations_array((VALUE*)save_regs_gc_mark, 
                     sizeof(save_regs_gc_mark) / sizeof(VALUE *));

    #if STACK_GROW_DIRECTION < 0
       rb_gc_mark_locations((VALUE*)STACK_END, rb_gc_stack_start);  ??

    ( code for other architectures )

(gc.c)
</pre>
<pre class="graylist">
#ifdef __GNUC__
#if defined(__human68k__) || defined(DJGPP)
#if defined(__human68k__)
typedef unsigned long rb_jmp_buf[8];
__asm__ (".even\n\
_rb_setjmp:\n\
	move.l	4(sp),a0\n\
	movem.l	d3-d7/a3-a5,(a0)\n\
	moveq.l	#0,d0\n\
	rts");
#ifdef setjmp
#undef setjmp
#endif
#else
#if defined(DJGPP)
typedef unsigned long rb_jmp_buf[6];
__asm__ (".align 4\n\
_rb_setjmp:\n\
	pushl	%ebp\n\
	movl	%esp,%ebp\n\
	movl	8(%ebp),%ebp\n\
	movl	%eax,(%ebp)\n\
	movl	%ebx,4(%ebp)\n\
	movl	%ecx,8(%ebp)\n\
	movl	%edx,12(%ebp)\n\
	movl	%esi,16(%ebp)\n\
	movl	%edi,20(%ebp)\n\
	popl	%ebp\n\
	xorl	%eax,%eax\n\
	ret");
#endif
#endif
int rb_setjmp (rb_jmp_buf);
#define jmp_buf rb_jmp_buf
#define setjmp rb_setjmp
#endif /* __human68k__ or DJGPP */
#endif /* __GNUC__ */

(gc.c)</a>
</pre>



h4.  Mark_locations_array () 
 
This function purpose is to step through an array a possible <b>VALUE</b>&nbsp words and determine
if they point to a object in a valid heap.&nbsp&nbsp  Each possible VALUE is presented to the function <b>is_pointer_to_heap().</b>&nbsp&nbsp If the function returns true the object is marked by calling <b>gc_mark().</b>
 
 
As discussed in previous sections,&nbsp these arrays have been stored registers and the stack.
 


<pre class="graylist">

mark_locations_array(x, n)
    register VALUE *x;
    register long n;
{
    VALUE v;
    while (n--) {
        v = *x;
        if (is_pointer_to_heap((void *)v)) {
            gc_mark(v, 0);
        }
    x++;
    }
}

(gc.c)
</pre>

h4.  Is_pointer_to_heap () 
 
This function given a <i>possible</i>&nbsp object address,&nbsp determines if it is a valid address.&nbsp&nbsp We know that all objects are allocated from one or more heaps in memory.&nbsp&nbsp If the given pointer falls within the address range of a valid heap,&nbsp then it is an object.  
 
 
However, just falling with the proper range does not make is a "live" object.&nbsp&nbsp It simply indicates that it <i>maybe</i>&nbsp a valid object.&nbsp&nbsp The object could easily be on the <i>freelist</i>,&nbsp for example.&nbsp&nbsp This function only determines that it is valid object address.
 


<pre class="graylist">
static inline int
is_pointer_to_heap(ptr)
    void *ptr;
{
    register RVALUE *p = RANY(ptr);
    register RVALUE *heap_org;
    register long i;

    if (p < lomem || p > himem) return Qfalse;
    if ((VALUE)p % sizeof(RVALUE) != 0) return Qfalse;

    /* check if p looks like a pointer */
    for (i=0; i < heaps_used; i++) {
        heap_org = heaps[i].slot;
        if (heap_org <= p && p < heap_org + heaps[i].limit)
          return Qtrue;
    }
    return Qfalse;
}

(gc.c)
</pre>

h4. Register window
<pre class="graylist">
 #if defined (sparc) || defined (__sparc__)
 # if defined (linux) || defined (__linux__)
 #define FLUSH_REGISTER_WINDOWS asm ("ta 0x83")
 # else /* Solaris and not sparc linux *
 #define FLUSH_REGISTER_WINDOWS asm ("ta 0x03")
 # endif
 #else /* Not a sparc *
 #define FLUSH_REGISTER_WINDOWS
 #endif

(defines.h)
</pre>


h3. Machine stack
<pre class="graylist">
 rb_gc_mark_locations (rb_gc_stack_start, (VALUE*) STACK_END);
 #if defined (__human68k__)
 rb_gc_mark_locations ((VALUE*) ((char*) rb_gc_stack_start
 
 (VALUE*) ((char*) STACK_END + 2));
 #endif

(gc.c)
</pre>


h4.  Init_stack () 
 
This function initializes the stack parameters.&nbsp&nbsp As with some previous sections that involved machine level interactions,&nbsp we will discuss specifics for the X86 processor only.
 
 
First,&nbsp the starting address of the stack must be computed.&nbsp&nbsp First,&nbsp if the specified parameter address contains zero,&nbsp it will be filled with it's own address.
 
 
Now the macro&nbsp  <b>STACK_UPPER(x, y, z)</b>&nbsp is a piece of tricky business.&nbsp&nbsp Since stack direction and usage varies,&nbsp this macro adjusts for it.&nbsp&nbsp For X86 processors the third parameter,&nbsp<i>z</i>,&nbsp is always used.&nbsp&nbsp Thus, the first usage of&nbsp STACK_UPPER()&nbsp executes the instruction <b>++addr</b>.&nbsp&nbsp The second,&nbsp executes the conditional <b>rb_gc_stack_start &lt addr</b>.
 
 
If the symbol HAVE_GETRLIMIT is defined,&nbsp the code following will compute a "reasonable" stack size for the current processor.&nbsp&nbsp This is done by asking the processor for the current Stack Limit and using it to compute the STACK_LEVEL_MAX value.&nbsp&nbsp For the X86 Processor the initial value is set to <i>655300</i>.

 

<pre class="graylist">
void
Init_stack(addr)
    VALUE *addr;
{
#ifdef __ia64
  ::       ::          ::
#endif

#if defined(_WIN32) || defined(__CYGWIN__)
  ::       ::          ::
#elif defined(STACK_END_ADDRESS)
  ::       ::          ::
#else
    if (!addr) addr = (VALUE *)&addr;   /* X86 Processing */
    STACK_UPPER(&addr, addr, ++addr);
    if (rb_gc_stack_start) {
  if (STACK_UPPER(&addr,
      rb_gc_stack_start > addr,
      rb_gc_stack_start < addr))
      rb_gc_stack_start = addr;
  return;
    }
    rb_gc_stack_start = addr;
#endif

#ifdef HAVE_GETRLIMIT                  /* X86 Processing */
    {
  struct rlimit rlim;

  if (getrlimit(RLIMIT_STACK, &rlim) == 0) {
      unsigned int space = rlim.rlim_cur/5;

      if (space > 1024*1024) space = 1024*1024;
      STACK_LEVEL_MAX = (rlim.rlim_cur - space) / sizeof(VALUE);
  }
    }
#endif
}


(gc.c)
</pre>


h4.  STACK_END 
 
Again,&nbsp as we did previously,&nbsp we have isolated the defines for the X86 processor.&nbsp&nbsp Other processors take slightly different tacks.&nbsp&nbsp The important issue here is that the two defines that "set" and "return" the <i>Stack End Address</i> are created properly for the current processor.
 

<pre class="graylist">
#ifdef C_ALLOCA
   ::         ::       ::
#else
# if defined(__GNUC__) && 
         defined(USE_BUILTIN_FRAME_ADDRESS) && !defined(__ia64)
   ::         ::       ::
   ::         ::       ::
# else                       /* Starting X86 Defines */                                   
#  define  SET_STACK_END    VALUE *stack_end = alloca(1)
# endif
# define STACK_END (stack_end)
#endif

(gc.c)
</pre>
 
The SET_STACK_END operation creates the pointer to the Stack End Address by allocating one word on the current stack.&nbsp&nbsp The returned address is stored in the pointer location, <i>stack_end</i>.

<pre class="graylist">
    VALUE *stack_end = alloca(1)
</pre>
 
When ever the define STACK_END is used, the value <i>(stack_end)</i>&nbsp is inserted.
</P>
These methods of creating and returning the Stack End Address isolates all the processor differences in <i>static defines</i> rather than coding executable methods of processor differentiation.&nbsp&nbsp This is a common technique used throughout the Ruby Interpreter.
 


h4.  Rb_gc_mark_locations () 
  
This function searches the stack for pointers into active heaps.&nbsp&nbsp Checks are made to assure that the possible object appears to be an appropriate size and resides at valid heap location.&nbsp&nbsp At this point,&nbsp we assume it is a "live" object.&nbsp&nbsp There is some chance that the object is already "dead", but as a conservative collector we accept the occasional uncollected "dead" object.


The actual traversing of the stack and marking objects is performed by <b>mark_locations_array()</b>.&nbsp&nbsp The function <b>rb_gc_mark_locations ()</b>&nbsp only coverts the input parameters into a form that is acceptable to <b>mark_locations_array()</b>.


<pre class="graylist">
void
rb_gc_mark_locations(start, end)
    VALUE *start, *end;
{
    long n;

    n = end - start;
    mark_locations_array(start,n);
}
(gc.c)
</pre>

While traversing a stack is generally a processor specific function,&nbsp  <b>rb_gc_mark_locations()</b> avoids this problem by requiring the caller make adjustments for processor differences.&nbsp&nbsp The following code encompasses the various processor adjustments for calls to <b>rb_gc_mark_locations()</b>.
 
<pre class="graylist">
 <b><i>garbage_collect():</i></b>  (continued)
    ::       ::       ::
    ::       ::       ::
#if STACK_GROW_DIRECTION < 0      /* X86 Processors */
    rb_gc_mark_locations((VALUE*)STACK_END, rb_gc_stack_start);

#elif STACK_GROW_DIRECTION > 0
    rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)STACK_END + 1);

#else
    if ((VALUE*)STACK_END < rb_gc_stack_start)
       rb_gc_mark_locations((VALUE*)STACK_END, rb_gc_stack_start);
    else
       rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)STACK_END + 1);
#endif

#ifdef __ia64
    /* mark backing store (flushed register window on the stack) */
    /* the basic idea from guile GC code                         */
    rb_gc_mark_locations(rb_gc_register_stack_start,
          (VALUE*)rb_ia64_bsp());
#endif

#if defined(__human68k__) || defined(__mc68000__)
    rb_gc_mark_locations((VALUE*)((char*)STACK_END + 2),
       (VALUE*)((char*)rb_gc_stack_start + 2));
#endif

(gc.c)
</pre>
 
As an example the first two lines are for calling this <b>rb_gc_mark_locations()</b>&nbsp on X86 Processors.

 Notice that the "start" and "end" specifications <i>are not necessarily</i>&nbsp the actual start and end addresses. These values are calculated for each processor so the stack is traversed in a positive direction, regardless of the actual stack orientation.
 




h3. Other route objects
 
Lastly, there are a number of system tables and miscellaneous objects that are left to be marked.&nbsp&nbsp We will cover them in this section.&nbsp&nbsp As you can see below,&nbsp this is the final marking phase before the <i>sweep</i>&nbsp begins!
 

</pre>
<pre class="graylist">
    <b><i>garbage_collect():</i></b>  (continued)
       ::         ::       ::
       ::         ::       ::
    rb_gc_mark_threads();

    /* mark protected global variables */
    for (list = global_List; list; list = list->next) {
       rb_gc_mark_maybe(*list->varptr);
    }
    rb_mark_end_proc();
    rb_gc_mark_global_tbl();

    rb_mark_tbl(rb_class_tbl);
    rb_gc_mark_trap_list();

    /* mark generic instance variables for special constants */
    rb_mark_generic_ivar_tbl();

    rb_gc_mark_parser();

    /* gc_mark objects whose marking are not completed*/
    do {
       while (!MARK_STACK_EMPTY) {
         if (mark_stack_overflow){
           gc_mark_all();
         }
         else {
           gc_mark_rest();
         }
       }
       rb_gc_abort_threads();

    } while (!MARK_STACK_EMPTY);

    gc_sweep(); /* Performs the Sweep Phase of the Garbage Collector */
 }

(gc.c)
</pre>

 
<b>rb_gc_mark_threads()</b><br>
If threads are being used,&nbsp this function will mark all active threads.
 

 
<b>Global List and rb_gc_mark_maybe()</b><br>
The global list contains pointers to both simple global address and objects.&nbsp&nbsp The <i>global_list</i>&nbsp is scanned and each address is passed to <b>rb_gc_mark_maybe()</b>.&nbsp&nbsp This function determines if the pointer resides in an active heap,&nbsp which means the address points at an object.&nbsp&nbsp All objects found on the global_list are marked.  
 

 
<b>rb_gc_mark_end_proc()</b><br> 
The handling of proc's by <b>eval.c</b>&nbsp evolves keeping various lists of proc objects.&nbsp This function marks all the objects recorded in these lists. 
 

 
<b>rb_gc_mark_global_tbl()</b><br>
Ruby maintains an internal hash table of all define global variables.&nbsp&nbsp This function marks each of these variables.
 

 
<b>rb_gc_mark_trap_list()</b><br>  
Ruby keeps a list of signal traps for handling threads.&nbsp&nbsp This function marks the objects associated with these thread signals.
 

 
<b>rb_gc_mark_generic_ivar_tbl()</b><br> 
When instance variables are created for special constants,&nbsp they are stored in the <i>generic_ivar_tbl</i>.&nbsp&nbsp This is necessary because special constants exist only in the VALUE word and do not instantiate an actual object.&nbsp&nbsp All variable objects in this table are marked! 
 

 
<b>rb_gc_mark_parser()</b><br> 
This function marks the objects that hold the state of the parser. 
 

 
<b>Marking Objects with incomplete marking</b><br>  
The last marking sequence to complete is the marking of objects on the <i>mark_stack</i>.&nbsp&nbsp As stated previously,&nbsp if the mark_stack has <i>overflowed</i>&nbsp all objects will be marked.&nbsp&nbsp Otherwise, just the objects on the mark_stack are fed to <b>gc_mark_children()</b>.
 

 
<b>rb_gc_abort_threads()</b><br>  
At the completion of all marking,&nbsp this function will terminate all unmarked  threads.
 



h2. Sweep

h3. Special treatment of NODE Objects
 
For the <i>sweep phase</i>&nbsp we will search for objects that are not marked and release them!&nbsp&nbsp However,&nbsp there is a small problem with objects of type NODE if the parser's semantic stack is not allocated on the machine stack.&nbsp&nbsp For configurations were the machine stack is not used,&nbsp the following code is provided to mark those objects.&nbsp&nbsp Notice that even for these configurations,&nbsp this is only a problem if the parser in compiling!
 
<pre class="graylist">
static void
gc_sweep()
{
 RVALUE *p, *pend, *final_list;
 int freed = 0;
 int i;
 unsigned long live = 0;
 unsigned long free_min = 0;
   ::       ::       ::    ::
   ::       ::       ::    ::
/* We should not reclaim nodes during compilation             */
/* if yacc's semantic stack is not allocated on machine stack */

 if (ruby_in_compile && ruby_parser_stack_on_heap()) {
   for (i = 0; i < heaps_used; i++) {
     p = heaps[i].slot; pend = p + heaps[i].limit;
     while (p < pend) {
       if (!(p->as.basic.flags&FL_MARK) && BUILTIN_TYPE(p) == T_NODE)
         gc_mark((VALUE)p, 0);
        p++;
        }
     }
   }
   ::       ::       ::    ::
   ::       ::       ::    ::

(gc.c)
</pre>


h3. Reclaiming "dead" Objects
 
The following section of <b>gc_sweep()</b>&nbsp examines the active heaps for objects that are not <i>marked</i>!&nbsp&nbsp Unmarked,&nbsp or "dead",&nbsp objects are first processed by <b>obj_free()</b>.&nbsp&nbsp This function releases any auxiliary memory that has been allocated for an object.&nbsp&nbsp These are things like the memory that holds the string for a string object.&nbsp&nbsp Other objects, such a <i>float</i>,&nbsp are self-contained objects and are not modified.
 
 
This does not actually "free" an object,&nbsp it simply reduces it to a bare, and probably an incomplete,&nbsp object.&nbsp&nbsp It becomes free only when it is placed on the <i>freelist</i>.&nbsp&nbsp However, before it can legitimately be placed on that list,&nbsp it must be checked for a <i>finalizer</i>. 
 

The rest of the section is concerned with insuring that unnecessary heaps are reclaimed and that there are sufficient "free' objects available.&nbsp&nbsp Care is taken not to reclaim an empty heap if the number of "free" objects is less than the computed value <i>free_min</i>.&nbsp&nbsp This value never less than the constant FREE_MIN (currently 4096).&nbsp&nbsp If however,&nbsp after all reclamation has been complete the number of "free" objects is less than <i>free_min</i>,&nbsp the function&nbsp<b>add_heap()</b>&nbsp performed to increase their number.

<pre class="graylist">
  <b><i>gc_sweep():</i></b>  (continued)
   ::       ::       ::    ::
   ::       ::       ::    ::
  freelist = 0;
  final_list = deferred_final_list;
  deferred_final_list = 0;
  
  for (i = 0; i < heaps_used; i++) {
    int n = 0;
    RVALUE *free = freelist;
    RVALUE *final = final_list;
    
    p = heaps[i].slot; pend = p + heaps[i].limit;
    while (p < pend) {
      if (!(p->as.basic.flags & FL_MARK)) {
        if (p->as.basic.flags) {
            obj_free((VALUE)p);
        }
        if (need_call_final && FL_TEST(p, FL_FINALIZE)) {
          p->as.free.flags = FL_MARK; /* remain marked */
          p->as.free.next = final_list;
          final_list = p;
        }
        else {
          p->as.free.flags = 0;
          p->as.free.next = freelist;
          freelist = p;
        }
        n++;
      }
      else if (RBASIC(p)->flags == FL_MARK) {
        /* objects to be finalized */
        /* do nothing remain marked */
      }
      else {
        RBASIC(p)->flags &= ~FL_MARK;
        live++;
      }
      p++;
    }
    if (n == heaps[i].limit && freed > free_min) {
      RVALUE *pp;
      
      heaps[i].limit = 0;
      for (pp = final_list; pp != final; pp = pp->as.free.next) {
          pp->as.free.flags |= FL_SINGLETON; /* freeing page mark */
      }
      freelist = free;  /* cancel this page from freelist */
    }
    else {
      freed += n;
    }
  }
  if (malloc_increase > malloc_limit) {
      malloc_limit += (malloc_increase - malloc_limit) * (double)live / (live + freed);
      if (malloc_limit < GC_MALLOC_LIMIT) malloc_limit = GC_MALLOC_LIMIT;
  }
  malloc_increase = 0;
  if (freed < free_min) {
      add_heap();
  }
   ::       ::       ::    ::
   ::       ::       ::    ::

(gc.c)
</pre>

h3. Finalizers
 
      Ruby supplies two methods for managing finalization processing for objects.&nbsp&nbsp They are:<br>
&nbsp&nbsp 1)&nbsp ObjectSpace.define_finalizer<br>
&nbsp&nbsp 2)&nbsp ObjectSpace.undefine_finalizer<br><br>
Defined finalizers are maintained in the hash table <i>finalizer_table</i>.&nbsp&nbsp This table is indexed by the Object's VALUE and contains a reference to a <i>proc block</i>.

 
Unfortunately,&nbsp two more <u>depreciated</u> methods must also be handled.&nbsp&nbsp They are:<br>
&nbsp&nbsp 1)&nbsp ObjectSpace.add_finalizer<br>
&nbsp&nbsp 2)&nbsp ObjectSpace.remove_finalizer<br><br>
These finalizers are held in the table <i>finalizers</i>.&nbsp&nbsp This table is indexed by the Object's ID and contains a reference to a <i>proc block</i>.&nbsp&nbsp As noted these are depreciated methods and are meant to be eventually removed.
 
 Let us look closer at the section above responsible for finalizer processing(shown below).&nbsp&nbsp When the first&nbsp <b>define_finalizer()</b>&nbsp method is executed,&nbsp the variable <i>need_call_final</i>&nbsp is set to one(1).&nbsp&nbsp This enables the checking for finalizers.&nbsp&nbsp Surprisingly,&nbsp the flag is never cleared once set.&nbsp&nbsp Even if all finalizers are undefined.
 
<pre class="graylist">
   ::       ::       ::    ::
   if (need_call_final && FL_TEST(p, FL_FINALIZE)) {
     p->as.free.flags = FL_MARK; /* remain marked */
     p->as.free.next = final_list;
     final_list = p;
   }
   else {
     p->as.free.flags = 0;
     p->as.free.next = freelist;
     freelist = p;
   }
   ::       ::       ::    ::
</pre>
 
Remember at this point in the processing the current object is <i>unmarked!</i>.&nbsp&nbsp If the FL_FINALIZE Flag is set for the current object,&nbsp the object is placed on the <i>final_list</i> and <i>marked</i>.&nbsp&nbsp For those that are wondering why the object is being marked again,&nbsp it must now persist in it's new state until the <i>proc</i>&nbsp associated with the finalizer is actually  executed.
 
 
If FL_FINALIZE is not set, the object is placed on the <i>free_list</i>. 
 
 
Finalizers are only executed at the completion of garbage collection and at program exit.

h3. Run_final

The function <b>run_final()</b>,&nbsp as shown below,&nbsp handles executing the <i>finalizer proc's</i>.
 

<pre class="graylist">
static void
run_final(obj)
    VALUE obj;
{
    long i;
    int status, critical_save = rb_thread_critical;
    VALUE args[3], table, objid;

    objid = rb_obj_id(obj); /* make obj into id */
       ::       ::       ::    ::
       ::       ::       ::    ::
     /* Code for Depreciated 'add_final' method */
       ::       ::       ::    ::
       ::       ::       ::    ::
    if (finalizer_table && st_delete(finalizer_table, 
                  (st_data_t*)&obj, &table)) {
      for (i=0; i<RARRAY(table)->len; i++) {
        VALUE final = RARRAY(table)->ptr[i];
        args[0] = RARRAY(final)->ptr[1];
        if (!args[1]) args[1] = rb_ary_new3(1, objid);
        args[2] = FIX2INT(RARRAY(final)->ptr[0]);
        rb_protect((VALUE(*)_((VALUE)))run_single_final, 
                   (VALUE)args, &status);
      }
    }
    rb_thread_critical = critical_save;
}

(gc.c)
</pre>
 
This function processes the <i>finalizer_table</i>&nbsp created by the <b>define_finalizer()</b>&nbsp method.&nbsp&nbsp The finalizer parameters are referenced through the hash table <i>finalizer_table</i>.&nbsp&nbsp The <i>hash key</i>&nbsp is the target Object's VALUE Pointer and <i>hash value</i>&nbsp is a VALUE pointer to the <i>Block Array</i>.
 
 
The Block Array contains one VALUE Pointer to a <i>Command Array</i>&nbsp for each <b>define_finalizer()</b>&nbsp method call applied to a specific object.&nbsp&nbsp If <b>define_finalizer()</b>&nbsp was called twice for the same object,&nbsp the Block Array will contain two entries.
 
 
Each VALUE pointer in the Block Array references an array containing three entries,&nbsp cmd,&nbsp args,&nbsp and safe_level.&nbsp&nbsp The <i>proc</i>&nbsp object is executed by feeding these three entries to the <u>rb_eval_cmd()</u>&nbsp function.
 


<img src="images/ch_gc_finalizer_structure.png" alt="(finalizer structure)"><br>
<br>Figure 16: Finalizer Structure






h3.  Rb_gc_force_recycle () 
 
There comes a time when you wish to kill an object with extreme prejudice!&nbsp&nbsp Not at some undetermined time later,&nbsp <i>now!</i>.&nbsp&nbsp While this facility is not available the user,&nbsp it is available to internal routines where the consequences are determinate.&nbsp&nbsp In any case,&nbsp <b>rb_gc_force_recycle()</b>&nbsp will clear the objects flags(i.e. effectively deleting the object) and places the object on the <i>freelist!</i>. 

 
A word of warning though,&nbsp <b>rb_gc_force_recycle()</b>&nbsp does not release any memory allocated by the object.&nbsp&nbsp Failure to take this into account will lead to <i>memory leaks!</i>


<pre class="graylist">
void
rb_gc_force_recycle(p)
    VALUE p;
{
    RANY(p)->as.free.flags = 0;
    RANY(p)->as.free.next = freelist;
    freelist = RANY(p);
}

(gc.c)
</pre>

h2. Timing of starting

h3.  Inside gc.c 
 
Where does Garbage Collection start?&nbsp&nbsp There are three primary places:
 
<pre class="greenlist">
1.  Ruby_xmalloc()
2.  Ruby_xrealloc()
3.  Rb_newobj()
</pre>

These are the functions that allocate space for objects,&nbsp both the object itself and any axillary space needed.&nbsp&nbsp Axillary space consists of things like space for strings and other data structures.

 
The functions <b>Ruby_xmalloc()</b> and <b>Ruby_xrealloc()</b> are used by a variety of internal functions to process requests for additional memory.&nbsp&nbsp When a memory allocation request fails,&nbsp these functions call <b>garbage_collect()</b>&nbsp to free up memory.&nbsp&nbsp A second failure will cause Ruby to generate a memory allocation error and exit.


The function <b>rb_newobj()</b>&nbsp is used to create new objects.&nbsp&nbsp When there are no objects on the <i>freelist</i>,&nbsp the function <b>garbage_collect()</b> is run to free up the space allocated to "dead" objects.&nbsp&nbsp When this does not create enough free objects,&nbsp a new heap is created.&nbsp&nbsp As above,&nbsp failure to allocate memory will cause Ruby to print an error and exit.
 


h3. Inside interpreter
 
Inside the interpreter there are numerous places where memory must be allocated,&nbsp such as opening files.&nbsp&nbsp In these and other cases when memory is required,&nbsp the function <b>rb_gc()</b>&nbsp is called and this function calls <b>garbage_collect()</b>. 
 
 
The Ruby statements <i>GC.start</i>,&nbsp <i>gc.garbage_collect</i>,&nbsp and <i>ObjectSpace.garbage_collect</i>&nbsp all call <b>rb_gc()</b>&nbsp directly. 
 

h2. Formation of object
 
The story of Garbage Collection has ended.&nbsp&nbsp We have discussed the reclamation of dead objects.&nbsp&nbsp We now need to further discuss the formation of objects.&nbsp&nbsp While this was done to some degree during the previous chapter for Classes,&nbsp we will continue the discussion in the following sections. 
 

h3. Allocation framework
 
We have covered the formation of several types of objects.&nbsp&nbsp Here we tackle the creation of a class instance with the 'new' method.
 
<pre class="graylist">
    ::     ::   ::
  class C
  end

  C.new()
    ::     ::   ::
  
(<somefile&gt.c)
</pre>
 
We can guess that&nbsp <b>C.new()</b>&nbsp will create an object.
 
 
But how is this accomplished?&nbsp&nbsp With most languages,&nbsp this sort of operation would be handled internally by the interpreter.&nbsp&nbsp In Ruby,&nbsp this and many other operations are handled by&nbsp<i>predefined methods</i>.&nbsp&nbsp As part of the initialization of the Ruby interpreter,&nbsp all the built-in objects and their methods are created before interpretation begins.&nbsp&nbsp The following is a portion for the initialization code for Objects. 
<pre class="graylist">
void

Init_Object()
{
    ::          ::          ::      
    rb_define_alloc_func(rb_cObject, rb_class_allocate_instance);
    ::          ::          ::      
    rb_define_method(rb_cClass, "new", rb_class_new_instance, -1);
    ::          ::          ::      
}

(object.c)
</pre>

 Let's set aside the first statement for minute and consider the second statement.&nbsp&nbsp This statement calls a function that adds the <i>method</i>&nbsp <b>new()</b>&nbsp to the class <i>Class</i>.&nbsp&nbsp This means when a <b>new()</b>&nbsp method is specified for a class,&nbsp the function <b>rb_class_new_instance()</b>&nbsp is executed.
 

<pre class="graylist">
VALUE
rb_class_new_instance(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE obj;

    obj = rb_obj_alloc(klass);
    rb_obj_call_init(obj, argc, argv);

    return obj;
}

(object.c)
</pre>
 
How does the interpreter "know" which allocation function to use when creating an object?&nbsp&nbsp Since different objects can be allocated differently,&nbsp then each type of object should have a way to define the allocation function.&nbsp&nbsp That method is called appropriately <b>rb_define_alloc_func()</b>.&nbsp&nbsp Notice that this is the first statement highlighted in <b>Init_Object().</b>
 



 
For class allocation,&nbsp the allocation function <b>rb_class_allocate_instance()</b>&nbsp is called by <b>rb_obj_alloc()</b>
 

<Pre class="graylist">
static VALUE
rb_class_allocate_instance(klass)
    VALUE klass;
{
    NEWOBJ(obj, struct RObject);
    OBJSETUP(obj, klass, T_OBJECT);
    return (VALUE)obj;
}

(object.c)
</pre>

 
This allocation function, and many others, makes use of the macro's NEWOBJ and OBJSETUP to create an appropriate object structure and install the specified values.&nbsp&nbsp 

<pre class="graylist">
 #define NEWOBJ (obj and type) type *obj = (type*) rb_newobj ()

 #define OBJSETUP (obj, c, t) do {\
   RBASIC (obj) -> Flags = (t); \
   RBASIC (obj) -> Klass = (c); \
   if (rb_safe_level () > = 3) FL_SET (obj and FL_TAINT);\
  While (0)

(ruby.h)
</pre>
 
The NEWOBJ&nbsp macro calls <b>rb_newobj()</b>,&nbsp which fetches the next&nbsp RVALUE&nbsp slot off the
<i>freelist</i>.&nbsp&nbsp Additionally, it sets the entire RVALUE block to zero.
 
 
The OBJSETUP&nbsp macro sets the <i>Klass</i>&nbsp and <i>Flags</i>&nbsp words in the object.&nbsp&nbsp It also sets the FL_TAINT flag if necessary. 
 
 
Returning to the discussion of <b>rb_class_new_instance()</b>&nbsp above.&nbsp&nbsp When control returns from <b>rb_obj_alloc()</b>,&nbsp the new object is initialized by calling <b>rb_obj_call_init()</b>.&nbsp&nbsp For a new class object this entails no further action and the function <b>rb_obj_dummy()</b>&nbsp is called.
 



 
Creating a class object using the <b>new()</b>&nbsp command involves only the following generic steps:
 
<pre class="graylist">
SomeClass.New = Class#new (rb_class_new_instance)
    SomeClass.Allocate = Class#allocate (rb_class_allocate_instance)
    SomeClass#initialize = Object#initialize (rb_obj_dummy)
</pre>


h3. Formation of user definition objects
 
This section is concerned with the formation of <i>user defined</i>&nbsp objects with the extended library.&nbsp&nbsp The extended library API contains three functions for handling these type of objects.
 
<pre class="greenlist">
1. Data_Wrap_Struct - Wraps a value/structure in a Ruby RData Object
2. Data_Make_Struct - Allocates Memory for a 'c-type' and wraps it
3. Data_Get_Struct&nbsp - Returns Pointer to the wrapped structure
</pre

<img src="images/ch_rdata_object.png" alt="(RData Structure)"><br>
<br>Figure 17: RData Structure


The <b>RDATA</b>&nbsp structure is the ruby object structure used to 'wrap' <i>user defined</i>&nbsp objects.&nbsp&nbsp Other than the standard <b>basic</b>&nbsp structure, the three other items are used as follows:


<b>*dmark</b>&nbsp points to a function for <i>marking</i>&nbsp Ruby Object references.&nbsp&nbsp This is only necessary if your structure contains references to Ruby objects.&nbsp&nbsp If so,&nbsp you must supply a function (pointed to by <b>*dmark</b>)&nbsp that will call <b>rb_gc_mark()</b>&nbsp for each reference to a Ruby Object.&nbsp&nbsp If no function is needed,&nbsp  then <b>*dmark</b>&nbsp may be set to zero.<br><br>
<b>*free</b>&nbsp points to a user function to free the user defined objects,&nbsp the system function <i>free()</i>,&nbsp  or a '-1'&nbsp to just to free the memory pointed to by <b>*data_ptr</b>.&nbsp&nbsp Note that both specifying <i>free()</i>&nbsp and '-1' accomplish the same thing,&nbsp the choice is up to the user.<BR><BR>
<b>*data_ptr</b>&nbsp points at the user defined structure 'wrapped' by the <b>RDATA</b>&nbsp Object.


h4.  Data_Wrap_Struct()&nbsp&nbsp and&nbsp&nbsp Data_Make_Struct()
<BR>
The <b>Data_Wrap_Struct()</b>&nbsp function is called as follows:
<pre class="graylist">
<font size=-1>Wrap_Data_Struct( VALUE class, void (*dmark)(), void (*free)(), *ptr )</font>
</pre>
 
The purpose of <b>Data_Wrap_Struct()</b> is to encapsolate a user defined value or structure in a Ruby <i>RData</i>&nbsp Object. Let us look at a simple example:
 
<pre class="graylist">
typedef struct adot {
  int horz;
  int vert;
} ADot;

ADot *ptr;
VALUE info

ptr = ALLOC(ADot);
ptr->horz = 0;
ptr->vert = 0;

info = Data_Wrap_Struct( cDots,&nbsp 0,&nbsp free,&nbsp ptr);
</pre>
 
Though not shown here, this code refers on a user defined class named <i>cDots</i>.&nbsp&nbsp This class is not particularly important beyond the need for a specific class to be specified.
 
 
Since the encapsulated structure does not refer to any other Ruby Objects,&nbsp a <b>*dmark</b>&nbsp function pointer does not need to be specified.&nbsp&nbsp Further,&nbsp because the structure does not have references to other user defined allocations,&nbsp the method <b>free</b>&nbsp is all that is required for freeing the <i>ADot</i>&nbsp structure.&nbsp&nbsp The value '-1'&nbsp could have been used instead of specifying <b>free</b>&nbsp and produced the same result. 
 
 
As you can guess,&nbsp the <i>ptr</i>&nbsp value points a the starting address of a <i>ADot</i>&nbsp structure.&nbsp&nbsp 


In conclusion,&nbsp it returns a VALUE pointer to a <i>RData</i>&nbsp object.
 
 
The <b>Data_Make_Struct()</b>&nbsp function is called as follows:
<pre class="graylist">
<font size=-1>Data_Make_Struct( VALUE class, c-type, void (*dmark)(), void (*free)(), (c-type) *ptr )</font>
</pre>
 
The primary difference between these functions is that <b>Data_Make_Struct()</b>&nbsp performs the allocation of the 'c' data structure for you.&nbsp&nbsp Presented here is another version of the previous example.&nbsp&nbsp It uses <b>Data_Make_Struct()</b>&nbsp instead of <b>Data_Wrap Struct().</b> 
 
<pre class="graylist">
typedef struct adot {
  int horz;
  int vert;
} ADot;

ADot *ptr;
VALUE info

info = Data_Wrap_Struct( cDots,&nbsp ADot,&nbsp  0,&nbsp free,&nbsp ptr);

ptr->horz = 0;
ptr->vert = 0;
</pre>
 
While the use of <i>ptr</i>&nbsp in this case to initialize the structure is valid,&nbsp you should generally use the method <b>Data_Get_Struct()</b>&nbsp to fetch the address of the encapsulated structure. 
 
 
The definitions for <b>Data_Wrap_Struct</b> and  <b>Data_Make_Struct</b>are defined as macros. 
 
<pre class="graylist"><font size=-1>
/*
#define RUBY_DATA_FUNC(func) ((void (*)_((void*)))func)
*/
typedef void (*RUBY_DATA_FUNC) _((void*));

VALUE rb_data_object_alloc _((VALUE,void*,RUBY_DATA_FUNC,RUBY_DATA_FUNC));

#define Data_Wrap_Struct(klass,mark,free,sval)\
    rb_data_object_alloc(klass,sval,(RUBY_DATA_FUNC)mark,(RUBY_DATA_FUNC)free)

#define Data_Make_Struct(klass,type,mark,free,sval) (\
    sval = ALLOC(type),\
    memset(sval, 0, sizeof(type)),\
    Data_Wrap_Struct(klass,mark,free,sval)\
)

(ruby.h)
</font></pre>
 
The function <b>Data_Make_Struct</b>&nbsp uses <b>Data_Wrap_Struct</b>&nbsp to actually create the desired <i>RData</i> Object.&nbsp&nbsp So in both cases that actual creation of the object is accomplished with the function <b>rb_data_object_alloc()</b>
 



<pre class="graylist">
VALUE rb_data_object_alloc(klass, datap, dmark, dfree)
    VALUE klass;
    void *datap;
    RUBY_DATA_FUNC dmark;
    RUBY_DATA_FUNC dfree;
{
    NEWOBJ(data, struct RData);
    if (klass) Check_Type(klass, T_CLASS);
    OBJSETUP(data, klass, T_DATA);
    data->data = datap;
    data->dfree = dfree;
    data->dmark = dmark;

    return (VALUE)data;
}

(gc.c)
</pre>



h4.  Data_Get_Struct () 
 
The <b>Data_Get_Struct()</b>&nbsp function is called as follows:
<pre class="graylist">
<font size=-1>Data_Get_Struct( VALUE object, c-type, (c-type) *ptr )</font>
</pre>
 
This function returns a c-type pointer to the value or structure embedded in a <i>RData</i>&nbsp Object.&nbsp&nbsp The definition for <b>Data_Get_Struct</b>&nbsp is a macro and it's definition is as follows:
 
<pre class="graylist">
#define Data_Get_Struct(obj,type,sval) do {\
    Check_Type(obj, T_DATA); \
    sval = (type*)DATA_PTR(obj);\
} while (0)

(ruby.h)
</pre>
 
The following is an example of how to retrieve data from a <i>RData</i>&nbsp object.&nbsp&nbsp In this case we examine the data stored in the examples above: 
 
<pre class="graylist">
typedef struct adot {
  int horz;
  int vert;
} ADot;

ADot *sval;
VALUE info;

int HORZ;
int VERT;

Data_Get_Struct( info, ADot, sval);

HORZ = sval->horz;  
VERT = sval->vert;
</pre>
<hr>

The original work is Copyright &copy; 2002 - 2004 Minero AOKI.<br>
Translations,&nbsp additions,&nbsp and graphics by C.E. Thornton<br>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/"><img alt="Creative Commons License" border="0" src="images/somerights20.jpg"/></a><br/>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/">Creative Commons Attribution-NonCommercial-ShareAlike2.5 License</a>.

