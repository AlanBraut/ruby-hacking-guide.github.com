---
layout: default
---

h1. chapter 5<br>Garbage Collection


h2. Execution time program image

This chapter will abruptly subject the reader to a discussion
of various low level issues.   First,  the Ruby 'C' program
memory structure,  followed by the Memory Structure supporting
the actual Ruby Language execution.   This may be tough going for some readers,  but this chapter is important to understanding later chapters.


h3. C  Program Memory Structure

A general a 'C'   program has the following basic memory structure.

<pre class="greenlist">
1. Program Code Space
2. Constants, Static variables, and global variables
3. Machine stack
4. Heap, ;also refered to a <i>Free Store</i>.
</pre

Items 1 and 2 are generally contained in the load image.   Items 3 an 4 are setup by program initialization.



Once a 'C' program is initialized,   it contains at least three seperate
memory segments.    Program Code,   Globals,   and static variables are
generally in the load image stored in Text Memory.    Arguments and local
variables of functions are stored on the Machine Stack.  Lastly,   the program can also
acquire additional memory from the Free Store (also refered to as the <i>Heap</i>).



The third item should to well known to most programmers.   The <i>Machine Stack</i>
is implemented by the processor hosting Ruby.
In Figure 1a.  the stack is shown growing toward higher addresses.   This is not universal,   the X86 Memory Stack,  Figure 1b,   grows toward the lower addresses.



<img src="images/ch_gc_macstack_2a.jpg" alt="(Macstack)"><br>
<br>Figure 1: Machine Stacks



 The Ruby language program uses the
the Machine Stack to handle it's stack operations.   The small items, like Integers and arguments are pushed onto the Machine Stack by the underlying code generated by the
'C' Compiler.

As we will see, the ruby interpreter pushes larger blocks of data onto the Machine Stack.   These blocks are called a <i>Stack Frames</i>.   The Stack Frame is a predefine memory block that allows Ruby push structured data onto the Machine Stack.   Ruby also pushes various other structured and unstructured data onto the stack.



The <i>Stack Frame</i> corresponds to a <i>Ruby Function Call</i>.   When the function returns,   the Stack Frame is poped from the Machine Stack!   The left side of  Figure 2 shows the  stack after the Ruby Function 'D' is called.   The right shows the stack after returning from the functions 'D' & 'C'.


<img src="images/ch_gc_nalloca.jpg" alt="(Macstack)"><br>
<br>Figure 2: Machine Stack - Using native alloca


h3.  Alloca() vs Malloc()


The <b>malloc()</b>  function returns a pointer to a block of memory of the
size requested, of a Null pointer to indicate an error.   The memory block
is obtained from the <i>Heap</i>.   Memory Blocks acquired using malloc() must eventually be returned to the Heap via <b>Free()</b>  function.


The <b>Native alloca()</b>  function is a different animal.   This function is a very low level function without many safeguards!   This function is
generally implemented as in-line function generated by the complier.   The requested memory block is allocated on the Machine Stack.   Thus,   when the function that called alloca() returns the memory block evaporates.   The inlined code is generally a single instruction adjusting the stack pointer,
it does not check for stack overflow,   and there is no NULL error return.





The use of <b>Native alloca()</b>  is good in the respect that is simple and
can improve execution times when used appropriately.



Now for the "fly in the ointment"!   The sad fact is that <b>Native alloc()</b>  is not supported by all host systems and compilers used to execute the Ruby Language Program (i.e.  the Ruby Interpreter).   The parts of the
Ruby interpreter that use <i>alloca()</i>  determine which implementation of
alloca() to use.


The <b>Alloca() Emulation</b>  code is provided by <i>missing/alloca.c</i>.



The <b>alloca emulation</b>  function uses a linked list to manage the allocation and release of the acquired memory.   Each entry in the linked list consists of a header and a block of memory.   Each Header contains a pointer to the next entry (if any)   and the current Machine Stack location.   A <i>List Element</i>  is made up of a <i>Header</i> (described above) followed by a <i>Size</i>  block of memory.




<img src="images/ch_gc_calloca_list_full.jpg" alt="(Calloca)"><br>
Figure 3: Alloca Emulation linked list diagram


This list and it's operations are controlled by one function,  alloca()     This is necessary to maintain compatibility with Native Alloca.


 When a user calls alloca(),   the function performs Garbage Collection.   The Garbage Collector steps backward through the linked List removing all List Elements where the recorded depth is deeper in stack than the current Machine Stack pointer.   After garbage collection is finished, a new List Element is created and placed a the top of the linked list.


If the <i>size</i>  is zero, the function returns after the garbage collection is perfomed and does not create a List Element

This is important to remember that until the next alloca() call the linked
list remains untouched.  While a List Element may exist beyond the point
where calling function returns,  it will evaporate the next time the alloca() function is called.

The Figure below shows the results after the return of 'D' and 'C' and the next garbage collection cycle caused by a alloca() call.   The figure below does not show creation of the next List Element,   if any.


<img src="images/ch_gc_calloca_list.jpg" alt="(Calloca)"><br>
Figure 4: Alloca Emulation linked list diagram


The <b>missing/alloca.c</b>  function emulates the Native Alloca()  on host systems or compilers that do not support the native alloca().


h2. GC ... Explanation


We have discussed the underlying support for stack resident memory allocation and it's emulation for those host systems and compilers that do not have Native alloca support.  The balance of this chapter will be the
management of the Heap.

</pre>
h3. GC

Normally,   objects reside in memory and at the conclusion of the program these memory resident objects are released along the other memory resources used by the program.    As long as the memory space is large enough to provide all the memory requested, things work fine!


In actuallity,   <i>memory is always a limited resource</i>.   Even if the user has access to all them memory available, even  small amounts of discarded memory add up to very large values for long running programs.   Almost all programs will acquire blocks of heap memory.   When these resources are not released properly,  the accumlation of this memory debris is called a <i>Memory Leak</i>.


The control of the memory resources is always a available to the programmer by using <b>malloc()</b> , and <b>free()</b>.   In Object Oriented programs knowing when to release objects from memory can become
difficult due to complex object references.
 Ruby relieves the programmer of much of this complexity by managing object memory allocation and release automatically.   Ruby handles this task,  as many other languages do,   by using a <i>Garbage Collection</i>   Scheme.



Ruby uses a modified version of the <i>Boehm-Demers-Weiser garbage collector </i>,   generally known as simply <i>Boehm GC</i>.   With this function there is no need release the memory allocated for Ruby objects and other automatically allocated memory.   The Ruby Garbage Collector,   hereafter refered to as just GC,   manages both the allocation and release of these memory resources.



The issue of <i>Heap Memory Compaction</i> arises in many discussions of the various implementations of Boehm GC.   Many programs that the use a
Garbage Collector,   often face issues of memory fragmentation.   Ruby does not implement memory compaction,   but does not generally suffer from crippling heap fragmentation.

One reason for this is that the basic object structures are all the same size.   It is also true that some objects,   strings leap to mind,   allocate additional memory to hold the string value.
The <i>free store</i>  or <i>heap</i>  storage algorithm is controll at a low level by the
<i>malloc</i> functiion.  This, and other issues concernint the Ruby GC will be covered in a later section.


The Boehm GC has been used successfully in many systems.   More information on Boehm GC is available at: <b>http://www.hpl.hp.com/personal/Hans_Boehm/gc</b>.

Recent languages such as Java and Perl, Python, C#, and Eiffel use Garbage Collection.  The rest of this chapter will be devoted to the details of Ruby's Garbage Collector.


h3. What is Garbage Collection?


The first question is what is GC trying accomplish.   The GC allocates memory from the
 <i>heap</i>  for <i>objects</i> and memory controlled by Objects.   Additionally, and
most importantly,   it manages this resource and reclaims the allocated memory from the program when it is
no longer in use.   This releaves the programmer of the task of keeping track of allocated memory and releasing it when no longer needed.

Ruby's GC is,  as are most Garbage Collectors,
  is composed of three  main sections.   The first is <i>Memory
Allocation</i>,  the second is <i>Garbage Detection</i>,  and the last is <i>Garbage Reclarmation</i>.

<i>Memory Allocation</i>  functions control access to the memory set aside for GC functions.
   This memory is initially allocated from Heap Memory at program initialization.  When this
initial allocation of memory is exhausted, Ruby will perform Garbage Collection.   If there is
still not enougth memory to satisfy the allocation request,   another block of memory is requested and added to the memory controlled by the Garbage Collector.


The various memory
allocation functions return blocks of memory of the requested sizes.   These functions also
maintain lists of memory that is allocated and memory that is available for allocation.    In addition to being used by memory allocation functions, these lists are
also updated  by the <i>Garbage Reclarmation</i>  processing.


<i>Garbage Detection</i> is the process of determining which objects are still in use.  These objects
are <i>Live Objects</i>  and will be preserved.    Conversely, all other objects are considered "Dead" and no longer
viable.   These objects, called <i>garbage</i>,  are processed by the <i>Garbage Reclarmation</i>  section.

<i>Garbage Reclarmation</i> section of GC attempts to find all the memory being used by the so
called <i>Garbage Objects</i> and returns it
to the <i>Memory Allocation</i> functions by updating the lists of available memory.
The memory returned is not just the object itself,   but any addtional memory attached to the basic
object.   In Ruby for example, <b>Fixnum,  true,  and false</b>  are all completely contained the basic object structure.
   <b>Strings</b>,  on the other hand,  allocate additional memory to hold the actual
character string.


h3. Survey of garbage collector types

The following sections discuss several general methods for performing<i>Garbage Collection</i>.
We briefing discuss the major types,  their weaknesses and strengths.   Bear in mind the <i>Mark and Sweep</i>  is the type used by Ruby.


h3. Mark & sweep


The <b>Mark phase</b> finds <i>live</i> objects and <i>marks</i>  them to prevent the
GC from deallocating the associated memory.   It performs this task by defining a <i>Root Set</i>  of known viable objects and tracing their connections to other objects.


The <i>Root Set</i>  are objects referenced by:

# Ruby Global Variables and Constants
# Ruby live Local Variables
# The machine stack
# Objects referenced by 'C' Global Variables registered by  <b>rb_gc_register_address()</b>



<img src="images/ch_gc_gcimage.jpg" alt="(Gcimage)"><br>
Figure 5: Root Set trace of live objects


The set of objects found by the sweep phase that are not <i><b>marked</b></i>   are considered <i>dead objects</i>,
also called <i>garbage.</i>


<b>Mark and Sweep Merits:</b><br>

# While Mark & Sweep GC's normally have problems with memory fragmentation, Ruby GC is somewhat
immune to this problem because the common size of Ruby Objects.
# One other advantage is that Mark & Sweep can release a <i>cycle</i>.   See the section on Reference Counting for a discussion of this problem.



<b>Mark and Sweep Deficiencies</b><br>

# The minimum time it takes to run one Mark and Sweep Cycle is directly proportional to the
number of Managed Objects.   Each object must be 'touched' at least once.   All live objects must be <i>marked</i> and all garbage objects must be <i>collected</i>.
# Because the Mark and Sweep cycle locks out other processing while it runs,  the GC can make a noticable dent in a programs performace.




h3. Stop & copy

This method is a modification of the Mark and Sweep Garbage Collector.   The managed heap space is divided into two sections.   One is the current active heap and the other is empty, call them A and B.   Any any one time, only one these heaps  will be active!   The GC allocates new objects in the active heap.


<img src="images/ch_gc_stop2.jpg" alt="(Stop2)"><br>
Figure 6: Stop & copy (1)


When the GC Runs, it transverses  all active objects in the same way as Mark and Sweep.   However, the live objects are transferred to the inactive heap instead marking them.   When the Mark phase is complete, the inactive heap is made the active heap.   The freshly inactivated heap only contains garbage objects and thus they are implicitly collected.   This is, the inactive area is <i>considered</i> empty!



<img src="images/ch_gc_stop3.jpg" alt="(Stop3)"><br>
Figure 7: Stop & copy (2)



<b>Stop and Copy Merits:</b><br>

# The live objects are essentially compacted during the Garbage Collection cycle.
# This additonally improves the <i>locality</i> of live objects.   Since they are all located near each other, they reduce memory paging in a virtual memory system.   There is a much higher probabilty that referneces will be in the memory cache.
# Like it's cousin Mark and Sweep, this method also is able to collect <i>cycles</i>.



<b>Stop and Copy Deficiencies</b><br>

# The time to copy objects to the inactive heap takes longer than simply marking a live object.
# The position of the objects change.   The relocation of references may take a signigicant amount of processing.



h3. Reference counting

A Reference Counting Garbage Collector is different from the other types of GC's we have discussed so far.   In this method,   each object has a <i>reference counter</i>  associate with it.   This counter is incremented by one each tiem a new reference pointer is created that points to a particular object.   For example, when a pointer is copied from one place to another by an assignment statement.


When a referece to an object is removed, the counter is decremented by one.   When the reference counter becomes zero,  the object is collected,  e.g.,  the memory allocated for the object is reclaimed.


<img src="images/ch_gc_refcnt.jpg" alt="(Refcnt)"><br>
Figure 8: Reference counting example

<b>Reference Counting Merits:</b><br>

# The processing load imposed by the Garbage Collector is distributed across the whole execution of the program.
# Objects are, theorically, released the moment they can no longer be reached by the program.



<b>Reference Counting Deficiencies</b><br>

# The most serious problem with reference counting is that is it not always <i>effective.</i>    The inability to handle <i>cycles</i>  is discussed below.
# Reference counting is very hard to make <i>efficient.</i>   Since every time a refernce to an object is created or destroyed, a reference counter must be incremented or decremented.   This adds more overhead to the processing of objects and references.
# Additionally, if the reference counter for a large complex object structure becomes zero, it can cascade through references finding other referneces becoming zero.   In some cases this may cause a noticable performace hit.



As mentioned above, a major deficiency of reference counting is handling <i>cycles.</i>  These are a group of objects that form a circular structure.  A simple example is shown below:


<img src="images/ch_gc_cycle.jpg" alt="(Cycle)"><br>
Figure 9: Cycle


As you can see, even if such a structure loses the last reference from an external object,   the counters will never reach zero.



h2. Management of Ruby objects

The Ruby GC only manages <i>Ruby Objects</i> and other memory blocks <i>controlled</i>  by Ruby Objects.   Ruby Objects often acquire addtional memory to provide storage for a variety of purposes.   These include buffers to hold character strings,  memory to hold numeric values, memory to hold arrays and hashes.

While memory can be allocated directly from the heap by calling 'C' language functions,  this memory will not be managed by the  Ruby GC.   It is the Users resposibility to release any memory acquired in this manner.  Failure to release memory will result in a <i>memory leak</i>  , as shown below:
<br>
<pre class="graylist">
Void not_ok ()
{
    Malloc (1024);     /* Possible Memory Leak! */
}
</pre>

In the following case,  the user allocates memory for a Ruby object using the <i>Ruby API.</i>   Ruby will manage this block on memory automatically and release it when it is no longer in use.

<pre class="graylist">
Void this_is_ok ()
{
    Rb_ary_new ();    /* Object managed by the Ruby GC */
away, *
}
</pre>


h3.  Struct RVALUE


As we stated the Ruby GC only manages Ruby Objects.   This control is accomplished
using the basic Ruby object structure.   Ruby objects are always addressed with a
reference pointer of type RVALUE.

The struct RVALUE a union of Object Structures and System Structures.   There is one object structure for each ruby object type( object,   klass,   string,  ...),  and additonal objects to support the Ruby interpreter operations.

<pre class="graylist">

typedef struct RVALUE {
    union {
  struct {
      unsigned long flags;  /* always 0 for freed obj */
      struct RVALUE *next;
  } free;
  struct RBasic  basic;
  struct RObject object;
  struct RClass  klass;
  struct RFloat  flonum;
  struct RString string;
  struct RArray  array;
  struct RRegexp regexp;
  struct RHash   hash;
  struct RData   data;
  struct RStruct rstruct;
  struct RBignum bignum;
  struct RFile   file;
  struct RNode   node;
  struct RMatch  match;
  struct RVarmap varmap;
  struct SCOPE   scope;
    } as;
#ifdef GC_DEBUG
    char *file;            /* Internal Debugging Feature */
    int   line;
#endif
} RVALUE;

(Gc.C)
</pre>

Ruby GC managed memory contains two distinct types of data.   The first is the actual Ruby Objects,  which are always exactly 20 Bytes(40 Bytes on 64 bit Processors).   The other type is the additional memory allocated and referenced by these objects.   This memory is used to store data and table references.



Of the RVALUE Structures listed above,  only the ones itemized below represent the structures that implement Ruby Objects.

<pre class="greenlist">
<i>Struct</i> <b>RBasic </b>   - Preamble for all Structures(flags & Klass ptr)<br>
<i>Struct</i> <b>RObject</b>   - General Object - For things not applicable below
<i>Struct</i> <b>RClass </b>   - Class objects
<i>Struct</i> <b>RFloat </b>   - Integer Decimals (small & medium)
<i>Struct</i> <b>RString</b>   - Character strings
<i>Struct</i> <b>RArray </b>   - Arrays
<i>Struct</i> <b>RRegexp</b>   - Regular expression
<i>Struct</i> <b>RHash  </b>   - Hash table
<i>Struct</i> <b>RFile  </b>   - IO File,  Socket,  And so on
<i>Struct</i> <b>RData  </b>   - Class for describing everything for 'C' level
<i>Struct</i> <b>RStruct</b>   - The structure of Ruby Struct Class
<i>Struct</i> <b>RBignum</b>   - Big integer
</pre>


The importance of the  <b>RVALUE Structure</b> can not by over emphasized.   This is the core of the Ruby Interpreter.   It not only expresses all Ruby objects,  but it also contains structures used by the Interpter itself.   All of these structures are same length and share a common preamble, the <b>RBasic Structure</b>.


The Structure Definition of RBasic is as follows:

<pre class="graylist">
  struct RBasic {
  unsigned long flags;
  VALUE klass;
  };

(ruby.h)
</pre>
The two structures most important to the operation of the Ruby GC are:
<pre class="greenlist">
1)  <i>Struct</i> <b>RBasic</b>
2)  <i>Struct</i> <b>as.free</b>
</pre>

As you will remember,   most of the RVALUE structures contain <b>RBasic</b>,  The only exceptions are <b>RNode</b>  and <b>SCOPE</b>.   In the case of <b>as.free</b>,  it reinterprets <b>RBasic</b> enteries only for the purpose of linking RVALUE blocks into the <b>*freelst</b>.

<pre class="greenlist">
<b>as.free</b>
unsigned long flags;   -- Always zero when added to the *freelist
struct RVALUE *next;   -- Points at next entry in the *freelist
</pre>

The construction of the <b>*freelist</b> ;will be  discussed shortly.


The <i>flags</i>  word in <b>RBasic</b>,  as explained in Chapter 02,  contains all the state information for a Ruby Object.


h3. Free Store Mapping


Due to the way the <i>malloc()</i>  functions,  the <i>free store</i>  memory is not always allocated in contiguous fashion.
   This is because malloc allocates  memory in various locations depending on the size
of the requested block.   Exactly where memory allocations will take place is beyond the scope of the document and is dependent on the exact implementation of <i>malloc()</i>!   However, since Ruby make one or more  very large allocations (<i>Ruby heap's)</i>   and many smaller allocations during object creation and Interpreter processing,  this generally results in only two primary locations for memory allocation.


The following is a plausible memory map for many processors running Ruby.


<img src="images/ch_gc_mem_map.png" alt="(Memory Allocation Map)"><br>
<br>
Figure 10: Memory allocation map




h3. Ruby object heaps


The Ruby Interpreter implements  a specialized memory management system for <i>Ruby Objects</i>
on top of the more general <i>Free Store</i>  management scheme provided by    <b>malloc()</b>,  <b>realloc()</b>,  and <b>free()</b>  functions.   Since Ruby Objects are fixed in size,   the Ruby GC can optimize their management.


The Ruby Object Heap,  hereafter called an Object Heap,   is implemented using two interrelated arrays. The array <b>heaps[ ]</b>  is the root structure.   Each element contains a <b>heaps_slot</b> structure.   Initially only the first elment of <b>heaps[ ]</b>  is instantiated.


The following code fragment show the important defines,   arrays,   and structures that support Object Heap contruction and management.



<pre class="graylist">
#define HEAPS_INCREMENT 10

#define HEAP_MIN_SLOTS 10000
static int heap_slots = HEAP_MIN_SLOTS;

static struct heaps_slot {
    void *membase;
    RVALUE *slot;
    int limit;
} *heaps;

static int heaps_length = 0;
static int heaps_used = 0;

(gc.c)
</pre>

The <b>heaps_slot</b>  structure contains three elements that describe an allocated array.   This array is often refered to as the <b>heap</b>.
It is made up of   <b>heap_slots</b>  number of elements,  refered to as a <b>slot</b>.   Each of these <b>slots</b>  is RVALUE sized.   In other words, each <b>slot</b> is an empty <i>object-sized</i>  block of memory that has been set to zero.


The last sentence above is important.   These <b>slots</b>  will eventully become <i>Ruby Objects</i>!



The three elements the <b>heap_slots</b>  structure  are:

<pre class="greenlist">
1) *membase - Points to the origin of the allocated memory block.
2) *slot    - The first properly "aligned" slot location in the heap.
              (*membase and *slot MAY or MAY NOT be the same address)
3) limit    - The total number of available "slots" in the heap.

</pre>

<img src="images/ch_gc_heapslot.png" alt="(Heapitems)"><br><br>
Figure 11: Relationship between the <b>heaps_slot</b> structure  and the <b>heap</b> it describes


The <b>*slot</b>  value is necessary because the starting address of the <b>heap</b>  <i>must</i>  be evenly divisible by the size of RVALUE.   When this is not the case,   the nearest evenly divisible address thats greater than <b>*membase</b>  is used.


The <b>heaps</b>  structure is a array of <b>heaps_slot</b> elements. The variables
that control it's usage are:

<pre class="greenlist">
1) *heaps       - Base address  of an array of <b>heaps_slot</b> elements.
2) heaps_length - The number of elements in the <b>heaps</b> array.
3) heaps_used   - The number of elements in <b>heaps</b> array being used.
</pre>

<img src="images/ch_gc_heaps_all.png" alt="(Heapitems)"><br><br>
Figure 12: The <i>complete</i> <b>heaps</b> structure


h3.  Freelist

The <b>*freelist</b> is the repository of <i>object-sized</i>  memory blocks that will be
used to create new objects.   The list is created or extended by the <b>add_heap()</b>
 function by linking all the elements in a new heap into the <b>*freelist</b>.


Also remember, as objects are reclaimed during the <i>sweep phase</i>  these objects are also added to the <b>*freelist</b>.



This accomplished by steping through each element in the new heap and  perfoming the following actions until the array of new elements is exhausted.
<pre class="greenlist">
1) The heap element  is referenced through the <b>as.free</b>  structure.
2) The <b>as.flags</b> word is zero indicating it is a empty object, <b>as.*next</b>
   is set to the contents of the <b>*freelist</b>.
3) The <b>*freelist</b> is set to the address of the current heap element.
</pre>



<img src="images/ch_gc_free_linking.jpg" alt="(*freelist linking)"><br><br>
Figure 13: Freelist construction order



When the Ruby GC sweeps memory each object that is not <i>marked</i>  is added to the <i>free list</i>.   Any memory referenced by the object is simply freed and returned to free stote.   The <b>as.free</b>  entry is used to construct the <b>*freelist</b>.   The <b>as.flags</b>  word is cleared to indicate that the object is "free",  and the <b>as.*next</b>  entry is used to link the object into the <b>*freelist</b>  as shown above.




h3.  Add_heap ()

▼  Add_heap () (Concise edition)
<pre class="graylist">
Static void
add_heap()
{
    RVALUE *p, *pend;

// Section 1 -- Extend the length of Heaps Array (if necessary)
//
    if (heaps_used == heaps_length) {
  /* Realloc heaps */
  struct heaps_slot *p;
  int length;

  heaps_length += HEAPS_INCREMENT;
  length = heaps_length*sizeof(struct heaps_slot);
  RUBY_CRITICAL(
      if (heaps_used > 0) {
    p = (struct heaps_slot *)realloc(heaps, length);
    if (p) heaps = p;
      }
      else {
    p = heaps = (struct heaps_slot *)malloc(length);
      });
  if (p == 0) rb_memerror();
    }

// Section 2 - Create new Heap Array and compute Heap_slots values
//
    for (;;) {
  RUBY_CRITICAL(p =
           (RVALUE*)malloc(sizeof(RVALUE)*(heap_slots+1)));
  if (p == 0) {
      if (heap_slots == HEAP_MIN_SLOTS) {
    rb_memerror();
      }
      heap_slots = HEAP_MIN_SLOTS;
      continue;
  }
        heaps[heaps_used].membase = p;
        if ((VALUE)p % sizeof(RVALUE) == 0)
            heap_slots += 1;
        else
            p = (RVALUE*)((VALUE)p + sizeof(RVALUE) -
                   ((VALUE)p % sizeof(RVALUE)));
        heaps[heaps_used].slot = p;
        heaps[heaps_used].limit = heap_slots;
  break;
    }

// Section 3 - Compute Begin/End of Heap and Adjust Parameters
//
    pend = p + heap_slots;
    if (lomem == 0 || lomem > p) lomem = p;
    if (himem < pend) himem = pend;
    heaps_used++;
    heap_slots *= 1.8;
    if (heap_slots <= 0) heap_slots = HEAP_MIN_SLOTS;

// Section 4 - Add all new Slots to *freelist
//
    while (p < pend) {
  p->as.free.flags = 0;
  p->as.free.next = freelist;
  freelist = p;
  p++;
    }
}

(gc.c)
</pre>

The following discussion covers the sections noted in the code block above.



<b><i>Section 1:</i></b><BR>
When the initial allotted elements in the <b>heaps</b>  array has been exhausted, the
array must be expanded to hold additional elements.   The special case of initialization
is handled by the same code,  since the size <b>heaps_used</b>  and <b>heaps_length</b>  are both initially zero.


The length of the <b>heaps</b>  array is initially set to the value of the HEAP_MIN_SLOTS constant.   Thereafter, it is exapanded by the same value.



<b><i>Section 2:</i></b><BR>
This section attempts to allocate a new <b>heap</b>.   If allocation fails and the <b>heap_slots</b>  value is greater than the HEAP_MIN_SLOTS constant value,  an attempt is made to to allocate just HEAP_MIN_SLOTS.   If this also fails, Ruby aborts with memory failure.

If memory allocation is sucessful, the values for the <b>heaps_slot</b>  element are computed.   The <b>*membase</b> value is the address returned by the malloc function.   If this value can not be evenly divided by the size of RVALUE, the next heighest address that is evenly divisable is used for the <b>*slot</b>  value. Otherwise, the <b>*membase</b>  value is used for <b>*slot</b>.


<b><i>Section 3:</i></b><BR>
This section computes the beginning and end addresses for the new <b>heap</b>.   Next,  the number of <b>heaps_used</b>  is incremented.   Finally,   <b>heap_slots</b>  variable is multiplied by the constant '1.8'.   This means that each new <b>heap</b>  will be '1.8'  times larger that the last.   This is done to reduce the number times that the GC is called for programs with large numbers of objects.



<b><i>Section 4:</i></b><BR>
The last step is to link each element of the <b>heap</b> into the <b>*freelist</b>.   This provides Ruby with a large number of new "empty" objects to be used.


h3.  Rb_newobj ()

▼  rb_newobj ()
<pre class="graylist">

VALUE
rb_newobj()
{
    VALUE obj;

    if (!freelist) garbage_collect();

    obj = (VALUE)freelist;
    freelist = freelist->as.free.next;

    MEMZERO((void*)obj, RVALUE, 1);
    return obj;
}

(gc.c)
</pre>

When Ruby needs to create a new object,   the <b>rb_newobj()</b>  function is called.   This function performs the following basic operations:

<pre class="greenlist">
1) If the <b>*freelist</b> is empty, garbage collection is performed.
2) A new object is extracted from the <b>*freelist</b>.
3) The new object is cleared and returned to the caller.
</pre>

h2. Marking

This process is performed by marking that following objects and their descendants:

<pre class="greenlist">
1) global variables and constants in Ruby.
2) live local variables in Ruby
3) the machine stack
4) objects referenced by C global variables
   registerd by rb_gc_register_address()
</pre>

h3.  Rb_gc_mark ()


 rb_gc_mark()  - Simply Calls <b>gc_mark()</b>.

<pre class="graylist">
void
rb_gc_mark(ptr)
    VALUE ptr;
{
    gc_mark(ptr, 0);
}
</pre>
<pre class="greenlist">
The separation of   rb_gc_mark()  into two functions is a result of
<i>refactoring</i>. This allows the core processing functions of gc_mark() to
be modified for reuse in different contexts.  This is example of the
continuing work being done to not only add new functionality,  but to
improve the underlying code of the Ruby Interpreter.
</pre>


 gc_mark()  -  Recursively marks all live objects


<pre class="graylist">
static void
gc_mark(ptr, lev)
    VALUE ptr;
    int lev;
{
    register RVALUE *obj;

    obj = RANY(ptr);
    if (rb_special_const_p(ptr)) return; /* special const not marked */
    if (obj->as.basic.flags == 0) return;       /* free cell */
    if (obj->as.basic.flags & FL_MARK) return;  /* already marked */
    obj->as.basic.flags |= FL_MARK;

    if (lev > GC_LEVEL_MAX || (lev == 0 && ruby_stack_check())) {
      if (!mark_stack_overflow) {
        if (mark_stack_ptr - mark_stack < MARK_STACK_MAX) {
          *mark_stack_ptr = ptr;
          mark_stack_ptr++;
        }
        else {
         mark_stack_overflow = 1;
        }
      }
      return;
   }
   gc_mark_children(ptr, lev+1);
}

</pre>

The RANY definition allows the reference of <i>any</i>  object.   For this particular function,   it's purpose to reference the <b>flags</b>  word of each object processed.    It's definition
is shown below:

<pre class="graylist">
    #define RANY(o) ((RVALUE*)(o))

(gc.c)
</pre>


If the object is a special constant,  already <i>marked</i>,  or a 'free' object no further processing is performed.   Otherwise, the object is <i>marked</i> and further processing is required.


After the object being <i>marked</i>,  a bit of special processing takes place.   For purposes of program stability,  the depth of recursion during object tracing is limited.   When this depth is reached, an attempt is made to place the current object pointer onto a special axuillary stack, the <b>mark_stack</b>.


If the <b>mark stack</b>  is full, the the <b>mark_stack_overflow</b>  marker is checked.   If it is set, when the marking phase is finished,  all viable objects in all the heaps are marked.   This is necessary to insure that all 'live' objects will be <i>marked!</i>


If the <b>mark_stack_overflow</b>  marker is not set,  then all the objects on the <b>mark_stack</b> are passed to <i>gc_mark_children</i>.   When complete, the Ruby GC starts the <i>sweep</i>  phase.



h3.  gc_mark_children ()

The following is a abbreviated version of the source code for <b>Gc_mark_children()</b>.   The code contains two main sections.   The first processes the T_NODE Objects.   The second processes the standard Object Nodes.

▼  gc_mark_children ()
<pre class="graylist">

static void
gc_mark_children(ptr, lev)
    VALUE ptr;
    int lev;
{
#ifdef ENABLE_DBG
if (mute_flag != 0) {
printf("<gc.c>  gc_mark_children(...) at (923)\n");
}
#endif
    register RVALUE *obj = RANY(ptr);

    goto marking;   /* skip */

  again:
    obj = RANY(ptr);
    if (rb_special_const_p(ptr)) return; /* special const not marked */
    if (obj->as.basic.flags == 0) return;       /* free cell */
    if (obj->as.basic.flags & FL_MARK) return;  /* already marked */
    obj->as.basic.flags |= FL_MARK;

  marking:
    if (FL_TEST(obj, FL_EXIVAR)) {
  rb_mark_generic_ivar(ptr);
    }

    switch (obj->as.basic.flags & T_MASK) {
      case T_NIL:
      case T_FIXNUM:
  rb_bug("rb_gc_mark() called for broken object");
  break;

      case T_NODE:
  mark_source_filename(obj->as.node.nd_file);
  switch (nd_type(obj)) {
    case NODE_IF:   /* 1,2,3 */
    case NODE_FOR:
    case NODE_ITER:

          /*............ abbreviation............ */
  }
  return;     /* no need to mark class. */
  }

    gc_mark(obj->as.basic.klass, lev);
    switch (obj->as.basic.flags & T_MASK) {
      case T_ICLASS:
      case T_CLASS:
      case T_MODULE:
  mark_tbl(obj->as.klass.m_tbl, lev);
  mark_tbl(obj->as.klass.iv_tbl, lev);
  ptr = obj->as.klass.super;
  goto again;

      case T_ARRAY:
  if (FL_TEST(obj, ELTS_SHARED)) {
      ptr = obj->as.array.aux.shared;
      goto again;
  }
  else {
      long i, len = obj->as.array.len;
      VALUE *ptr = obj->as.array.ptr;

      for (i=0; i < len; i++) {
    gc_mark(*ptr++, lev);
      }
  }
  break;

          /*............ abbreviation............ */

      default:
  rb_bug("rb_gc_mark(): unknown data type 0x%x(0x%x) %s",
         obj->as.basic.flags & T_MASK, obj,
         is_pointer_to_heap(obj) ?
                            "corrupted object" : "non object");
    }
}

(gc.c)
</pre>

<b>Gc_mark_children()</b>  tries to find all the objects that can be reached from the input object.   As we will see in this and following sections,  this is a endeavor that involves detailed processing.   What do we mean?    Consider the following simple array:   "ary = [ 1, 2]"

<img src="images/ch_gc_node_tree.png" alt="(node tree)"><br>
<br>Figure 14: Objects for    "ary = [ 1 ;, 2 ]"

The Gray structures(See Below) indicate the extent of the basic input object,   that is the part of the object that has already been marked.   This is the object that was processed by <b>gc_mark()</b>.   It has been passed to this routine to do what?   To mark all of it's childern!    The array structure itself is not marked,   it is considered part of the input object and it will deleted when it's object is destroyed.   This is true of all auxillary memory used by objects.


The blue structures are the <i>children</i>  of the input object,   They are the <i>reachable</i>   objects.   These are the objects that <b>gc_mark_children()</b> will <i>Mark</i>  if they are not already marked.


As you can see,   these are the constructs that represent the <i>objects and data</i> created by the programmer.   However,   there are another set of objects supported by the Ruby Interpreter.   These are <b>T_NODES</b>.   These are the objects that represent the program code inside Ruby.   Each <i>source line</i>  is converted into a tree of   T_NODES.


T_NODES will be discussed in some detail in Secton II.   For now,  T_NODES are shown just to illustrate the processing in first section of <b>gc_mark_children()</b>.    The following T_NODE Tree is created for the source line "x = 5 + 1":


<img src="images/ch_gc_tnode_tree.png" alt="(tnode tree)"><br>
<br>Figure 15: T_NODES Generated for   "x = 5 + 1"


As before the gray structures illustrate the input object processed by <b>gc_mark()</b> and the Blue structures represent the objects that are "reachable" by <b>gc_mark_children()</b>.



This pairing of <b>gc_mark</b>  and <b>gc_mark_children()</b>  work recursively to trace
the objects.   The trace depth variable <i>lev</i>  and the <i>mark_stack</i> work to
prevent run-away recursion.   These features breaks very deep traces into smaller chucks to
ease processing.   It is important to know that while these features sometimes fail,
the program does not crash.  It simply marks ALL of the ojbects.   While this mary appear
crude, it will allow Ruby to continue to run until the processor memory is exhausted.






In the case of T_DATA Objects,  if a <i>Marking Function</i>  is present, it is executed.   Ruby has no way of knowing what the structure of a T_DATA Object represents,   thus we can not process this object any further.

<pre class="graylist">
 case T_DATA:
   if (obj-> As.Data.Dmark) (*obj-> As.Data.Dmark) (DATA_PTR (obj));
 break;

(gc.c)
</pre>
h3.  Rb_gc ()

The function <b>rb_gc()</b>  simply calls the function <b>garbage_collect()</b>  and on completion calls <b>rb_gc_finalize_deferred()</b>.


</pre>
<pre class="graylist">
void
rb_gc()
{
    garbage_collect();
    rb_gc_finalize_deferred();
}

(gc.c)
</pre>

The function  <b>garbage_collect()</b>  attempts to reclaim the space allocated to <i>non-live</i>  objects before adding another heap.   The reclaimation process is  performed by two main tasks.   The first task is performed by calling <b>gc_mark()</b>   for the <i>root set</i>  of objects.   These are:


# global variables and constants in Ruby.
# live local variables in Ruby
# the machine stack
# objects referenced by C global variables registerd by rb_gc_register_address()


Second,   the function <b>gc_sweep</b>  is then called called to reclaim all objects that were not <i>marked</i>  by the marking functions.    That is,   all objects that were not reachable from the <i>root set</i>  of objects.


The function <b>rb_gc_finalize_deferred()</b>  is called to perform any actions that have be performed before an object is destroyed.   There three instances when this must be done.


#  When an object was placed on the <i>deferred_final_list</i>  by calling the method <i>ObjectSpace.define_finalizer</i>,   This method stores a <i>proc</i>  that <b>rb_gc_finalize_deferred()</b>  will execute before deleting the target object.
#  When a T_DATA Object has a <i>dfree</i>  function specified.
#  When a T_FILE Object is destroyed, any open I/O channels must be closed.


h3. Ruby stack and object lists

The following section of code,  from <b>garbage_collect(),</b>  traces objects found in Ruby stack structures and certain lists of objects.   These include Local Variables,  Nodes in Stack Frames,  Scope Objects, in-block Variables, and any finalizer objects.


<pre class="graylist">
   gc_mark((VALUE)ruby_current_node, 0);

    /* mark frame stack */
    for (frame = ruby_frame; frame; frame = frame->prev) {
  rb_gc_mark_frame(frame);
  if (frame->tmp) {
      struct FRAME *tmp = frame->tmp;
      while (tmp) {
    rb_gc_mark_frame(tmp);
    tmp = tmp->prev;
      }
  }
    }
    gc_mark((VALUE)ruby_scope, 0);
    gc_mark((VALUE)ruby_dyna_vars, 0);
    if (finalizer_table) {
  mark_tbl(finalizer_table, 0);
    }

(gc.c)
</pre>

The variable <i>ruby_current_node</i>  points to the current node on the Abstract Syntax Tree(AST).   As usual, marking this node also marks all nodes reachable from this node.


Each Stack Frame contains a pointer to an AST Node,  which is marked!   Additionally, a Stack Frame may contain a sub-list of Stack Frames, which also have their Nodes marked.


Marking <i>ruby_scope</i>  marks all local variables in the current Scope.


Marking <i>ruby_dyna_vars</i>  marks all in-block Variables in the current Scope.


Finally, if a <i>finalizer_table</i>  is present,   all objects contained in the table are marked.






h3. Registers and the Stack

The <b>GC</b>  also has to worry about objects referenced from machine registers and the stack.   For registers, this presents a problem for the interpreter.   When you attempt to examine register contents,  knowledge of the underlying architecture is required.   This presents some difficulties.   This will be obvious when examining the code.   For the purposes of this document,  will examine only the <i>X86 Processor</i>.

The following code example is for the X86 Processor ( both 32 & 64 bit).   The <b>FLUSH_REGISTER _WINDOWS</b> definition is not used by the X86.   A <b>setjmp()</b>  function is used to store the machine registers in a known location.   Then function <b>mark_locations_array()</b>  then marks any objects referenced from the saved registers.   This function will be discussed shortly.


Now the registers have been marked,  attempt is made to find all apparent object references on the full stack.   These references unlike others are more tentative in nature.   All we know about the references on the stack is that they point an object in an active heap.   When found, these objects are marked.

The only problem we have is that the object may be a "dead" object.   We just don't know for certain!   The reference may never be used.   This is yet another  example of why GC is called a <i>conservative</i> garbage collector.   When we are uncertain about whether an object is alive or dead,   we err on the side of caution and mark it!





<pre class="graylist">

    FLUSH_REGISTER_WINDOWS;     /* "((void)0)" for X86 Architecture */

    setjmp(save_regs_gc_mark);  /* Save registers in local array */

    mark_locations_array((VALUE*)save_regs_gc_mark,
                     sizeof(save_regs_gc_mark) / sizeof(VALUE *));

    #if STACK_GROW_DIRECTION < 0
       rb_gc_mark_locations((VALUE*)STACK_END, rb_gc_stack_start);  ??

    ( code for other architectures )

(gc.c)
</pre>
<pre class="graylist">
#ifdef __GNUC__
#if defined(__human68k__) || defined(DJGPP)
#if defined(__human68k__)
typedef unsigned long rb_jmp_buf[8];
__asm__ (".even\n\
_rb_setjmp:\n\
	move.l	4(sp),a0\n\
	movem.l	d3-d7/a3-a5,(a0)\n\
	moveq.l	#0,d0\n\
	rts");
#ifdef setjmp
#undef setjmp
#endif
#else
#if defined(DJGPP)
typedef unsigned long rb_jmp_buf[6];
__asm__ (".align 4\n\
_rb_setjmp:\n\
	pushl	%ebp\n\
	movl	%esp,%ebp\n\
	movl	8(%ebp),%ebp\n\
	movl	%eax,(%ebp)\n\
	movl	%ebx,4(%ebp)\n\
	movl	%ecx,8(%ebp)\n\
	movl	%edx,12(%ebp)\n\
	movl	%esi,16(%ebp)\n\
	movl	%edi,20(%ebp)\n\
	popl	%ebp\n\
	xorl	%eax,%eax\n\
	ret");
#endif
#endif
int rb_setjmp (rb_jmp_buf);
#define jmp_buf rb_jmp_buf
#define setjmp rb_setjmp
#endif /* __human68k__ or DJGPP */
#endif /* __GNUC__ */

(gc.c)</a>
</pre>



h4.  Mark_locations_array ()

This function purpose is to step through an array a possible <b>VALUE</b>  words and determine
if they point to a object in a valid heap.    Each possible VALUE is presented to the function <b>is_pointer_to_heap().</b>   If the function returns true the object is marked by calling <b>gc_mark().</b>


As discussed in previous sections,  these arrays have been stored registers and the stack.



<pre class="graylist">

mark_locations_array(x, n)
    register VALUE *x;
    register long n;
{
    VALUE v;
    while (n--) {
        v = *x;
        if (is_pointer_to_heap((void *)v)) {
            gc_mark(v, 0);
        }
    x++;
    }
}

(gc.c)
</pre>

h4.  Is_pointer_to_heap ()

This function given a <i>possible</i>  object address,  determines if it is a valid address.   We know that all objects are allocated from one or more heaps in memory.   If the given pointer falls within the address range of a valid heap,  then it is an object.


However, just falling with the proper range does not make is a "live" object.   It simply indicates that it <i>maybe</i>  a valid object.   The object could easily be on the <i>freelist</i>,  for example.   This function only determines that it is valid object address.



<pre class="graylist">
static inline int
is_pointer_to_heap(ptr)
    void *ptr;
{
    register RVALUE *p = RANY(ptr);
    register RVALUE *heap_org;
    register long i;

    if (p < lomem || p > himem) return Qfalse;
    if ((VALUE)p % sizeof(RVALUE) != 0) return Qfalse;

    /* check if p looks like a pointer */
    for (i=0; i < heaps_used; i++) {
        heap_org = heaps[i].slot;
        if (heap_org <= p && p < heap_org + heaps[i].limit)
          return Qtrue;
    }
    return Qfalse;
}

(gc.c)
</pre>

h4. Register window
<pre class="graylist">
 #if defined (sparc) || defined (__sparc__)
 # if defined (linux) || defined (__linux__)
 #define FLUSH_REGISTER_WINDOWS asm ("ta 0x83")
 # else /* Solaris and not sparc linux *
 #define FLUSH_REGISTER_WINDOWS asm ("ta 0x03")
 # endif
 #else /* Not a sparc *
 #define FLUSH_REGISTER_WINDOWS
 #endif

(defines.h)
</pre>


h3. Machine stack
<pre class="graylist">
 rb_gc_mark_locations (rb_gc_stack_start, (VALUE*) STACK_END);
 #if defined (__human68k__)
 rb_gc_mark_locations ((VALUE*) ((char*) rb_gc_stack_start

 (VALUE*) ((char*) STACK_END + 2));
 #endif

(gc.c)
</pre>


h4.  Init_stack ()

This function initializes the stack parameters.   As with some previous sections that involved machine level interactions,  we will discuss specifics for the X86 processor only.


First,  the starting address of the stack must be computed.   First,  if the specified parameter address contains zero,  it will be filled with it's own address.


Now the macro   <b>STACK_UPPER(x, y, z)</b>  is a piece of tricky business.   Since stack direction and usage varies,  this macro adjusts for it.   For X86 processors the third parameter, <i>z</i>,  is always used.   Thus, the first usage of  STACK_UPPER()  executes the instruction <b>++addr</b>.   The second,  executes the conditional <b>rb_gc_stack_start &lt addr</b>.


If the symbol HAVE_GETRLIMIT is defined,  the code following will compute a "reasonable" stack size for the current processor.   This is done by asking the processor for the current Stack Limit and using it to compute the STACK_LEVEL_MAX value.   For the X86 Processor the initial value is set to <i>655300</i>.



<pre class="graylist">
void
Init_stack(addr)
    VALUE *addr;
{
#ifdef __ia64
  ::       ::          ::
#endif

#if defined(_WIN32) || defined(__CYGWIN__)
  ::       ::          ::
#elif defined(STACK_END_ADDRESS)
  ::       ::          ::
#else
    if (!addr) addr = (VALUE *)&addr;   /* X86 Processing */
    STACK_UPPER(&addr, addr, ++addr);
    if (rb_gc_stack_start) {
  if (STACK_UPPER(&addr,
      rb_gc_stack_start > addr,
      rb_gc_stack_start < addr))
      rb_gc_stack_start = addr;
  return;
    }
    rb_gc_stack_start = addr;
#endif

#ifdef HAVE_GETRLIMIT                  /* X86 Processing */
    {
  struct rlimit rlim;

  if (getrlimit(RLIMIT_STACK, &rlim) == 0) {
      unsigned int space = rlim.rlim_cur/5;

      if (space > 1024*1024) space = 1024*1024;
      STACK_LEVEL_MAX = (rlim.rlim_cur - space) / sizeof(VALUE);
  }
    }
#endif
}


(gc.c)
</pre>


h4.  STACK_END

Again,  as we did previously,  we have isolated the defines for the X86 processor.   Other processors take slightly different tacks.   The important issue here is that the two defines that "set" and "return" the <i>Stack End Address</i> are created properly for the current processor.


<pre class="graylist">
#ifdef C_ALLOCA
   ::         ::       ::
#else
# if defined(__GNUC__) &&
         defined(USE_BUILTIN_FRAME_ADDRESS) && !defined(__ia64)
   ::         ::       ::
   ::         ::       ::
# else                       /* Starting X86 Defines */
#  define  SET_STACK_END    VALUE *stack_end = alloca(1)
# endif
# define STACK_END (stack_end)
#endif

(gc.c)
</pre>

The SET_STACK_END operation creates the pointer to the Stack End Address by allocating one word on the current stack.   The returned address is stored in the pointer location, <i>stack_end</i>.

<pre class="graylist">
    VALUE *stack_end = alloca(1)
</pre>

When ever the define STACK_END is used, the value <i>(stack_end)</i>  is inserted.
</P>
These methods of creating and returning the Stack End Address isolates all the processor differences in <i>static defines</i> rather than coding executable methods of processor differentiation.   This is a common technique used throughout the Ruby Interpreter.



h4.  Rb_gc_mark_locations ()

This function searches the stack for pointers into active heaps.   Checks are made to assure that the possible object appears to be an appropriate size and resides at valid heap location.   At this point,  we assume it is a "live" object.   There is some chance that the object is already "dead", but as a conservative collector we accept the occasional uncollected "dead" object.


The actual traversing of the stack and marking objects is performed by <b>mark_locations_array()</b>.   The function <b>rb_gc_mark_locations ()</b>  only coverts the input parameters into a form that is acceptable to <b>mark_locations_array()</b>.


<pre class="graylist">
void
rb_gc_mark_locations(start, end)
    VALUE *start, *end;
{
    long n;

    n = end - start;
    mark_locations_array(start,n);
}
(gc.c)
</pre>

While traversing a stack is generally a processor specific function,   <b>rb_gc_mark_locations()</b> avoids this problem by requiring the caller make adjustments for processor differences.   The following code encompasses the various processor adjustments for calls to <b>rb_gc_mark_locations()</b>.

<pre class="graylist">
 <b><i>garbage_collect():</i></b>  (continued)
    ::       ::       ::
    ::       ::       ::
#if STACK_GROW_DIRECTION < 0      /* X86 Processors */
    rb_gc_mark_locations((VALUE*)STACK_END, rb_gc_stack_start);

#elif STACK_GROW_DIRECTION > 0
    rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)STACK_END + 1);

#else
    if ((VALUE*)STACK_END < rb_gc_stack_start)
       rb_gc_mark_locations((VALUE*)STACK_END, rb_gc_stack_start);
    else
       rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)STACK_END + 1);
#endif

#ifdef __ia64
    /* mark backing store (flushed register window on the stack) */
    /* the basic idea from guile GC code                         */
    rb_gc_mark_locations(rb_gc_register_stack_start,
          (VALUE*)rb_ia64_bsp());
#endif

#if defined(__human68k__) || defined(__mc68000__)
    rb_gc_mark_locations((VALUE*)((char*)STACK_END + 2),
       (VALUE*)((char*)rb_gc_stack_start + 2));
#endif

(gc.c)
</pre>

As an example the first two lines are for calling this <b>rb_gc_mark_locations()</b>  on X86 Processors.

 Notice that the "start" and "end" specifications <i>are not necessarily</i>  the actual start and end addresses. These values are calculated for each processor so the stack is traversed in a positive direction, regardless of the actual stack orientation.





h3. Other route objects

Lastly, there are a number of system tables and miscellaneous objects that are left to be marked.   We will cover them in this section.   As you can see below,  this is the final marking phase before the <i>sweep</i>  begins!


</pre>
<pre class="graylist">
    <b><i>garbage_collect():</i></b>  (continued)
       ::         ::       ::
       ::         ::       ::
    rb_gc_mark_threads();

    /* mark protected global variables */
    for (list = global_List; list; list = list->next) {
       rb_gc_mark_maybe(*list->varptr);
    }
    rb_mark_end_proc();
    rb_gc_mark_global_tbl();

    rb_mark_tbl(rb_class_tbl);
    rb_gc_mark_trap_list();

    /* mark generic instance variables for special constants */
    rb_mark_generic_ivar_tbl();

    rb_gc_mark_parser();

    /* gc_mark objects whose marking are not completed*/
    do {
       while (!MARK_STACK_EMPTY) {
         if (mark_stack_overflow){
           gc_mark_all();
         }
         else {
           gc_mark_rest();
         }
       }
       rb_gc_abort_threads();

    } while (!MARK_STACK_EMPTY);

    gc_sweep(); /* Performs the Sweep Phase of the Garbage Collector */
 }

(gc.c)
</pre>


<b>rb_gc_mark_threads()</b><br>
If threads are being used,  this function will mark all active threads.



<b>Global List and rb_gc_mark_maybe()</b><br>
The global list contains pointers to both simple global address and objects.   The <i>global_list</i>  is scanned and each address is passed to <b>rb_gc_mark_maybe()</b>.   This function determines if the pointer resides in an active heap,  which means the address points at an object.   All objects found on the global_list are marked.



<b>rb_gc_mark_end_proc()</b><br>
The handling of proc's by <b>eval.c</b>  evolves keeping various lists of proc objects.  This function marks all the objects recorded in these lists.



<b>rb_gc_mark_global_tbl()</b><br>
Ruby maintains an internal hash table of all define global variables.   This function marks each of these variables.



<b>rb_gc_mark_trap_list()</b><br>
Ruby keeps a list of signal traps for handling threads.   This function marks the objects associated with these thread signals.



<b>rb_gc_mark_generic_ivar_tbl()</b><br>
When instance variables are created for special constants,  they are stored in the <i>generic_ivar_tbl</i>.   This is necessary because special constants exist only in the VALUE word and do not instantiate an actual object.   All variable objects in this table are marked!



<b>rb_gc_mark_parser()</b><br>
This function marks the objects that hold the state of the parser.



<b>Marking Objects with incomplete marking</b><br>
The last marking sequence to complete is the marking of objects on the <i>mark_stack</i>.   As stated previously,  if the mark_stack has <i>overflowed</i>  all objects will be marked.   Otherwise, just the objects on the mark_stack are fed to <b>gc_mark_children()</b>.



<b>rb_gc_abort_threads()</b><br>
At the completion of all marking,  this function will terminate all unmarked  threads.




h2. Sweep

h3. Special treatment of NODE Objects

For the <i>sweep phase</i>  we will search for objects that are not marked and release them!   However,  there is a small problem with objects of type NODE if the parser's semantic stack is not allocated on the machine stack.   For configurations were the machine stack is not used,  the following code is provided to mark those objects.   Notice that even for these configurations,  this is only a problem if the parser in compiling!

<pre class="graylist">
static void
gc_sweep()
{
 RVALUE *p, *pend, *final_list;
 int freed = 0;
 int i;
 unsigned long live = 0;
 unsigned long free_min = 0;
   ::       ::       ::    ::
   ::       ::       ::    ::
/* We should not reclaim nodes during compilation             */
/* if yacc's semantic stack is not allocated on machine stack */

 if (ruby_in_compile && ruby_parser_stack_on_heap()) {
   for (i = 0; i < heaps_used; i++) {
     p = heaps[i].slot; pend = p + heaps[i].limit;
     while (p < pend) {
       if (!(p->as.basic.flags&FL_MARK) && BUILTIN_TYPE(p) == T_NODE)
         gc_mark((VALUE)p, 0);
        p++;
        }
     }
   }
   ::       ::       ::    ::
   ::       ::       ::    ::

(gc.c)
</pre>


h3. Reclaiming "dead" Objects

The following section of <b>gc_sweep()</b>  examines the active heaps for objects that are not <i>marked</i>!   Unmarked,  or "dead",  objects are first processed by <b>obj_free()</b>.   This function releases any auxiliary memory that has been allocated for an object.   These are things like the memory that holds the string for a string object.   Other objects, such a <i>float</i>,  are self-contained objects and are not modified.


This does not actually "free" an object,  it simply reduces it to a bare, and probably an incomplete,  object.   It becomes free only when it is placed on the <i>freelist</i>.   However, before it can legitimately be placed on that list,  it must be checked for a <i>finalizer</i>.


The rest of the section is concerned with insuring that unnecessary heaps are reclaimed and that there are sufficient "free' objects available.   Care is taken not to reclaim an empty heap if the number of "free" objects is less than the computed value <i>free_min</i>.   This value never less than the constant FREE_MIN (currently 4096).   If however,  after all reclamation has been complete the number of "free" objects is less than <i>free_min</i>,  the function <b>add_heap()</b>  performed to increase their number.

<pre class="graylist">
  <b><i>gc_sweep():</i></b>  (continued)
   ::       ::       ::    ::
   ::       ::       ::    ::
  freelist = 0;
  final_list = deferred_final_list;
  deferred_final_list = 0;

  for (i = 0; i < heaps_used; i++) {
    int n = 0;
    RVALUE *free = freelist;
    RVALUE *final = final_list;

    p = heaps[i].slot; pend = p + heaps[i].limit;
    while (p < pend) {
      if (!(p->as.basic.flags & FL_MARK)) {
        if (p->as.basic.flags) {
            obj_free((VALUE)p);
        }
        if (need_call_final && FL_TEST(p, FL_FINALIZE)) {
          p->as.free.flags = FL_MARK; /* remain marked */
          p->as.free.next = final_list;
          final_list = p;
        }
        else {
          p->as.free.flags = 0;
          p->as.free.next = freelist;
          freelist = p;
        }
        n++;
      }
      else if (RBASIC(p)->flags == FL_MARK) {
        /* objects to be finalized */
        /* do nothing remain marked */
      }
      else {
        RBASIC(p)->flags &= ~FL_MARK;
        live++;
      }
      p++;
    }
    if (n == heaps[i].limit && freed > free_min) {
      RVALUE *pp;

      heaps[i].limit = 0;
      for (pp = final_list; pp != final; pp = pp->as.free.next) {
          pp->as.free.flags |= FL_SINGLETON; /* freeing page mark */
      }
      freelist = free;  /* cancel this page from freelist */
    }
    else {
      freed += n;
    }
  }
  if (malloc_increase > malloc_limit) {
      malloc_limit += (malloc_increase - malloc_limit) * (double)live / (live + freed);
      if (malloc_limit < GC_MALLOC_LIMIT) malloc_limit = GC_MALLOC_LIMIT;
  }
  malloc_increase = 0;
  if (freed < free_min) {
      add_heap();
  }
   ::       ::       ::    ::
   ::       ::       ::    ::

(gc.c)
</pre>

h3. Finalizers

      Ruby supplies two methods for managing finalization processing for objects.   They are:<br>
   1)  ObjectSpace.define_finalizer<br>
   2)  ObjectSpace.undefine_finalizer<br><br>
Defined finalizers are maintained in the hash table <i>finalizer_table</i>.   This table is indexed by the Object's VALUE and contains a reference to a <i>proc block</i>.


Unfortunately,  two more <u>depreciated</u> methods must also be handled.   They are:<br>
   1)  ObjectSpace.add_finalizer<br>
   2)  ObjectSpace.remove_finalizer<br><br>
These finalizers are held in the table <i>finalizers</i>.   This table is indexed by the Object's ID and contains a reference to a <i>proc block</i>.   As noted these are depreciated methods and are meant to be eventually removed.

 Let us look closer at the section above responsible for finalizer processing(shown below).   When the first  <b>define_finalizer()</b>  method is executed,  the variable <i>need_call_final</i>  is set to one(1).   This enables the checking for finalizers.   Surprisingly,  the flag is never cleared once set.   Even if all finalizers are undefined.

<pre class="graylist">
   ::       ::       ::    ::
   if (need_call_final && FL_TEST(p, FL_FINALIZE)) {
     p->as.free.flags = FL_MARK; /* remain marked */
     p->as.free.next = final_list;
     final_list = p;
   }
   else {
     p->as.free.flags = 0;
     p->as.free.next = freelist;
     freelist = p;
   }
   ::       ::       ::    ::
</pre>

Remember at this point in the processing the current object is <i>unmarked!</i>.   If the FL_FINALIZE Flag is set for the current object,  the object is placed on the <i>final_list</i> and <i>marked</i>.   For those that are wondering why the object is being marked again,  it must now persist in it's new state until the <i>proc</i>  associated with the finalizer is actually  executed.


If FL_FINALIZE is not set, the object is placed on the <i>free_list</i>.


Finalizers are only executed at the completion of garbage collection and at program exit.

h3. Run_final

The function <b>run_final()</b>,  as shown below,  handles executing the <i>finalizer proc's</i>.


<pre class="graylist">
static void
run_final(obj)
    VALUE obj;
{
    long i;
    int status, critical_save = rb_thread_critical;
    VALUE args[3], table, objid;

    objid = rb_obj_id(obj); /* make obj into id */
       ::       ::       ::    ::
       ::       ::       ::    ::
     /* Code for Depreciated 'add_final' method */
       ::       ::       ::    ::
       ::       ::       ::    ::
    if (finalizer_table && st_delete(finalizer_table,
                  (st_data_t*)&obj, &table)) {
      for (i=0; i<RARRAY(table)->len; i++) {
        VALUE final = RARRAY(table)->ptr[i];
        args[0] = RARRAY(final)->ptr[1];
        if (!args[1]) args[1] = rb_ary_new3(1, objid);
        args[2] = FIX2INT(RARRAY(final)->ptr[0]);
        rb_protect((VALUE(*)_((VALUE)))run_single_final,
                   (VALUE)args, &status);
      }
    }
    rb_thread_critical = critical_save;
}

(gc.c)
</pre>

This function processes the <i>finalizer_table</i>  created by the <b>define_finalizer()</b>  method.   The finalizer parameters are referenced through the hash table <i>finalizer_table</i>.   The <i>hash key</i>  is the target Object's VALUE Pointer and <i>hash value</i>  is a VALUE pointer to the <i>Block Array</i>.


The Block Array contains one VALUE Pointer to a <i>Command Array</i>  for each <b>define_finalizer()</b>  method call applied to a specific object.   If <b>define_finalizer()</b>  was called twice for the same object,  the Block Array will contain two entries.


Each VALUE pointer in the Block Array references an array containing three entries,  cmd,  args,  and safe_level.   The <i>proc</i>  object is executed by feeding these three entries to the <u>rb_eval_cmd()</u>  function.



<img src="images/ch_gc_finalizer_structure.png" alt="(finalizer structure)"><br>
<br>Figure 16: Finalizer Structure






h3.  Rb_gc_force_recycle ()

There comes a time when you wish to kill an object with extreme prejudice!   Not at some undetermined time later,  <i>now!</i>.   While this facility is not available the user,  it is available to internal routines where the consequences are determinate.   In any case,  <b>rb_gc_force_recycle()</b>  will clear the objects flags(i.e. effectively deleting the object) and places the object on the <i>freelist!</i>.


A word of warning though,  <b>rb_gc_force_recycle()</b>  does not release any memory allocated by the object.   Failure to take this into account will lead to <i>memory leaks!</i>


<pre class="graylist">
void
rb_gc_force_recycle(p)
    VALUE p;
{
    RANY(p)->as.free.flags = 0;
    RANY(p)->as.free.next = freelist;
    freelist = RANY(p);
}

(gc.c)
</pre>

h2. Timing of starting

h3.  Inside gc.c

Where does Garbage Collection start?   There are three primary places:

<pre class="greenlist">
1.  Ruby_xmalloc()
2.  Ruby_xrealloc()
3.  Rb_newobj()
</pre>

These are the functions that allocate space for objects,  both the object itself and any axillary space needed.   Axillary space consists of things like space for strings and other data structures.


The functions <b>Ruby_xmalloc()</b> and <b>Ruby_xrealloc()</b> are used by a variety of internal functions to process requests for additional memory.   When a memory allocation request fails,  these functions call <b>garbage_collect()</b>  to free up memory.   A second failure will cause Ruby to generate a memory allocation error and exit.


The function <b>rb_newobj()</b>  is used to create new objects.   When there are no objects on the <i>freelist</i>,  the function <b>garbage_collect()</b> is run to free up the space allocated to "dead" objects.   When this does not create enough free objects,  a new heap is created.   As above,  failure to allocate memory will cause Ruby to print an error and exit.



h3. Inside interpreter

Inside the interpreter there are numerous places where memory must be allocated,  such as opening files.   In these and other cases when memory is required,  the function <b>rb_gc()</b>  is called and this function calls <b>garbage_collect()</b>.


The Ruby statements <i>GC.start</i>,  <i>gc.garbage_collect</i>,  and <i>ObjectSpace.garbage_collect</i>  all call <b>rb_gc()</b>  directly.


h2. Formation of object

The story of Garbage Collection has ended.   We have discussed the reclamation of dead objects.   We now need to further discuss the formation of objects.   While this was done to some degree during the previous chapter for Classes,  we will continue the discussion in the following sections.


h3. Allocation framework

We have covered the formation of several types of objects.   Here we tackle the creation of a class instance with the 'new' method.

<pre class="graylist">
    ::     ::   ::
  class C
  end

  C.new()
    ::     ::   ::

(<somefile&gt.c)
</pre>

We can guess that  <b>C.new()</b>  will create an object.


But how is this accomplished?   With most languages,  this sort of operation would be handled internally by the interpreter.   In Ruby,  this and many other operations are handled by <i>predefined methods</i>.   As part of the initialization of the Ruby interpreter,  all the built-in objects and their methods are created before interpretation begins.   The following is a portion for the initialization code for Objects.
<pre class="graylist">
void

Init_Object()
{
    ::          ::          ::
    rb_define_alloc_func(rb_cObject, rb_class_allocate_instance);
    ::          ::          ::
    rb_define_method(rb_cClass, "new", rb_class_new_instance, -1);
    ::          ::          ::
}

(object.c)
</pre>

 Let's set aside the first statement for minute and consider the second statement.   This statement calls a function that adds the <i>method</i>  <b>new()</b>  to the class <i>Class</i>.   This means when a <b>new()</b>  method is specified for a class,  the function <b>rb_class_new_instance()</b>  is executed.


<pre class="graylist">
VALUE
rb_class_new_instance(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE obj;

    obj = rb_obj_alloc(klass);
    rb_obj_call_init(obj, argc, argv);

    return obj;
}

(object.c)
</pre>

How does the interpreter "know" which allocation function to use when creating an object?   Since different objects can be allocated differently,  then each type of object should have a way to define the allocation function.   That method is called appropriately <b>rb_define_alloc_func()</b>.   Notice that this is the first statement highlighted in <b>Init_Object().</b>





For class allocation,  the allocation function <b>rb_class_allocate_instance()</b>  is called by <b>rb_obj_alloc()</b>


<Pre class="graylist">
static VALUE
rb_class_allocate_instance(klass)
    VALUE klass;
{
    NEWOBJ(obj, struct RObject);
    OBJSETUP(obj, klass, T_OBJECT);
    return (VALUE)obj;
}

(object.c)
</pre>


This allocation function, and many others, makes use of the macro's NEWOBJ and OBJSETUP to create an appropriate object structure and install the specified values.

<pre class="graylist">
 #define NEWOBJ (obj and type) type *obj = (type*) rb_newobj ()

 #define OBJSETUP (obj, c, t) do {\
   RBASIC (obj) -> Flags = (t); \
   RBASIC (obj) -> Klass = (c); \
   if (rb_safe_level () > = 3) FL_SET (obj and FL_TAINT);\
  While (0)

(ruby.h)
</pre>

The NEWOBJ  macro calls <b>rb_newobj()</b>,  which fetches the next  RVALUE  slot off the
<i>freelist</i>.   Additionally, it sets the entire RVALUE block to zero.


The OBJSETUP  macro sets the <i>Klass</i>  and <i>Flags</i>  words in the object.   It also sets the FL_TAINT flag if necessary.


Returning to the discussion of <b>rb_class_new_instance()</b>  above.   When control returns from <b>rb_obj_alloc()</b>,  the new object is initialized by calling <b>rb_obj_call_init()</b>.   For a new class object this entails no further action and the function <b>rb_obj_dummy()</b>  is called.





Creating a class object using the <b>new()</b>  command involves only the following generic steps:

<pre class="graylist">
SomeClass.New = Class#new (rb_class_new_instance)
    SomeClass.Allocate = Class#allocate (rb_class_allocate_instance)
    SomeClass#initialize = Object#initialize (rb_obj_dummy)
</pre>


h3. Formation of user definition objects

This section is concerned with the formation of <i>user defined</i>  objects with the extended library.   The extended library API contains three functions for handling these type of objects.

<pre class="greenlist">
1. Data_Wrap_Struct - Wraps a value/structure in a Ruby RData Object
2. Data_Make_Struct - Allocates Memory for a 'c-type' and wraps it
3. Data_Get_Struct  - Returns Pointer to the wrapped structure
</pre

<img src="images/ch_rdata_object.png" alt="(RData Structure)"><br>
<br>Figure 17: RData Structure


The <b>RDATA</b>  structure is the ruby object structure used to 'wrap' <i>user defined</i>  objects.   Other than the standard <b>basic</b>  structure, the three other items are used as follows:


<b>*dmark</b>  points to a function for <i>marking</i>  Ruby Object references.   This is only necessary if your structure contains references to Ruby objects.   If so,  you must supply a function (pointed to by <b>*dmark</b>)  that will call <b>rb_gc_mark()</b>  for each reference to a Ruby Object.   If no function is needed,   then <b>*dmark</b>  may be set to zero.<br><br>
<b>*free</b>  points to a user function to free the user defined objects,  the system function <i>free()</i>,   or a '-1'  to just to free the memory pointed to by <b>*data_ptr</b>.   Note that both specifying <i>free()</i>  and '-1' accomplish the same thing,  the choice is up to the user.<BR><BR>
<b>*data_ptr</b>  points at the user defined structure 'wrapped' by the <b>RDATA</b>  Object.


h4.  Data_Wrap_Struct()   and   Data_Make_Struct()
<BR>
The <b>Data_Wrap_Struct()</b>  function is called as follows:
<pre class="graylist">
<font size=-1>Wrap_Data_Struct( VALUE class, void (*dmark)(), void (*free)(), *ptr )</font>
</pre>

The purpose of <b>Data_Wrap_Struct()</b> is to encapsolate a user defined value or structure in a Ruby <i>RData</i>  Object. Let us look at a simple example:

<pre class="graylist">
typedef struct adot {
  int horz;
  int vert;
} ADot;

ADot *ptr;
VALUE info

ptr = ALLOC(ADot);
ptr->horz = 0;
ptr->vert = 0;

info = Data_Wrap_Struct( cDots,  0,  free,  ptr);
</pre>

Though not shown here, this code refers on a user defined class named <i>cDots</i>.   This class is not particularly important beyond the need for a specific class to be specified.


Since the encapsulated structure does not refer to any other Ruby Objects,  a <b>*dmark</b>  function pointer does not need to be specified.   Further,  because the structure does not have references to other user defined allocations,  the method <b>free</b>  is all that is required for freeing the <i>ADot</i>  structure.   The value '-1'  could have been used instead of specifying <b>free</b>  and produced the same result.


As you can guess,  the <i>ptr</i>  value points a the starting address of a <i>ADot</i>  structure.


In conclusion,  it returns a VALUE pointer to a <i>RData</i>  object.


The <b>Data_Make_Struct()</b>  function is called as follows:
<pre class="graylist">
<font size=-1>Data_Make_Struct( VALUE class, c-type, void (*dmark)(), void (*free)(), (c-type) *ptr )</font>
</pre>

The primary difference between these functions is that <b>Data_Make_Struct()</b>  performs the allocation of the 'c' data structure for you.   Presented here is another version of the previous example.   It uses <b>Data_Make_Struct()</b>  instead of <b>Data_Wrap Struct().</b>

<pre class="graylist">
typedef struct adot {
  int horz;
  int vert;
} ADot;

ADot *ptr;
VALUE info

info = Data_Wrap_Struct( cDots,  ADot,   0,  free,  ptr);

ptr->horz = 0;
ptr->vert = 0;
</pre>

While the use of <i>ptr</i>  in this case to initialize the structure is valid,  you should generally use the method <b>Data_Get_Struct()</b>  to fetch the address of the encapsulated structure.


The definitions for <b>Data_Wrap_Struct</b> and  <b>Data_Make_Struct</b>are defined as macros.

<pre class="graylist"><font size=-1>
/*
#define RUBY_DATA_FUNC(func) ((void (*)_((void*)))func)
*/
typedef void (*RUBY_DATA_FUNC) _((void*));

VALUE rb_data_object_alloc _((VALUE,void*,RUBY_DATA_FUNC,RUBY_DATA_FUNC));

#define Data_Wrap_Struct(klass,mark,free,sval)\
    rb_data_object_alloc(klass,sval,(RUBY_DATA_FUNC)mark,(RUBY_DATA_FUNC)free)

#define Data_Make_Struct(klass,type,mark,free,sval) (\
    sval = ALLOC(type),\
    memset(sval, 0, sizeof(type)),\
    Data_Wrap_Struct(klass,mark,free,sval)\
)

(ruby.h)
</font></pre>

The function <b>Data_Make_Struct</b>  uses <b>Data_Wrap_Struct</b>  to actually create the desired <i>RData</i> Object.   So in both cases that actual creation of the object is accomplished with the function <b>rb_data_object_alloc()</b>




<pre class="graylist">
VALUE rb_data_object_alloc(klass, datap, dmark, dfree)
    VALUE klass;
    void *datap;
    RUBY_DATA_FUNC dmark;
    RUBY_DATA_FUNC dfree;
{
    NEWOBJ(data, struct RData);
    if (klass) Check_Type(klass, T_CLASS);
    OBJSETUP(data, klass, T_DATA);
    data->data = datap;
    data->dfree = dfree;
    data->dmark = dmark;

    return (VALUE)data;
}

(gc.c)
</pre>



h4.  Data_Get_Struct ()

The <b>Data_Get_Struct()</b>  function is called as follows:
<pre class="graylist">
<font size=-1>Data_Get_Struct( VALUE object, c-type, (c-type) *ptr )</font>
</pre>

This function returns a c-type pointer to the value or structure embedded in a <i>RData</i>  Object.   The definition for <b>Data_Get_Struct</b>  is a macro and it's definition is as follows:

<pre class="graylist">
#define Data_Get_Struct(obj,type,sval) do {\
    Check_Type(obj, T_DATA); \
    sval = (type*)DATA_PTR(obj);\
} while (0)

(ruby.h)
</pre>

The following is an example of how to retrieve data from a <i>RData</i>  object.   In this case we examine the data stored in the examples above:

<pre class="graylist">
typedef struct adot {
  int horz;
  int vert;
} ADot;

ADot *sval;
VALUE info;

int HORZ;
int VERT;

Data_Get_Struct( info, ADot, sval);

HORZ = sval->horz;
VERT = sval->vert;
</pre>
<hr>

The original work is Copyright &copy; 2002 - 2004 Minero AOKI.<br>
Translations,  additions,  and graphics by C.E. Thornton<br>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/"><img alt="Creative Commons License" border="0" src="images/somerights20.jpg"/></a><br/>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/">Creative Commons Attribution-NonCommercial-ShareAlike2.5 License</a>.

