<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>  Chapter 15: Methods |  Ruby Hacking Guide </title>
  <link rel="stylesheet" href="/css/styles.css" />
</head>
<body>

  <div id="main">

    <header>
      <h1><a href="/">Ruby Hacking Guide</a></h1>
    </header>

    <nav role="navigation">
      <ul>
      </ul>
    </nav>

    <h1>Chapter 15: Methods</h1>
<p>In this chapter, I&#8217;ll talk about method searching and invoking.</p>
<h2>Searching methods</h2>
<h3>Terminology</h3>
<p>In this chapter, both method calls and method definitions are discussed,
and there will appear really various &#8220;arguments&#8221;. Therefore, to make it not
confusing, let&#8217;s strictly define terms here:</p>
<pre class="emlist">
m(a)          # a is a "normal argument"
m(*list)      # list is an "array argument"
m(&amp;block)     # block is a "block argument"

def m(a)      # a is a "normal parameter"
def m(a=nil)  # a is an "option parameter", nil is "it default value".
def m(*rest)  # rest is a "rest parameter"
def m(&amp;block) # block is a "block parameter"
</pre>
<p>In short, they are all &#8220;arguments&#8221; when passing and &#8220;parameters&#8221; when receiving,
and each adjective is attached according to its type.</p>
<p>However, among the above things, the &#8220;block arguments&#8221; and the &#8220;block
parameters&#8221; will be discussed in the next chapter.</p>
<h3>Investigation</h3>
<p class="caption">▼The Source Program</p>

<pre class="longlist">
obj.method(7,8)
</pre>
<p class="caption">▼Its Syntax Tree</p>

<pre class="longlist">
NODE_CALL
nd_mid = 9049 (method)
nd_recv:
    NODE_VCALL
    nd_mid = 9617 (obj)
nd_args:
    NODE_ARRAY [
    0:
        NODE_LIT
        nd_lit = 7:Fixnum
    1:
        NODE_LIT
        nd_lit = 8:Fixnum
    ]
</pre>
<p>The node for a method call is `NODE_CALL`.
The `nd_args` holds the arguments as a list of `NODE_ARRAY`.</p>
<p>Additionally, as the nodes for method calls, there are also `NODE_FCALL` and `NODE_VCALL`.
`NODE_FCALL` is for the &#8220;`method(args)`&#8221; form,
`NODE_VCALL` corresponds to method calls in the &#8220;`method`&#8221; form that is the same
form as the local variables.
`<span class="caps">FCALL</span>` and `<span class="caps">VCALL</span>` could actually be integrated into one,
but because there&#8217;s no need to prepare arguments when it is `<span class="caps">VCALL</span>`,
they are separated from each other only in order to save both times and memories for it.</p>
<p>Now, let&#8217;s look at the handler of `NODE_CALL` in `rb_eval()`.</p>
<p class="caption">▼ `rb_eval()` − `NODE_CALL` </p>

<pre class="longlist">
2745  case NODE_CALL:
2746    {
2747        VALUE recv;
2748        int argc; VALUE *argv; /* used in SETUP_ARGS */
2749        TMP_PROTECT;
2750
2751        BEGIN_CALLARGS;
2752        recv = rb_eval(self, node-&gt;nd_recv);
2753        SETUP_ARGS(node-&gt;nd_args);
2754        END_CALLARGS;
2755
2756        SET_CURRENT_SOURCE();
2757        result = rb_call(CLASS_OF(recv),recv,node-&gt;nd_mid,argc,argv,0);
2758    }
2759    break;

(eval.c)
</pre>
<p>The problems are probably the three macros, `BEGIN_CALLARGS SETUP_ARGS() END_CALLARGS`.
It seems that `rb_eval()` is to evaluate the receiver and
`rb_call()` is to invoke the method, we can roughly imagine that the evaluation
of the arguments might be done in the three macros, but what is actually done?
`BEGIN_CALLARGS` and `END_CALLARGS` are difficult to understand before talking
about the iterators, so they are explained in the next chapter &#8220;Block&#8221;.
Here, let&#8217;s investigate only about `SETUP_ARGS()`.</p>
<h3>`SETUP_ARGS()`</h3>
<p>`SETUP_ARGS()` is the macro to evaluate the arguments of a method.
Inside of this macro, as the comment in the original program says,
the variables named `argc` and `argv` are used,
so they must be defined in advance.
And because it uses `TMP_ALLOC()`, it must use `TMP_PROTECT` in advance.
Therefore, something like the following is a boilerplate:</p>
<pre class="emlist">
int argc; VALUE *argv;   /* used in SETUP_ARGS */
TMP_PROTECT;

SETUP_ARGS(args_node);
</pre>
<p>`args_node` is (the node represents) the arguments of the method,
turn it into an array of the values obtained by evaluating it,
and store it in `argv`.
Let&#8217;s look at it:</p>
<p class="caption">▼ `SETUP_ARGS()` </p>

<pre class="longlist">
1780  #define SETUP_ARGS(anode) do {\
1781      NODE *n = anode;\
1782      if (!n) {\                             no arguments
1783          argc = 0;\
1784          argv = 0;\
1785      }\
1786      else if (nd_type(n) == NODE_ARRAY) {\  only normal arguments
1787          argc=n-&gt;nd_alen;\
1788          if (argc &gt; 0) {\   arguments present
1789              int i;\
1790              n = anode;\
1791              argv = TMP_ALLOC(argc);\
1792              for (i=0;i&lt;argc;i++) {\
1793                  argv[i] = rb_eval(self,n-&gt;nd_head);\
1794                  n=n-&gt;nd_next;\
1795              }\
1796          }\
1797          else {\            no arguments
1798              argc = 0;\
1799              argv = 0;\
1800          }\
1801      }\
1802      else {\                                 both or one of an array argument
1803          VALUE args = rb_eval(self,n);\      and a block argument
1804          if (TYPE(args) != T_ARRAY)\
1805              args = rb_ary_to_ary(args);\
1806          argc = RARRAY(args)-&gt;len;\
1807          argv = ALLOCA_N(VALUE, argc);\
1808          MEMCPY(argv, RARRAY(args)-&gt;ptr, VALUE, argc);\
1809      }\
1810  } while (0)

(eval.c)
</pre>
<p>This is a bit long, but since it clearly branches in three ways, not so terrible
actually. The meaning of each branch is written as comments.</p>
<p>We don&#8217;t have to care about the case with no arguments, the two rest branches
are doing similar things. Roughly speaking, what they are doing consists of
three steps:</p>
<ul>
	<li>allocate a space to store the arguments</li>
	<li>evaluate the expressions of the arguments</li>
	<li>copy the value into the variable space</li>
</ul>
<p>If I write in the code (and tidy up a little), it becomes as follows.</p>
<pre class="emlist">
/***** else if clause、argc!=0 *****/
int i;
n = anode;
argv = TMP_ALLOC(argc);                         /* 1 */
for (i = 0; i &lt; argc; i++) {
    argv[i] = rb_eval(self, n-&gt;nd_head);        /* 2,3 */
    n = n-&gt;nd_next;
}

/***** else clause *****/
VALUE args = rb_eval(self, n);                  /* 2 */
if (TYPE(args) != T_ARRAY)
    args = rb_ary_to_ary(args);
argc = RARRAY(args)-&gt;len;
argv = ALLOCA_N(VALUE, argc);                   /* 1 */
MEMCPY(argv, RARRAY(args)-&gt;ptr, VALUE, argc);   /* 3 */
</pre>
<p>`TMP_ALLOC()` is used in the `else if` side,
but `ALLOCA_N()`, which is ordinary `alloca()`, is used in the `else` side.
Why?
Isn&#8217;t it dangerous in the `C_ALLOCA` environment because `alloca()` is
equivalent to `malloc()` ?</p>
<p>The point is that &#8220;in the `else` side the values of arguments are also stored in
`args`&#8221;. If I illustrate, it would look like Figure 1.</p>
<p><img src="images/ch_method_anchor.jpg" title="Being in the heap is all right." alt="Being in the heap is all right." /></p>
<p>If at least one `<span class="caps">VALUE</span>` is on the stack, others can be successively marked through
it. This kind of `<span class="caps">VALUE</span>` plays a role to tie up the other `<span class="caps">VALUE</span>`s to the stack
like an anchor. Namely, it becomes &#8220;`anchor <span class="caps">VALUE</span>`&#8221;.
In the `else` side, `args` is the anchor `<span class="caps">VALUE</span>`.</p>
<p>For your information, &#8220;anchor `<span class="caps">VALUE</span>`&#8221; is the word just coined now.</p>
<h3>`rb_call()`</h3>
<p>`SETUP_ARGS()` is relatively off the track. Let&#8217;s go back to the main line. The
function to invoke a method, it is `rb_call()`. In the original there&#8217;re codes
like raising exceptions when it could not find anything, as usual I&#8217;ll skip all
of them.</p>
<p class="caption">▼ `rb_call()` (simplified)</p>

<pre class="longlist">
static VALUE
rb_call(klass, recv, mid, argc, argv, scope)
    VALUE klass, recv;
    ID    mid;
    int argc;
    const VALUE *argv;
    int scope;
{
    NODE  *body;
    int    noex;
    ID     id = mid;
    struct cache_entry *ent;

    /* search over method cache */
    ent = cache + EXPR1(klass, mid);
    if (ent-&gt;mid == mid &amp;&amp; ent-&gt;klass == klass) {
        /* cache hit */
        klass = ent-&gt;origin;
        id    = ent-&gt;mid0;
        noex  = ent-&gt;noex;
        body  = ent-&gt;method;
    }
    else {
        /* cache miss, searching step-by-step  */
        body = rb_get_method_body(&amp;klass, &amp;id, &amp;noex);
    }

    /* ... check the visibility ... */

    return rb_call0(klass, recv, mid, id,
                    argc, argv, body, noex &amp; NOEX_UNDEF);
}
</pre>
<p>The basic way of searching methods was discussed in chapter 2: &#8220;Object&#8221;.
It is following its superclasses and searching `m_tbl`. This is done by
`search_method()`.</p>
<p>The principle is certainly this, but when it comes to the phase to execute
actually, if it searches by looking up its hash many times for each method call,
its speed would be too slow.
To improve this, in `ruby`, once a method is called, it will be cached.
If a method is called once, it&#8217;s often immediately called again.
This is known as an experiential fact and  this cache records the high hit rate.</p>
<p>What is looking up the cache is the first half of `rb_call()`. Only with</p>
<pre class="emlist">
ent = cache + EXPR1(klass, mid);
</pre>
<p>this line, the cache is searched.
We&#8217;ll examine its mechanism in detail later.</p>
<p>When any cache was not hit, the next `rb_get_method_body()` searches the class
tree step-by-step and caches the result at the same time.
Figure 2 shows the entire flow of searching.</p>
<p><img src="images/ch_method_msearch.jpg" title="Method Search" alt="Method Search" /></p>
<h3>Method Cache</h3>
<p>Next, let&#8217;s examine the structure of the method cache in detail.</p>
<p class="caption">▼Method Cache</p>

<pre class="longlist">
 180  #define CACHE_SIZE 0x800
 181  #define CACHE_MASK 0x7ff
 182  #define EXPR1(c,m) ((((c)&gt;&gt;3)^(m))&amp;CACHE_MASK)
 183
 184  struct cache_entry {            /* method hash table. */
 185      ID mid;                     /* method's id */
 186      ID mid0;                    /* method's original id */
 187      VALUE klass;                /* receiver's class */
 188      VALUE origin;               /* where method defined  */
 189      NODE *method;
 190      int noex;
 191  };
 192
 193  static struct cache_entry cache[CACHE_SIZE];

(eval.c)
</pre>
<p>If I describe the mechanism shortly, it is a hash table. I mentioned that the
principle of the hash table is to convert a table search to an indexing of an
array. Three things are necessary to accomplish: an array to store the data,
a key, and a hash function.</p>
<p>First, the array here is an array of `struct cache_entry`. And the method is
uniquely determined by only the class and the method name, so these two become
the key of the hash calculation. The rest is done by creating a hash function
to generate the index (`0&#215;000` ~ `0&#215;7ff`) of the cache array form the key.
It is `<acronym title=")`. Among its arguments, `c` is the class object and `m` is the
method name (`ID`"><span class="caps">EXPR1</span></acronym>. (Figure 3)</p>
<p><img src="images/ch_method_mhash.jpg" title="Method Cache" alt="Method Cache" /></p>
<p>However, `EXPR1()` is not a perfect hash function or anything, so a different
method can generate the same index coincidentally. But because this is nothing
more than a cache, conflicts do not cause a problem.
It just slows its performance down a little.</p>
<h4>The effect of Method Cache</h4>
<p>By the way, how much effective is the method cache in actuality?
We could not be convinced just by being said &#8220;it is known as &#8230;&#8221;.
Let&#8217;s measure by ourselves.</p>
<table>
	<tr>
		<th>Type </th>
		<th>Program </th>
		<th>Hit Rate </th>
	</tr>
	<tr>
		<td> generating <acronym title="1"><span class="caps">LALR</span></acronym> parser </td>
		<td> racc ruby.y </td>
		<td> 99.9% </td>
	</tr>
	<tr>
		<td> generating a mail thread </td>
		<td> a mailer </td>
		<td> 99.1% </td>
	</tr>
	<tr>
		<td> generating a document </td>
		<td> rd2html rubyrefm.rd </td>
		<td> 97.8% </td>
	</tr>
</table>
<p>Surprisingly, in all of the three experiments the hit rate is more than 95%.
This is awesome. Apparently, the effect of &#8220;it is know as &#8230;&#8221; is outstanding.</p>
<h2>Invocation</h2>
<h3>`rb_call0()`</h3>
<p>There have been many things and finally we arrived at the method invoking.
However, this `rb_call0()` is huge. As it&#8217;s more than 200 lines, it would come
to 5,6 pages. If the whole part is laid out here, it would be disastrous. Let&#8217;s
look at it by dividing into small portions. Starting with the outline:</p>
<p class="caption">▼ `rb_call0()` (Outline)</p>

<pre class="longlist">
4482  static VALUE
4483  rb_call0(klass, recv, id, oid, argc, argv, body, nosuper)
4484      VALUE klass, recv;
4485      ID    id;
4486      ID    oid;
4487      int argc;                   /* OK */
4488      VALUE *argv;                /* OK */
4489      NODE *body;                 /* OK */
4490      int nosuper;
4491  {
4492      NODE *b2;           /* OK */
4493      volatile VALUE result = Qnil;
4494      int itr;
4495      static int tick;
4496      TMP_PROTECT;
4497
4498      switch (ruby_iter-&gt;iter) {
4499        case ITER_PRE:
4500          itr = ITER_CUR;
4501          break;
4502        case ITER_CUR:
4503        default:
4504          itr = ITER_NOT;
4505          break;
4506      }
4507
4508      if ((++tick &amp; 0xff) == 0) {
4509          CHECK_INTS;             /* better than nothing */
4510          stack_check();
4511      }
4512      PUSH_ITER(itr);
4513      PUSH_FRAME();
4514
4515      ruby_frame-&gt;last_func = id;
4516      ruby_frame-&gt;orig_func = oid;
4517      ruby_frame-&gt;last_class = nosuper?0:klass;
4518      ruby_frame-&gt;self = recv;
4519      ruby_frame-&gt;argc = argc;
4520      ruby_frame-&gt;argv = argv;
4521
4522      switch (nd_type(body)) {
              /* ... main process ... */
4698
4699        default:
4700          rb_bug("unknown node type %d", nd_type(body));
4701          break;
4702      }
4703      POP_FRAME();
4704      POP_ITER();
4705      return result;
4706  }

(eval.c)
</pre>
<p>First, an `<span class="caps">ITER</span>` is pushed and whether or not the method is an iterator is
finally fixed. As its value is used by the `PUSH_FRAME()` which comes
immediately after it, `PUSH_ITER()` needs to appear beforehand.
`PUSH_FRAME()` will be discussed soon.</p>
<p>And if I first describe about the &#8220;&#8230; main process &#8230;&#8221; part,
it branches based on the following node types
and each branch does its invoking process.</p>
<table>
	<tr>
		<td> `NODE_CFUNC`   </td>
		<td> methods defined in C </td>
	</tr>
	<tr>
		<td> `NODE_IVAR`    </td>
		<td> `attr_reader` </td>
	</tr>
	<tr>
		<td> `NODE_ATTRSET` </td>
		<td> `attr_writer` </td>
	</tr>
	<tr>
		<td> `NODE_SUPER`   </td>
		<td> `super` </td>
	</tr>
	<tr>
		<td> `NODE_ZSUPER`  </td>
		<td> `super` without arguments </td>
	</tr>
	<tr>
		<td> `NODE_DMETHOD` </td>
		<td> invoke `UnboundMethod` </td>
	</tr>
	<tr>
		<td> `NODE_BMETHOD` </td>
		<td> invoke `Method` </td>
	</tr>
	<tr>
		<td> `NODE_SCOPE`   </td>
		<td> methods defined in Ruby </td>
	</tr>
</table>
<p>Some of the above nodes are not explained in this book but not so important and
could be ignored.  The important things are only `NODE_CFUNC`, `NODE_SCOPE` and
`NODE_ZSUPER`.</p>
<h3>`PUSH_FRAME()`</h3>
<p class="caption">▼ `PUSH_FRAME() POP_FRAME()` </p>

<pre class="longlist">
 536  #define PUSH_FRAME() do {               \
 537      struct FRAME _frame;                \
 538      _frame.prev = ruby_frame;           \
 539      _frame.tmp  = 0;                    \
 540      _frame.node = ruby_current_node;    \
 541      _frame.iter = ruby_iter-&gt;iter;      \
 542      _frame.cbase = ruby_frame-&gt;cbase;   \
 543      _frame.argc = 0;                    \
 544      _frame.argv = 0;                    \
 545      _frame.flags = FRAME_ALLOCA;        \
 546      ruby_frame = &amp;_frame

 548  #define POP_FRAME()                     \
 549      ruby_current_node = _frame.node;    \
 550      ruby_frame = _frame.prev;           \
 551  } while (0)

(eval.c)
</pre>
<p>First, we&#8217;d like to make sure the entire `<span class="caps">FRAME</span>` is allocated on the stack.
This is identical to `module_setup()`. The rest is basically just doing
ordinary initializations.</p>
<p>If I add one more description, the flag `FRAME_ALLOCA` indicates the allocation
method of the `<span class="caps">FRAME</span>`. `FRAME_ALLOCA` obviously indicates &#8220;it is on the stack&#8221;.</p>
<h3>`rb_call0()` &#8211; `NODE_CFUNC`</h3>
<p>A lot of things are written in this part of the original code,
but most of them are related to `trace_func` and substantive code is only the
following line:</p>
<p class="caption">▼ `rb_call0()` − `NODE_CFUNC` (simplified)</p>

<pre class="longlist">
case NODE_CFUNC:
  result = call_cfunc(body-&gt;nd_cfnc, recv, len, argc, argv);
  break;
</pre>
<p>Then, as for `call_cfunc()` &#8230;</p>
<p class="caption">▼ `call_cfunc()` (simplified)</p>

<pre class="longlist">
4394  static VALUE
4395  call_cfunc(func, recv, len, argc, argv)
4396      VALUE (*func)();
4397      VALUE recv;
4398      int len, argc;
4399      VALUE *argv;
4400  {
4401      if (len &gt;= 0 &amp;&amp; argc != len) {
4402          rb_raise(rb_eArgError, "wrong number of arguments(%d for %d)",
4403                   argc, len);
4404      }
4405
4406      switch (len) {
4407        case -2:
4408          return (*func)(recv, rb_ary_new4(argc, argv));
4409          break;
4410        case -1:
4411          return (*func)(argc, argv, recv);
4412          break;
4413        case 0:
4414          return (*func)(recv);
4415          break;
4416        case 1:
4417          return (*func)(recv, argv[0]);
4418          break;
4419        case 2:
4420          return (*func)(recv, argv[0], argv[1]);
4421          break;
                ：
                ：
4475        default:
4476          rb_raise(rb_eArgError, "too many arguments(%d)", len);
4477          break;
4478      }
4479      return Qnil;                /* not reached */
4480  }

(eval.c)
</pre>
<p>As shown above, it branches based on the argument count.
The maximum argument count is 15.</p>
<p>Note that neither `<span class="caps">SCOPE</span>` or `<span class="caps">VARS</span>` is pushed when it is `NODE_CFUNC`. It makes
sense because a method defined in C does not use Ruby&#8217;s local
variables. But it simultaneously means that if the &#8220;current&#8221; local variables are
accessed by `C`, they are actually the local variables of the previous `<span class="caps">FRAME</span>`.
And in some places, say, `rb_svar` (`eval.c`), it is actually done.</p>
<h3>`rb_call0()` &#8211; `NODE_SCOPE`</h3>
<p>`NODE_SCOPE` is to invoke a method defined in Ruby.
This part forms the foundation of Ruby.</p>
<p class="caption">▼ `rb_call0()` − `NODE_SCOPE` (outline)</p>

<pre class="longlist">
4568  case NODE_SCOPE:
4569    {
4570        int state;
4571        VALUE *local_vars;  /* OK */
4572        NODE *saved_cref = 0;
4573
4574        PUSH_SCOPE();
4575
            /* （A）forward CREF */
4576        if (body-&gt;nd_rval) {
4577            saved_cref = ruby_cref;
4578            ruby_cref = (NODE*)body-&gt;nd_rval;
4579            ruby_frame-&gt;cbase = body-&gt;nd_rval;
4580        }
            /* （B）initialize ruby_scope-&gt;local_vars */
4581        if (body-&gt;nd_tbl) {
4582            local_vars = TMP_ALLOC(body-&gt;nd_tbl[0]+1);
4583            *local_vars++ = (VALUE)body;
4584            rb_mem_clear(local_vars, body-&gt;nd_tbl[0]);
4585            ruby_scope-&gt;local_tbl = body-&gt;nd_tbl;
4586            ruby_scope-&gt;local_vars = local_vars;
4587        }
4588        else {
4589            local_vars = ruby_scope-&gt;local_vars = 0;
4590            ruby_scope-&gt;local_tbl  = 0;
4591        }
4592        b2 = body = body-&gt;nd_next;
4593
4594        PUSH_VARS();
4595        PUSH_TAG(PROT_FUNC);
4596
4597        if ((state = EXEC_TAG()) == 0) {
4598            NODE *node = 0;
4599            int i;

                /* ……（C）assign the arguments to the local variables …… */

4666            if (trace_func) {
4667                call_trace_func("call", b2, recv, id, klass);
4668            }
4669            ruby_last_node = b2;
                /* （D）method body */
4670            result = rb_eval(recv, body);
4671        }
4672        else if (state == TAG_RETURN) { /* back via return */
4673            result = prot_tag-&gt;retval;
4674            state = 0;
4675        }
4676        POP_TAG();
4677        POP_VARS();
4678        POP_SCOPE();
4679        ruby_cref = saved_cref;
4680        if (trace_func) {
4681            call_trace_func("return", ruby_last_node, recv, id, klass);
4682        }
4683        switch (state) {
4684          case 0:
4685            break;
4686
4687          case TAG_RETRY:
4688            if (rb_block_given_p()) {
4689               JUMP_TAG(state);
4690            }
4691            /* fall through */
4692          default:
4693            jump_tag_but_local_jump(state);
4694            break;
4695        }
4696    }
4697    break;

(eval.c)
</pre>
<p>(A) `<span class="caps">CREF</span>` forwarding, which was described at the section of constants in the
previous chapter.
In other words, `cbase` is transplanted to `<span class="caps">FRAME</span>` from the method entry.</p>
<p>(B) The content here is completely identical to what is done at `module_setup()`.
An array is allocated at `local_vars` of `<span class="caps">SCOPE</span>`. With this and
`PUSH_SCOPE()` and `PUSH_VARS()`, the local variable scope creation is completed.
After this, one can execute `rb_eval()` in the exactly same environment as the
interior of the method.</p>
<p>(C) This sets the received arguments to the parameter variables.
The parameter variables are in essence identical to the local variables. Things
such as the number of arguments are specified by `NODE_ARGS`, all it has to do
is setting one by one. Details will be explained soon. And,</p>
<p>(D) this executes the method body. Obviously, the receiver (`recv`) becomes
`self`. In other words, it becomes the first argument of `rb_eval()`. After all,
the method is completely invoked.</p>
<h3>Set Parameters</h3>
<p>Then, we&#8217;ll examine the totally skipped part, which sets parameters.
But before that, I&#8217;d like you to first check the syntax tree of the method again.</p>
<pre class="screen">
% ruby -rnodedump -e 'def m(a) nil end'
NODE_SCOPE
nd_rval = (null)
nd_tbl = 3 [ _ ~ a ]
nd_next:
    NODE_BLOCK
    nd_head:
        NODE_ARGS
        nd_cnt  = 1
        nd_rest = -1
        nd_opt = (null)
    nd_next:
        NODE_BLOCK
        nd_head:
            NODE_NEWLINE
            nd_file = "-e"
            nd_nth  = 1
            nd_next:
                NODE_NIL
        nd_next = (null)
</pre>
<p>`NODE_ARGS` is the node to specify the parameters of a method.
I aggressively dumped several things,
and it seemed its members are used as follows:</p>
<table>
	<tr>
		<td> `nd_cnt` </td>
		<td> the number of the normal parameters </td>
	</tr>
	<tr>
		<td> `nd_rest` </td>
		<td> the variable `ID` of the `rest` parameter. `-1` if the `rest` parameter is missing </td>
	</tr>
	<tr>
		<td> `nd_opt` </td>
		<td> holds the syntax tree to represent the default values of the option parameters. a list of `NODE_BLOCK` </td>
	</tr>
</table>
<p>If one has this amount of the information, the local variable `ID` for each
parameter variable can be uniquely determined.
First, I mentioned that 0 and 1 are always `$<em>` and `$~`.
In 2 and later, the necessary number of ordinary parameters are in line.
The number of option parameters can be determined by the length of `<span class="caps">NODE</span></em><span class="caps">BLOCK</span>`.
Again next to them, the rest-parameter comes.</p>
<p>For example, if you write a definition as below,</p>
<pre class="emlist">
def m(a, b, c = nil, *rest)
  lvar1 = nil
end
</pre>
<p>local variable IDs are assigned as follows.</p>
<pre class="emlist">
0   1   2   3   4   5      6
$_  $~  a   b   c   rest   lvar1
</pre>
<p>Are you still with me?
Taking this into considerations, let&#8217;s look at the code.</p>
<p class="caption">▼ `rb_call0()` − `NODE_SCOPE` −assignments of arguments</p>

<pre class="longlist">
4601  if (nd_type(body) == NODE_ARGS) { /* no body */
4602      node = body;           /* NODE_ARGS */
4603      body = 0;              /* the method body */
4604  }
4605  else if (nd_type(body) == NODE_BLOCK) { /* has body */
4606      node = body-&gt;nd_head;  /* NODE_ARGS */
4607      body = body-&gt;nd_next;  /* the method body */
4608  }
4609  if (node) {  /* have somewhat parameters */
4610      if (nd_type(node) != NODE_ARGS) {
4611          rb_bug("no argument-node");
4612      }
4613
4614      i = node-&gt;nd_cnt;
4615      if (i &gt; argc) {
4616          rb_raise(rb_eArgError, "wrong number of arguments(%d for %d)",
4617                   argc, i);
4618      }
4619      if (node-&gt;nd_rest == -1) {  /* no rest parameter */
              /* counting the number of parameters */
4620          int opt = i;   /* the number of parameters (i is nd_cnt) */
4621          NODE *optnode = node-&gt;nd_opt;
4622
4623          while (optnode) {
4624              opt++;
4625              optnode = optnode-&gt;nd_next;
4626          }
4627          if (opt &lt; argc) {
4628              rb_raise(rb_eArgError,
4629                  "wrong number of arguments(%d for %d)", argc, opt);
4630          }
              /* assigning at the second time in rb_call0 */
4631          ruby_frame-&gt;argc = opt;
4632          ruby_frame-&gt;argv = local_vars+2;
4633      }
4634
4635      if (local_vars) { /* has parameters */
4636          if (i &gt; 0) {             /* has normal parameters */
4637              /* +2 to skip the spaces for $_ and $~ */
4638              MEMCPY(local_vars+2, argv, VALUE, i);
4639          }
4640          argv += i; argc -= i;
4641          if (node-&gt;nd_opt) {      /* has option parameters */
4642              NODE *opt = node-&gt;nd_opt;
4643
4644              while (opt &amp;&amp; argc) {
4645                  assign(recv, opt-&gt;nd_head, *argv, 1);
4646                  argv++; argc--;
4647                  opt = opt-&gt;nd_next;
4648              }
4649              if (opt) {
4650                  rb_eval(recv, opt);
4651              }
4652          }
4653          local_vars = ruby_scope-&gt;local_vars;
4654          if (node-&gt;nd_rest &gt;= 0) { /* has rest parameter */
4655              VALUE v;
4656
                  /* make an array of the remainning parameters and assign it to a variable */
4657              if (argc &gt; 0)
4658                  v = rb_ary_new4(argc,argv);
4659              else
4660                  v = rb_ary_new2(0);
4661              ruby_scope-&gt;local_vars[node-&gt;nd_rest] = v;
4662          }
4663      }
4664  }

(eval.c)
</pre>
<p>Since comments are added more than before,
you might be able to understand what it is doing by following step-by-step.</p>
<p>One thing I&#8217;d like to mention is about `argc` and `argv` of `ruby_frame`.
It seems to be updated only when any rest-parameter does not exist,
why is it only when any rest-parameter does not exist?</p>
<p>This point can be understood by thinking about the purpose of `argc` and `argv`.
These members actually exist for `super` without arguments.
It means the following form:</p>
<pre class="emlist">
super
</pre>
<p>This `super` has a behavior to directly pass the parameters of the currently executing method.
To enable to pass at the moment, the arguments are saved in `ruby_frame&#8594;argv`.</p>
<p>Going back to the previous story here,
if there&#8217;s a rest-parameter, passing the original parameters list somehow seems more convenient.
If there&#8217;s not, the one after option parameters are assigned seems better.</p>
<pre class="emlist">
def m(a, b, *rest)
  super     # probably 5, 6, 7, 8 should be passed
end
m(5, 6, 7, 8)

def m(a, b = 6)
  super     # probably 5, 6 should be passed
end
m(5)
</pre>
<p>This is a question of which is better as a specification rather than &#8220;it must be&#8221;.
If a method has a rest-parameter,
it supposed to also have a rest-parameter at superclass.
Thus, if the value after processed is passed, there&#8217;s the high possibility of being inconvenient.</p>
<p>Now, I&#8217;ve said various things, but the story of method invocation is all done.
The rest is, as the ending of this chapter, looking at the implementation of
`super` which is just discussed.</p>
<h3>`super`</h3>
<p>What corresponds to `super` are `NODE_SUPER` and `NODE_ZSUPER`.
`NODE_SUPER` is ordinary `super`,
and `NODE_ZSUPER` is `super` without arguments.</p>
<p class="caption">▼ `rb_eval()` − `NODE_SUPER` </p>

<pre class="longlist">
2780        case NODE_SUPER:
2781        case NODE_ZSUPER:
2782          {
2783              int argc; VALUE *argv; /* used in SETUP_ARGS */
2784              TMP_PROTECT;
2785
                  /*（A）case when super is forbidden */
2786              if (ruby_frame-&gt;last_class == 0) {
2787                  if (ruby_frame-&gt;orig_func) {
2788                      rb_name_error(ruby_frame-&gt;last_func,
2789                                    "superclass method `%s' disabled",
2790                                    rb_id2name(ruby_frame-&gt;orig_func));
2791                  }
2792                  else {
2793                      rb_raise(rb_eNoMethodError,
                                   "super called outside of method");
2794                  }
2795              }
                  /*（B）setup or evaluate parameters */
2796              if (nd_type(node) == NODE_ZSUPER) {
2797                  argc = ruby_frame-&gt;argc;
2798                  argv = ruby_frame-&gt;argv;
2799              }
2800              else {
2801                  BEGIN_CALLARGS;
2802                  SETUP_ARGS(node-&gt;nd_args);
2803                  END_CALLARGS;
2804              }
2805
                  /*（C）yet mysterious PUSH_ITER() */
2806              PUSH_ITER(ruby_iter-&gt;iter?ITER_PRE:ITER_NOT);
2807              SET_CURRENT_SOURCE();
2808              result = rb_call(RCLASS(ruby_frame-&gt;last_class)-&gt;super,
2809                               ruby_frame-&gt;self, ruby_frame-&gt;orig_func,
2810                               argc, argv, 3);
2811              POP_ITER();
2812          }
2813          break;

(eval.c)
</pre>
<p>For `super` without arguments, I said that `ruby_frame&#8594;argv` is directly used
as arguments, this is directly shown at (B).</p>
<p>(C) just before calling `rb_call()`, doing `PUSH_ITER()`.
This is also what cannot be explained in detail, but in this way the block
passed to the current method can be handed over to the next method (meaning, the
method of superclass that is going to be called).</p>
<p>And finally, (A) when `ruby_frame&#8594;last_class` is 0, calling `super` seems forbidden.
Since the error message says &#8220;`must be enabled by rb_enable_super()`&#8221;,
it seems it becomes callable by calling `rb_enable_super()`.
<br>((errata: The error message &#8220;`must be enabled by rb_enable_super()`&#8221; exists not
in this list but in `rb_call_super()`.))
<br>Why?</p>
<p>First, If we investigate in what kind of situation `last_class` becomes 0,
it seems that it is while executing the method whose substance is defined in C (`NODE_CFUNC`).
Moreover, it is the same when doing `alias` or replacing such method.</p>
<p>I&#8217;ve understood until there, but even though reading source codes, I couldn&#8217;t
understand the subsequents of them.
Because I couldn&#8217;t, I searched &#8220;`rb_enable_super`&#8221; over the `ruby`&#8217;s
mailing list archives and found it.
According to that mail, the situation looks like as follows:</p>
<p>For example, there&#8217;s a method named `String.new`.
Of course, this is a method to create a string.
`String.new` creates a struct of `T_STRING`.
Therefore, you can expect that the receiver is always of `T_STRING` when
writing an instance methods of `String`.</p>
<p>Then, `super` of `String.new` is `Object.new`.
`Object.new` create a struct of `T_OBJECT`.
What happens if `String.new` is replaced by new definition and `super` is called?</p>
<pre class="emlist">
def String.new
  super
end
</pre>
<p>As a consequence, an object whose struct is of `T_OBJECT` but whose class is `String` is created.
However, a method of `String` is written with expectation of a struct of `T_STRING`,
so naturally it downs.</p>
<p>How can we avoid this? The answer is to forbid to call any method expecting a
struct of a different struct type.
But the information of &#8220;expecting struct type&#8221; is not attached to method,
and also not to class.
For example, if there&#8217;s a way to obtain `T_STRING` from `String` class,
it can be checked before calling, but currently we can&#8217;t do such thing.
Therefore, as the second-best plan,
&#8220;`super` from methods defined in C is forbidden&#8221; is defined.
In this way, if the layer of methods at C level is precisely created,
it cannot be got down at least.
And, when the case is &#8220;It&#8217;s absolutely safe, so allow `super`&#8221;,
`super` can be enabled by calling `rb_enable_super()`.</p>
<p>In short, the heart of the problem is miss match of struct types.
This is the same as the problem that occurs at the allocation framework.</p>
<p>Then, how to solve this is to solve the root of the problem that &#8220;the class
does not know the struct-type of the instance&#8221;.
But, in order to resolve this, at least new <span class="caps">API</span> is necessary,
and if doing more deeply, compatibility will be lost.
Therefore, for the time being, the final solution has not decided yet.</p>

    <footer>
      The original work is Copyright © 2002 - 2004 Minero AOKI.
      Translated by Vincent ISAMBART and Clifford Escobar CAOILE
      This work is licensed under a
      <p>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/">Creative Commons Attribution-NonCommercial-ShareAlike2.5 License</a>
      </p>
    </footer>

  </div>
</body>
</html>
