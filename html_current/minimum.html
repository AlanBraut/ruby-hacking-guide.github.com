<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>  A Minimal Introduction to Ruby |  Ruby Hacking Guide </title>
  <link rel="stylesheet" href="/css/styles.css" />
</head>
<body>

  <div id="main">

    <header>
      <h1><a href="/">Ruby Hacking Guide</a></h1>
    </header>

    <nav role="navigation">
      <ul>
      </ul>
    </nav>

    <p>Translated by Sebastian Krause</p>
<h1 id="chapter">Chapter 1: Introduction</h1>
<h2>A Minimal Introduction to Ruby</h2>
<p>Here the Ruby prerequisites are explained, which one needs to know
in order to understand the first section.
I won&#8217;t point out programming techniques or points one should be
careful about. So don&#8217;t think you&#8217;ll be able to write Ruby programs just because
you read this chapter. Readers who have prior experience with Ruby
can skip this chapter.</p>
<p>We will talk about grammar extensively in the second section, hence
I won&#8217;t delve into the finer points of grammar here. From hash literals
and such I&#8217;ll show only the most widely used notations. On principle
I won&#8217;t omit things even if I can. This way the syntax becomes more simple.
I won&#8217;t always say &#8220;We can omit this&#8221;.</p>
<h2>Objects</h2>
<h3>Strings</h3>
<p>Everything that can be manipulated in a Ruby program is an object.
There are no primitives as Java&#8217;s `int` and `long`. For instance
if we write as below it denotes a string object with content `content`.</p>
<pre class="emlist">
"content"
</pre>
<p>I casually called it a  string object but to be precise this is an expression which generates
a string object. Therefore if we write it several times each time
another string object is generated.</p>
<pre class="emlist">
"content"
"content"
"content"
</pre>
<p>Here three string objects with content `content` are generated.</p>
<p>By the way, objects just existing there can&#8217;t be seen by programmers.
Let&#8217;s show how to print them on the terminal.</p>
<pre class="emlist">
p("content")   # Shows "content"
</pre>
<p>Everything after an `#` is a comment. From now on, I&#8217;ll put the result
of an expression in a comment behind.</p>
<p>`p(`……`)` calls the function `p`. It displays arbitrary objects &#8220;as such&#8221;.
It&#8217;s basically a debugging function.</p>
<p>Precisely speaking, there are no functions in Ruby, but just for now
we can think of it as a function.
You can use functions wherever you are.</p>
<h3>Various Literals</h3>
<p>Now, let&#8217;s explain some more the expressions which directly generate objects,
the so-called literals.
First the integers and floating point numbers.</p>
<pre class="emlist">
# Integer
1
2
100
9999999999999999999999999   # Arbitrarily big integers

# Float
1.0
99.999
1.3e4     # 1.3×10^4
</pre>
<p>Don&#8217;t forget that these are all expressions which generate objects.
I&#8217;m repeating myself but there are no primitives in Ruby.</p>
<p>Below an array object is generated.</p>
<pre class="emlist">
[1, 2, 3]
</pre>
<p>This program generates an array which consists of the three integers
1, 2 and 3 in that order. As the elements of an array can be arbitrary
objects the following is also possible.</p>
<pre class="emlist">
[1, "string", 2, ["nested", "array"]]
</pre>
<p>And finally, a hash table is generated by the expression below.</p>
<pre class="emlist">
{"key"=&gt;"value", "key2"=&gt;"value2", "key3"=&gt;"value3"}
</pre>
<p>A hash table is a structure which expresses one-to-one relationships between arbitrary objects.
The above line creates a table which stores the following relationships.</p>
<pre class="emlist">
"key"   →  "value"
"key2"  →  "value2"
"key3"  →  "value3"
</pre>
<p>If we ask a hash table created in this way &#8220;What&#8217;s corresponding to `key`?&#8221;, it&#8217;ll
answer &#8220;That&#8217;s `value`.&#8221; How can we ask? We use methods.</p>
<h3>Method Calls</h3>
<p>We can call methods on an object. In C++ Jargon they are member functions.
I don&#8217;t think it&#8217;s necessary to explain what a method is. I&#8217;ll just explain
the notation.</p>
<pre class="emlist">
"content".upcase()
</pre>
<p>Here the `upcase` method is called on a string object ( with content `content`).
As `upcase` is a method which
returns a new string with the small letters replaced by capital letters,
we get the following result.</p>
<pre class="emlist">
p("content".upcase())   # Shows "CONTENT"
</pre>
<p>Method calls can be chained.</p>
<pre class="emlist">
"content".upcase().downcase()
</pre>
<p>Here the method `downcase` is called on the return value of `&#8220;content&#8221;.upcase()`.</p>
<p>There are no public fields (member variables) as in Java or C++. The object interface consists of methods only.</p>
<h2>The Program</h2>
<h3>Top Level</h3>
<p>In Ruby we can just write expressions and it becomes a program.
One doesn&#8217;t need to define a `main()` as in C++ or Java.</p>
<pre class="emlist">
p("content")
</pre>
<p>This is a complete Ruby program. If we put this into a file called
`first.rb` we can execute it from the command line as follows.</p>
<pre class="screen">
% ruby first.rb
"content"
</pre>
<p>With the `-e` option of the `ruby` program we don&#8217;t even need to create a file.</p>
<pre class="screen">
% ruby -e 'p("content")'
"content"
</pre>
<p>By the way, the place where `p` is written is the lowest nesting level of the program,
it means the highest level from the program&#8217;s standpoint,
thus it&#8217;s called &#8220;top-level&#8221;.
Having top-level is a characteristic trait of Ruby as a scripting language.</p>
<p>In Ruby, one line is usually one statement. A semicolon at the end isn&#8217;t necessary.
Therefore the program below is interpreted as three statements.</p>
<pre class="emlist">
p("content")
p("content".upcase())
p("CONTENT".downcase())
</pre>
<p>When we execute it it looks like this.</p>
<pre class="screen">
% ruby second.rb
"content"
"CONTENT"
"content"
</pre>
<h3>Local Variables</h3>
<p>In Ruby all variables and constants store references to objects.
That&#8217;s why one can&#8217;t copy the content by assigning one variable to another variable.
Variables of type Object in Java or pointers to objects in C++ are good to think of.
However, you can&#8217;t change the value of each pointer itself.</p>
<p>In Ruby one can tell the classification (scope) of a variable
by the beginning of the name.
Local variables start with a small letter or an underscore.
One can write assignments by using &#8220;`=`&#8221;.</p>
<pre class="emlist">
str = "content"
arr = [1,2,3]
</pre>
<p>An initial assignment serves as declaration, an explicit declaration is
not necessary. Because variables don&#8217;t have types,
we can assign any kind of objects indiscriminately.
The program below is completely legal.</p>
<pre class="emlist">
lvar = "content"
lvar = [1,2,3]
lvar = 1
</pre>
<p>But even if we can, we don&#8217;t have to do it. If different kind of
objects are put in one variable, it tends to become difficult to read. In a
real world Ruby program one  doesn&#8217;t do this kind of things without a good reason.
The above was just an example for the sake of it.</p>
<p>Variable reference has also a pretty sensible notation.</p>
<pre class="emlist">
str = "content"
p(str)           # Shows "content"
</pre>
<p>In addition let&#8217;s check the point that a variable hold a reference by taking an example.</p>
<pre class="emlist">
a = "content"
b = a
c = b
</pre>
<p>After we execute this program all three local variables `a b c`
point to the same object, a string object with content `&#8220;content&#8221;`
created on the first line (Figure 1).</p>
<p><img src="images/ch_minimum_reference.png" title="Ruby variables store references to objects" alt="Ruby variables store references to objects" /></p>
<p>By the way, as these variables are called local,
they should be local to somewhere,
but we cannot talk about this scope without reading a bit further.
Let&#8217;s say for now that the top level is one local scope.</p>
<h3>Constants</h3>
<p>Constants start with a capital letter. They can only be assigned
once (at their creation).</p>
<pre class="emlist">
Const = "content"
PI = 3.1415926535

p(Const)   # Shows "content"
</pre>
<p>I&#8217;d like to say that if we assign twice an error occurs. But there
is just a warning, not an error.
It is in this way in order to avoid raising an error
even when the same file is loaded twice
in applications that manipulate Ruby program itself,
for instance in development environments.
Therefore, it is allowed due to practical requirements and there&#8217;s no other choice,
but essentially there should be an error.
In fact, up until version 1.1 there really was an error.</p>
<pre class="emlist">
C = 1
C = 2   # There is a warning but ideally there should be an error.
</pre>
<p>A lot of people are fooled by the word constant.
A constant only does not switch objects once it is assigned.
But it does not mean the pointed object itself won&#8217;t change.
The term &#8220;read only&#8221;
might capture the concept better than &#8220;constant&#8221;.</p>
<p>By the way, to indicate that an object itself shouldn&#8217;t be changed
another means is used: `freeze`.</p>
<p><img src="images/ch_minimum_const.jpg" title="constant means read only" alt="constant means read only" /></p>
<p>And the scope of constants is actually also cannot be described yet.
It will be discussed later in the next section mixing with classes.</p>
<h3>Control Structures</h3>
<p>Since Ruby has a wide abundance of control structures,
just lining up them can be a huge task.
For now, I just mention that there are `if` and `while`.</p>
<pre class="emlist">
if i &lt; 10 then
  # body
end

while i &lt; 10 do
  # body
end
</pre>
<p>In a conditional expression,
only the two objects, `false` and `nil`, are false and all
other various objects are true. 0 or the empty string are also true of course.</p>
<p>It wouldn&#8217;t be wise if there were just `false`, there is also `true`.
And it is of course true.</p>
<h2>Classes and Methods</h2>
<h3>Classes</h3>
<p>In object oriented system, essentially methods belong to objects.
It can hold only in a ideal world, though.
In a normal program there are a lot of objects which have the
same set of methods, it would be an enormous work if each object remember the
set of callable methods.
Usually a mechanism like classes or
multimethods is used to get rid of the duplication of definitions.</p>
<p>In Ruby, as the traditional way to bind objects and methods together,
the concept of classes is used.
Namely every object belongs to a class, the methods
which can be called are determined by the class.
And in this way, an object is called &#8220;an instance of the XX class&#8221;.</p>
<p>For example the string `&#8220;str&#8221;` is an instance of the `String` class.
And on this `String` class the methods `upcase`, `downcase`, `strip` and
many others are defined. So it looks as if each string object can respond to all these
methods.</p>
<pre class="emlist">
# They all belong to the String class,
# hence the same methods are defined
       "content".upcase()
"This is a pen.".upcase()
    "chapter II".upcase()

       "content".length()
"This is a pen.".length()
    "chapter II".length()
</pre>
<p>By the way, what happens if the called method isn&#8217;t defined?
In a static language a compiler error occurs but in Ruby there
is a runtime exception. Let&#8217;s try it out. For this kind of programs the
`-e` option is handy.</p>
<pre class="screen">
% ruby -e '"str".bad_method()'
-e:1: undefined method `bad_method' for "str":String (NoMethodError)
</pre>
<p>When the method isn&#8217;t found there&#8217;s apparently a `NoMethodError`.</p>
<p>Always saying &#8220;the upcase method of String&#8221; and such is cumbersome.
Let&#8217;s introduce a special notation `String#upcase` refers to the method
`upcase` defined in the class `String`.</p>
<p>By the way, if we write `String.upcase` it has a completely different
meaning in the Ruby world. What could that be? I explain it in the
next paragraph.</p>
<h3>Class Definition</h3>
<p>Up to now we talked about already defined classes.
We can of course also define our own classes.
To define classes we use the `class` statement.</p>
<pre class="emlist">
class C
end
</pre>
<p>This is the definition of a new class `C`. After we defined it we
can use it as follows.</p>
<pre class="emlist">
class C
end
c = C.new()   # create an instance of C and assign it to the variable c
</pre>
<p>Note that the notation for creating a new instance is not `new C`.
The astute reader might think:
Hmm, this `C.new()` really looks like a method call.
In Ruby the object generating expressions are indeed just methods.</p>
<p>In Ruby class names and constant names are the same.
Then, what is stored in the constant whose name is the same as a class name?
In fact, it&#8217;s the class.
In Ruby all things which a program can manipulate are objects. So
of course classes are also expressed as objects. Let&#8217;s call these
<em>class objects</em>. Every class is an instance of the class `Class`.</p>
<p>In other words a `class` statement creates a new class object and
it assigns a constant named
with the classname to the class. On the other hand
the generation of an instance references this constant and calls a method
on this object ( usually new). If we look at the example below, it&#8217;s
pretty obvious that the creation of an instance doesn&#8217;t differ
from a normal method call.</p>
<pre class="emlist">
S = "content"
class C
end

S.upcase()  # Get the object the constant S points to and call upcase
C.new()     # Get the object the constant C points to and call new
</pre>
<p>So `new` is not a reserved word in Ruby.</p>
<p>And we can also use `p` for an instance of a class even immediately after its creation.</p>
<pre class="emlist">
class C
end

c = C.new()
p(c)       # #&lt;C:0x2acbd7e4&gt;
</pre>
<p>It won&#8217;t display as nicely as a string or an integer but it shows
its respective class and it&#8217;s internal ID. This ID is the pointer value
which points to the object.</p>
<p>Oh, I completely forgot to mention about the notation of method names:
`Object.new` means the class object `Object` and the `new` method called on the class itself.
So `Object#new` and `Object.new` are completely different things, we have
to separate them strictly.</p>
<pre class="emlist">
obj = Object.new()   # Object.new
obj.new()            # Object#new
</pre>
<p>In practice a method `Object#new` is almost never defined so the
second line will return an error.
Please regard this as an example of the notation.</p>
<h3>Method Definition</h3>
<p>Even if we can define classes,
it is useless if we cannot define methods.
Let&#8217;s define a method for our class `C`.</p>
<pre class="emlist">
class C
  def myupcase( str )
    return str.upcase()
  end
end
</pre>
<p>To define a method we use the `def` statement. In this example we
defined the method `myupcase`. The name of the only parameter is `str`.
As with variables, it&#8217;s not necessary to write parameter types or the return type.
And we can use any number of parameters.</p>
<p>Let&#8217;s use the defined method. Methods are usually called from the
outside by default.</p>
<pre class="emlist">
c = C.new()
result = c.myupcase("content")
p(result)   # Shows "CONTENT"
</pre>
<p>Of course if you get used to it you don&#8217;t need to assign every time.
The line below gives the same result.</p>
<pre class="emlist">
p(C.new().myupcase("content"))   # Also shows "CONTENT"
</pre>
<h3>`self`</h3>
<p>During the execution of a method the information about
who is itself (the instance on which the method was called) is always saved
and can be picked up in `self`.
Like the `this` in C++ or Java. Let&#8217;s check this out.</p>
<pre class="emlist">
class C
  def get_self()
    return self
  end
end

c = C.new()
p(c)              # #&lt;C:0x40274e44&gt;
p(c.get_self())   # #&lt;C:0x40274e44&gt;
</pre>
<p>As we see, the above two expressions return the exact same object.
We could confirm that `self` is `c` during the method call on `c`.</p>
<p>Then what is the way to call a method on itself?
What first comes to mind is calling via `self`.</p>
<pre class="emlist">
class C
  def my_p( obj )
    self.real_my_p(obj)   # called a method against oneself
  end

  def real_my_p( obj )
    p(obj)
  end
end

C.new().my_p(1)   # Output 1
</pre>
<p>But always adding the `self` when calling an own method is tedious.
Hence, it is designed so that one can omit the called method (the receiver)
whenever one calls a method on `self`.</p>
<pre class="emlist">
class C
  def my_p( obj )
    real_my_p(obj)   # You can call without specifying the receiver
  end

  def real_my_p( obj )
    p(obj)
  end
end

C.new().my_p(1)   # Output 1
</pre>
<h3>Instance Variables</h3>
<p>As there are a saying &#8220;Objects are data and code&#8221;,
just being able to define methods alone would be not so useful.
Each object must also be able to
to store data. In other words instance variables.
Or in C++ jargon member variables.</p>
<p>In the fashion of Ruby&#8217;s variable naming convention,
the variable type can be determined by the first a few characters.
For instance variables it&#8217;s an `@`.</p>
<pre class="emlist">
class C
  def set_i(value)
    @i = value
  end

  def get_i()
    return @i
  end
end

c = C.new()
c.set_i("ok")
p(c.get_i())   # Shows "ok"
</pre>
<p>Instance variables differ a bit from the variables seen before:
We can reference them without assigning (defining) them.
To see what happens we add the following lines to the code above.</p>
<pre class="emlist">
c = C.new()
p(c.get_i())   # Shows nil
</pre>
<p>Calling `get` without `set` gives `nil`. `nil` is the object
which indicates &#8220;nothing&#8221;.
It&#8217;s mysterious that there&#8217;s really an object but it means nothing,
but that&#8217;s just the way it is.</p>
<p>We can use `nil` like a literal as well.</p>
<pre class="emlist">
p(nil)   # Shows nil
</pre>
<h3>`initialize`</h3>
<p>As we saw before, when we call &#8216;new&#8217; on a freshly defined class,
we can create an instance. That&#8217;s sure, but
sometimes we might want to have a peculiar instantiation.
In this case we don&#8217;t change the `new` method,
we define the `initialize` method.
When we do this, it gets called within `new`.</p>
<pre class="emlist">
class C
  def initialize()
    @i = "ok"
  end
  def get_i()
    return @i
  end
end
c = C.new()
p(c.get_i())   # Shows "ok"
</pre>
<p>Strictly speaking this is the specification of the `new` method
but not the specification of the language itself.</p>
<h3>Inheritance</h3>
<p>Classes can inherit from other classes. For instance `String`
inherits from `Object`. In this book, we&#8217;ll indicate this relation
by a vertical arrow as in Fig.3.</p>
<p><img src="images/ch_minimum_supersub.jpg" title="Inheritance" alt="Inheritance" /></p>
<p>In the case of this illustration, the inherited class (`Object`) is called
superclass or superior class. The inheriting class (`String`) is called
subclass or inferior class. This point differs from C++ jargon, be careful.
But it&#8217;s the same as in Java.</p>
<p>Anyway let&#8217;s try it out. Let our created class inherit from another
class. To inherit from another class ( or designate a superclass)
write the following.</p>
<pre class="emlist">
class C &lt; SuperClassName
end
</pre>
<p>When we leave out the superclass like in the cases before the
class `Object` becomes tacitly the superclass.</p>
<p>Now, why should we want to inherit? Of course to hand over methods.
Handing over means that the methods which were defined in the
superclass also work in the subclass as if they were defined in there once more.
Let&#8217;s check it out.</p>
<pre class="emlist">
class C
  def hello()
    return "hello"
  end
end

class Sub &lt; C
end

sub = Sub.new()
p(sub.hello())   # Shows "hello"
</pre>
<p>`hello` was defined in the class `C` but we could call it on an instance of
the class `Sub` as well. Of course we don&#8217;t need to assign variables.
The above is the same as the line below.</p>
<pre class="emlist">
p(Sub.new().hello())
</pre>
<p>By defining a method with the same name, we can overwrite the method.
In C++ and Object Pascal (Delphi) it&#8217;s only possible to overwrite
functions explicitly defined with the keyword `virtual` but in Ruby every method
can be overwritten unconditionally.</p>
<pre class="emlist">
class C
  def hello()
    return "Hello"
  end
end

class Sub &lt; C
  def hello()
    return "Hello from Sub"
  end
end

p(Sub.new().hello())   # Shows "Hello from Sub"
p(C.new().hello())     # Shows "Hello"
</pre>
<p>We can inherit over several steps. For instance as in Fig.4
`Fixnum` inherits every method from `Object`, `Numeric` and `Integer`.
When there are methods with the same name the nearer classes take
preference. As type overloading isn&#8217;t there at all the requisites are
extremely straightforward.</p>
<p><img src="images/ch_minimum_multiinherit.jpg" title="Inheritance over multiple steps" alt="Inheritance over multiple steps" /></p>
<p>In C++ it&#8217;s possible to create a class which inherits nothing.
While in Ruby one has to inherit from the `Object` class either
directly or indirectly. In other words when we draw the inheritance
relations it becomes a single tree with `Object` at the top.
For example, when we draw a tree of the inheritance relations among the
important classes of the basic library, it would look like Fig.5.</p>
<p><img src="images/ch_minimum_classtree.jpg" title="Ruby&#39;s class tree" alt="Ruby&#39;s class tree" /></p>
<p>Once the superclass is appointed ( in the definition statement ) it&#8217;s
impossible to change it. In other words, one can add a new class to the class tree
but cannot change a position or delete a class.</p>
<h3>Inheritance of Variables……?</h3>
<p>In Ruby (instance) variables aren&#8217;t inherited.
Even though trying to inherit,
a class does not know about what variables are going to be used.</p>
<p>But when an inherited method is called ( in an instance of a subclass),
assignment of instance variables happens. Which means they
become defined. Then, since the namespace of instance variables
is completely flat based on each instance,
it can be accessed by a method of whichever class.</p>
<pre class="emlist">
class A
  def initialize()   # called from when processing new()
    @i = "ok"
  end
end

class B &lt; A
  def print_i()
    p(@i)
  end
end

B.new().print_i()   # Shows "ok"
</pre>
<p>If you can&#8217;t agree with this behavior, let&#8217;s forget about classes
and inheritance. When there&#8217;s an instance `obj` of
the class `C`, then think as if all the methods of the superclass of `C` are
defined in `C`. Of course we keep the overwrite rule in mind.
Then the methods of `C` get attached to the instance `obj` (Fig.6).
This strong palpability is a specialty of Ruby&#8217;s object orientation.</p>
<p><img src="images/ch_minimum_objimage.jpg" title="A conception of a Ruby object" alt="A conception of a Ruby object" /></p>
<h3>Modules</h3>
<p>Only a single superclass can be designated. So Ruby looks like
single inheritance. But because of <em>modules</em> it has in practice
the ability which is identical to multiple inheritance.
Let&#8217;s explain these modules next.</p>
<p>In short, modules are classes for which a superclass cannot be
designated and instances cannot be created.
For the definition we write as follows.</p>
<pre class="emlist">
module M
end
</pre>
<p>Here the module `M` was defined. Methods are defined exactly the
same way as for classes.</p>
<pre class="emlist">
module M
  def myupcase( str )
    return str.upcase()
  end
end
</pre>
<p>But because we cannot create instances, we cannot call them directly.
To do that, we use the module by &#8220;including&#8221; it into other classes.
Then we become to be able to deal with it as if a class inherited the module.</p>
<pre class="emlist">
module M
  def myupcase( str )
    return str.upcase()
  end
end

class C
  include M
end

p(C.new().myupcase("content"))  # "CONTENT" is shown
</pre>
<p>Even though no method was defined in the class `C` we can call
the method `myupcase`.
It means it &#8220;inherited&#8221; the method of the module `M`.
Inclusion is functionally completely the same as inheritance.
There&#8217;s no limit on defining methods or accessing instance variables.</p>
<p>I said we cannot specify any superclass of a module, but
other modules can be included.</p>
<pre class="emlist">
module M
end

module M2
  include M
end
</pre>
<p>In other words it&#8217;s functionally the same as appointing a superclass.
But a class cannot come above a module. Only modules are allowed
above modules.</p>
<p>The example below also contains the inheritance of methods.</p>
<pre class="emlist">
module OneMore
  def method_OneMore()
    p("OneMore")
  end
end

module M
  include OneMore

  def method_M()
    p("M")
  end
end

class C
  include M
end

C.new().method_M()         # Output "M"
C.new().method_OneMore()   # Output "OneMore"
</pre>
<p>As with classes when we sketch inheritance it looks like Fig.7</p>
<p><img src="images/ch_minimum_modinherit.jpg" title="multilevel inclusion" alt="multilevel inclusion" /></p>
<p>Besides, the class `C` also has a superclass.
How is its relationship to modules?
For instance, let&#8217;s think of the following case.</p>
<pre class="emlist">
# modcls.rb

class Cls
  def test()
    return "class"
  end
end

module Mod
  def test()
    return "module"
  end
end

class C &lt; Cls
  include Mod
end

p(C.new().test())   # "class"? "module"?
</pre>
<p>`C` inherits from `Cls` and includes `Mod`.
Which will be shown in this case, `&#8220;class&#8221;` or `&#8220;module&#8221;`?
In other words, which one is &#8220;closer&#8221;, class or module?
We&#8217;d better ask Ruby about Ruby, thus let&#8217;s execute it:</p>
<pre class="screen">
% ruby modcls.rb
"module"
</pre>
<p>Apparently a module takes preference before the superclass.</p>
<p>In general, in Ruby when a module is included, it would be inherited by going in between
the class and the superclass. As a picture it might look like Fig.8.</p>
<p><img src="images/ch_minimum_modclass.jpg" title="The relation between modules and classes" alt="The relation between modules and classes" /></p>
<p>And if we also taking the modules included in the module into accounts,
it would look like Fig.9.</p>
<p><img src="images/ch_minimum_modclass2.jpg" title="The relation between modules and classes(2)" alt="The relation between modules and classes(2)" /></p>
<h2>The Program revisited</h2>
<p>Caution. This section is extremely important and explaining the elements which are
not easy to mix with for programmers who have only used static languages before.
For other parts just skimming is sufficient,
but for only this part I&#8217;d like you to read it carefully.
The explanation will also be relatively attentive.</p>
<h3>Nesting of Constants</h3>
<p>First a repetition of constants. As a constant begins with a capital
letter the definition goes as follows.</p>
<pre class="emlist">
Const = 3
</pre>
<p>Now we reference the constant in this way.</p>
<pre class="emlist">
p(Const)   # Shows 3
</pre>
<p>Actually we can also write this.</p>
<pre class="emlist">
p(::Const)   # Shows 3 in the same way.
</pre>
<p>The `::` in front shows that it&#8217;s a constant defined at the top level.
You can think of the path in a filesystem. Assume there is a file `vmunix`
in the root directory. Being at `/` one can write `vmunix` to access the file. One
can also write `/vmunix` as its full path. It&#8217;s the same with `Const` and `::Const`.
At top level it&#8217;s okay to write only `Const` or to write the full path `::Const`</p>
<p>And what corresponds to a filesystem&#8217;s directories in Ruby?
That should be class and module definition statements.
However mentioning both is cumbersome, so I&#8217;ll just subsume them under
class definition. When one enters a class definition the level
for constants rises ( as if entering a directory).</p>
<pre class="emlist">
class SomeClass
  Const = 3
end

p(::SomeClass::Const)   # Shows 3
p(  SomeClass::Const)   # The same. Shows 3
</pre>
<p>`SomeClass` is defined at toplevel. Hence one can reference it by writing
either `SomeClass` or `::SomeClass`.
And as the constant `Const` nested in the class definition is a `Const` &#8220;inside `SomeClass`&#8221;,
It becomes `::SomeClass::Const`.</p>
<p>As we can create a directory in a directory,
we can create a class inside a class.
For instance like this:</p>
<pre class="emlist">
class C        # ::C
  class C2     # ::C::C2
    class C3   # ::C::C2::C3
    end
  end
end
</pre>
<p>By the way, for a constant defined in a class definition statement,
should we always write its
full name? Of course not. As with the filesystem, if one is inside the
same class definition one can skip the `::`. It becomes like that:</p>
<pre class="emlist">
class SomeClass
  Const = 3
  p(Const)   # Shows 3.
end
</pre>
<p>&#8220;What?&#8221; you might think.
Surprisingly, even if it is in a class definition statement,
we can write a program which is going to be executed.
People who are used to only static languages will find this quite exceptional.
I was also flabbergasted the first time I saw it.</p>
<p>Let&#8217;s add that we can of course also view a constant inside a method.
The reference rules are the same
as within the class definition (outside the method).</p>
<pre class="emlist">
class C
  Const = "ok"
  def test()
    p(Const)
  end
end

C.new().test()   # Shows "ok"
</pre>
<h3>Everything is executed</h3>
<p>Looking at the big picture I want to write one more thing.
In Ruby almost the whole parts of program is &#8220;executed&#8221;.
Constant definitions, class definitions and method definitions
and almost all the rest is executed in the apparent order.</p>
<p>Look for instance at the following code.
I used various constructions which have been used before.</p>
<pre class="emlist">
 1:  p("first")
 2:
 3:  class C &lt; Object
 4:    Const = "in C"
 5:
 6:    p(Const)
 7:
 8:    def myupcase(str)
 9:       return str.upcase()
10:    end
11:  end
12:
13:  p(C.new().myupcase("content"))
</pre>
<p>This program is executed in the following order:</p>
<table>
	<tr>
		<td>`1: p(&#8220;first&#8221;)`</td>
		<td>Shows `&#8220;first&#8221;`</td>
	</tr>
	<tr>
		<td>`3: &lt; Object`</td>
		<td>The constant `Object` is referenced and the class object `Object` is gained</td>
	</tr>
	<tr>
		<td>`3: class C`</td>
		<td>A new class object with superclass `Object` is generated, and assigned to the constant C</td>
	</tr>
	<tr>
		<td>`4: Const = &#8220;in C&#8221;`</td>
		<td>Assigning the value `&#8220;in C&#8221;` to the constant `::C::Const`</td>
	</tr>
	<tr>
		<td>`6: p(Const)`</td>
		<td>Showing the constant `::C::Const` hence `&#8220;in C&#8221;`</td>
	</tr>
	<tr>
		<td>`8: def myupcase(&#8230;)&#8230;end`</td>
		<td>Define `C#myupcase`</td>
	</tr>
	<tr>
		<td>`13: C.new().myupcase(&#8230;)`</td>
		<td>Refer the constant `C`, call the method `new` on it, and then `myupcase` on the return value</td>
	</tr>
	<tr>
		<td>`9: return str.upcase()`</td>
		<td>Returns `&#8220;<span class="caps">CONTENT</span>&#8221;`</td>
	</tr>
	<tr>
		<td>`13: p(&#8230;)`</td>
		<td>Shows `&#8220;<span class="caps">CONTENT</span>&#8221;`</td>
	</tr>
</table>
<h3>The Scope of Local Variables</h3>
<p>At last we can talk about the scope of local variables.</p>
<p>The toplevel, the interior of a class definition, the interior of a module definition and a method body are all
have each completely independent local variable scope.
In other words, the `lvar` variables in the following program are all different variables,
and they do not influence each other.</p>
<pre class="emlist">
lvar = 'toplevel'

class C
  lvar = 'in C'
  def method()
    lvar = 'in C#method'
  end
end

p(lvar)   # Shows "toplevel"

module M
  lvar = 'in M'
end

p(lvar)   # Shows "toplevel"
</pre>
<h3>`self` as context</h3>
<p>Previously, I said that during method execution oneself (an object on which the
method was called) becomes self.
That&#8217;s true but only half true.
Actually during the execution of a Ruby program,
`self` is always set wherever it is.
It means there&#8217;s `self` also at the top level or in a class definition statement.</p>
<p>For instance the `self` at the toplevel is `main`. It&#8217;s an instance
of the `Object` class which is nothing special. `main` is provided
to set up `self` for the time being. There&#8217;s no deeper meaning attached
to it.</p>
<p>Hence the toplevel&#8217;s `self` i.e. `main` is an instance of `Object`,
such that one can call the methods of `Object` there. And in `Object`
the module `Kernel` is included. In there the function-flavor methods
like `p` and `puts` are defined (Fig.10). That&#8217;s why one can
call `puts` and `p` also at the toplevel.</p>
<p><img src="images/ch_minimum_Kernel.jpg" title="`main`, `Object` and `Kernel`" alt="`main`, `Object` and `Kernel`" /></p>
<p>Thus `p` isn&#8217;t a function, it&#8217;s a method. Just because
it is defined in `Kernel` and thus can be called like a function as &#8220;its own&#8221;
method wherever it is or no matter what the class of `self` is.
Therefore, there aren&#8217;t functions in the true sense, there are only methods.</p>
<p>By the way, besides `p` and `puts` there are the function-flavor
methods `print`, `puts`, `printf`, `sprintf`, `gets`, `fork`, and `exec`
and many more with somewhat familiar names. When you look at the choice
of names you might be able to imagine Ruby&#8217;s character.</p>
<p>Well, since `self` is setup everywhere,
`self` should also be in a class definition in the same way.
The `self` in the class definition is the class itself (the class object).
Hence it would look like this.</p>
<pre class="emlist">
class C
  p(self)   # C
end
</pre>
<p>What should this be good for?
In fact, we&#8217;ve already seen an example in which it is very useful. This one.</p>
<pre class="emlist">
module M
end
class C
  include M
end
</pre>
<p>This `include` is actually a method call to the class object `C`.
I haven&#8217;t mentioned it yet but the parentheses around arguments
can be omitted for method calls. And I omitted the parentheses
around `include` such that it doesn&#8217;t look like a method call
because we have not finished the talk about class definition statement.</p>
<h3>Loading</h3>
<p>In Ruby the loading of libraries also happens at runtime.
Normally one writes this.</p>
<pre class="emlist">
require("library_name")
</pre>
<p>The impression isn&#8217;t false, `require` is a method. It&#8217;s not even
a reserved word. When it is written this way,
loading is executed on the line it is written,
and the execution is handed over to (the code of) the library.
As there is no concept like Java packages in Ruby,
when we&#8217;d like to separate namespaces,
it is done by putting files into a directory.</p>
<pre class="emlist">
require("somelib/file1")
require("somelib/file2")
</pre>
<p>And in the library usually classes and such are defined with `class` statements
or `module` statements. The constant scope of the top level is flat without the
distinction of files, so one can see classes defined in another file without
any special preparation.
To partition the namespace of class names one has to explicitly nest modules as shown below.</p>
<pre class="emlist">
# example of the namespace partition of net library
module Net
  class SMTP
    # ...
  end
  class POP
    # ...
  end
  class HTTP
    # ...
  end
end
</pre>
<h2>More about Classes</h2>
<h3>The talk about Constants still goes on</h3>
<p>Up to now we used the filesystem metaphor for
the scope of constants, but I want you to completely forget that.</p>
<p>There is more about constants. Firstly one can also see constants
in the &#8220;outer&#8221; class.</p>
<pre class="emlist">
Const = "ok"
class C
  p(Const)   # Shows "ok"
end
</pre>
<p>The reason why this is designed in this way is because
this becomes useful when modules are used as namespaces.
Let&#8217;s explain this by adding a few things to the previous example of `net` library.</p>
<pre class="emlist">
module Net
  class SMTP
    # Uses Net::SMTPHelper in the methods
  end
  class SMTPHelper   # Supports the class Net::SMTP
  end
end
</pre>
<p>In such case, it&#8217;s convenient if we can refer to it also from the `<span class="caps">SMTP</span>` class
just by writing `SMTPHelper`, isn&#8217;t it?
Therefore, it is concluded that &#8220;it&#8217;s convenient if we can see the outer classes&#8221;.</p>
<p>The outer class can be referenced no matter how many times it is nesting.
When the same name is defined on different levels, the one which will
first be found from within will be referred to.</p>
<pre class="emlist">
Const = "far"
class C
  Const = "near" # This one is closer than the one above
  class C2
    class C3
      p(Const)   # "near" is shown
    end
  end
end
</pre>
<p>There&#8217;s another way of searching constants. If the toplevel is reached
when going further and further outside then the own superclass is
searched for the constant.</p>
<pre class="emlist">
class A
  Const = "ok"
end
class B &lt; A
  p(Const)   # "ok" is shown
end
</pre>
<p>Really, that&#8217;s pretty complicated.</p>
<p>Let&#8217;s summarize. When looking up a constant, first the outer classes is
searched then the superclasses. This is quite contrived,
but let&#8217;s assume a class hierarchy as follows.</p>
<pre class="emlist">
class A1
end
class A2 &lt; A1
end
class A3 &lt; A2
  class B1
  end
  class B2 &lt; B1
  end
  class B3 &lt; B2
    class C1
    end
    class C2 &lt; C1
    end
    class C3 &lt; C2
      p(Const)
    end
  end
end
</pre>
<p>When the constant `Const` in `C3` is referenced, it&#8217;s looked
up in the order depicted in
Fig.11.</p>
<p><img src="images/ch_minimum_constref.jpg" title="Search order for constants" alt="Search order for constants" /></p>
<p>Be careful about one point. The superclasses of the classes outside,
for instance `A1` and `B2`, aren&#8217;t searched at all.
If it&#8217;s outside once it&#8217;s always outside and if it&#8217;s superclass once
it&#8217;s always superclass. Otherwise, the number of classes searched would
become too big and the behavior of such complicated thing would become unpredictable.</p>
<h3>Metaclasses</h3>
<p>I said that a method can be called on if it is an object.
I also said that the methods that can be called are determined by the class of an object.
Then shouldn&#8217;t there be
a class for class objects? (Fig.12)</p>
<p><img src="images/ch_minimum_classclass.jpg" title="A class of classes?" alt="A class of classes?" /></p>
<p>In this kind of situation, in Ruby, we can check in practice.
It&#8217;s because there&#8217;s &#8220;a method which returns the class (class object) to which
an object itself belongs&#8221;, `Object#class`.</p>
<pre class="emlist">
p("string".class())   # String is shown
p(String.class())     # Class is shown
p(Object.class())     # Class is shown
</pre>
<p>Apparently `String` belongs to the class named `Class`.
Then what&#8217;s the class of `Class`?</p>
<pre class="emlist">
p(Class.class())      # Class is shown
</pre>
<p>Again `Class`. In other words, whatever object it is,
by following like `.class().class().class()` &#8230;,
it would reach `Class` in the end,
then it will stall in the loop (Fig.13).</p>
<p><img src="images/ch_minimum_ccc.jpg" title="The class of the class of the class..." alt="The class of the class of the class..." /></p>
<p>`Class` is the class of classes. And what has a recursive structure as &#8220;X of X&#8221;
is called a meta-X.
Hence `Class` is a metaclass.</p>
<h3>Metaobjects</h3>
<p>Let&#8217;s change the target and think about modules.
As modules are also objects, there also should be a class for them.
Let&#8217;s see.</p>
<pre class="emlist">
module M
end
p(M.class())   # Module is shown
</pre>
<p>The class of a module seems to be `Module`. And what should be
the class of the class `Module`?</p>
<pre class="emlist">
p(Module.class())   # Class
</pre>
<p>It&#8217;s again `Class`</p>
<p>Now we change the direction and examine the inheritance relationships.
What&#8217;s the superclass of `Class` and `Module`?
In Ruby, we can find it out with `Class#superclass`.</p>
<pre class="emlist">
p(Class.superclass())    # Module
p(Module.superclass())   # Object
p(Object.superclass())   # nil
</pre>
<p>So `Class` is a subclass of `Module`.
Based on these facts,
Figure 14 shows the relationships between the important classes of Ruby.</p>
<p><img src="images/ch_minimum_metaobjects.jpg" title="The class relationship between the important Ruby classes" alt="The class relationship between the important Ruby classes" /></p>
<p>Up to now we used `new` and `include` without any explanation, but finally I can explain
their true form. `new` is really a method defined for the class `Class`.
Therefore on whatever class, (because it is an instance of `Class`),
`new` can be used immediately.
But `new` isn&#8217;t defined in `Module`. Hence it&#8217;s not
possible to create instances in a module. And since `include` is defined
in the `Module` class, it can be called on both modules and classes.</p>
<p>These three classes `Object`, `Module` and `class` are objects that support the
foundation of Ruby. We can say that these three objects describe the Ruby&#8217;s
object world itself. Namely they are objects which describe objects.
Hence, `Object Module Class` are Ruby&#8217;s &#8220;meta-objects&#8221;.</p>
<h3>Singleton Methods</h3>
<p>I said that methods can be called if it is an object.
I also said that the methods that can be called are determined by the object&#8217;s class.
However I think I also said that ideally methods belong to objects.
Classes are just a means to
eliminate the effort of defining the same method more than once.</p>
<p>Actually In Ruby there&#8217;s also a means to define methods for individual objects (instances)
not depending on the class.
To do this, you can write this way.</p>
<pre class="emlist">
obj = Object.new()
def obj.my_first()
  puts("My first singleton method")
end
obj.my_first()   # Shows My first singleton method
</pre>
<p>As you already know `Object` is the root for every class.
It&#8217;s very unlikely that a method whose name is so weird like `my_first` is
defined in such important
class. And `obj` is an instance of `Object`. However the method `my_first`
can be called on `obj`. Hence we have created without doubt
a method which has nothing to do with the class the object belongs to.
These methods which are defined for each object individually are
called singleton methods.</p>
<p>When are singleton methods used?
First, it is used when defining something like static methods of Java or C++.
In other words methods which can be used
without creating an instance. These methods are expressed in Ruby
as singleton methods of a class object.</p>
<p>For example in <span class="caps">UNIX</span> there&#8217;s a system call `unlink`. This command
deletes a file entry from the filesystem. In Ruby it can be used
directly as the singleton method `unlink` of the `File` class.
Let&#8217;s try it out.</p>
<pre class="emlist">
File.unlink("core")  # deletes the coredump
</pre>
<p>It&#8217;s cumbersome to say &#8220;the singleton method `unlink`
of the object `File`&#8221;. We simply write `File.unlink`. Don&#8217;t mix
it up and write `File#unlink`, or vice versa don&#8217;t write `File.write`
for the method `write` defined in `File`.</p>
<p>▼ A summary of the method notation</p>
<table>
	<tr>
		<th>notation </th>
		<th>the target object </th>
		<th>example </th>
	</tr>
	<tr>
		<td>`File.unlink`</td>
		<td>the `File`class itself</td>
		<td>`File.unlink(&#8220;core&#8221;)`</td>
	</tr>
	<tr>
		<td>`File#write`</td>
		<td>an instance of `File`</td>
		<td>`f.write(&#8220;str&#8221;)`</td>
	</tr>
</table>
<h3>Class Variables</h3>
<p>Class variables were added to Ruby from 1.6 on, they are a relatively new mechanism.
As with constants, they belong to a class,
and they can be referenced and assigned from both the class and its instances.
Let&#8217;s look at an example. The beginning of the name is `@@`.</p>
<pre class="emlist">
class C
  @@cvar = "ok"
  p(@@cvar)      # "ok" is shown

  def print_cvar()
    p(@@cvar)
  end
end

C.new().print_cvar()  # "ok" is shown
</pre>
<p>As the first assignment serves as the definition, a reference
before an assignment like the one shown below leads to a runtime error.
There is an ´@´ in front but the behavior differs completely
from instance variables.</p>
<pre class="screen">
% ruby -e '
class C
  @@cvar
end
'
-e:3: uninitialized class variable @@cvar in C (NameError)
</pre>
<p>Here I was a bit lazy and used the -e option. The program
is the three lines between the single quotes.</p>
<p>Class variables are inherited. Or saying it differently,
a variable in a superior class can be assigned and referenced in the
inferior class.</p>
<pre class="emlist">
class A
  @@cvar = "ok"
end

class B &lt; A
  p(@@cvar)            # Shows "ok"
  def print_cvar()
    p(@@cvar)
  end
end

B.new().print_cvar()   # Shows "ok"
</pre>
<h2>Global Variables</h2>
<p>At last there are also global variables. They can be referenced from
everywhere and assigned everywhere. The first letter of the name is a `$`.</p>
<pre class="emlist">
$gvar = "global variable"
p($gvar)   # Shows "global variable"
</pre>
<p>As with instance variables, all kinds of names can be considered defined
for global variables before assignments.
In other words a reference before an assignment gives a `nil` and
doesn&#8217;t raise an error.</p>
<hr>
<p>Copyright &#169; 2002-2004 Minero Aoki, All rights reserved.</p>
<p>English Translation: Sebastian Krause &lt;skra@pantolog.de&gt;</p>

    <footer>
      The original work is Copyright © 2002 - 2004 Minero AOKI.
      Translated by Vincent ISAMBART and Clifford Escobar CAOILE
      This work is licensed under a
      <p>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/">Creative Commons Attribution-NonCommercial-ShareAlike2.5 License</a>
      </p>
    </footer>

  </div>
</body>
</html>
