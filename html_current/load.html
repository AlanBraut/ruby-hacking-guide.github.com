<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>  Loading |  Ruby Hacking Guide </title>
  <link rel="stylesheet" href="/css/styles.css" />
</head>
<body>

  <div id="main">

    <header>
      <h1><a href="/">Ruby Hacking Guide</a></h1>
    </header>

    <nav role="navigation">
      <ul>
      </ul>
    </nav>

    <p>Translated by Vincent <span class="caps">ISAMBART</span></p>
<h1 id="chapter">Chapter 18: Loading</h1>
<h2>Outline</h2>
<h3>Interface</h3>
<p>At the Ruby level, there are two procedures that can be used for
loading: `require` and `load`.</p>
<pre class="emlist">
require 'uri'            # load the uri library
load '/home/foo/.myrc'   # read a resource file
</pre>
<p>They are both normal methods, compiled and evaluated exactly like any
other code. It means loading occurs after compilation gave control to
the evaluation stage.</p>
<p>These two function each have their own use. &#8216;require&#8217; is to load
libraries, and `load` is to load an arbitrary file. Let&#8217;s see this in
more details.</p>
<h4>`require`</h4>
<p>`require` has four features:</p>
<ul>
	<li>the file is searched for in the load path</li>
	<li>it can load extension libraries</li>
	<li>the `.rb`/`.so` extension can be omitted</li>
	<li>a given file is never loaded more than once</li>
</ul>
<p>Ruby&#8217;s load path is in the global variable `$:`, which contains an
array of strings. For example, displaying the content of the `$:` in
the environment I usually use would show:</p>
<pre class="screen">
% ruby -e 'puts $:'
/usr/lib/ruby/site_ruby/1.7
/usr/lib/ruby/site_ruby/1.7/i686-linux
/usr/lib/ruby/site_ruby
/usr/lib/ruby/1.7
/usr/lib/ruby/1.7/i686-linux
.
</pre>
<p>Calling `puts` on an array displays one element on each line so it&#8217;s easy
to read.</p>
<p>As I ran `configure` using `&#8212;prefix=/usr`, the library path is
`/usr/lib/ruby` and below, but if you compile it normally from the
source code, the libraries will be in `/usr/local/lib/ruby` and below.
In a Windows environment, there will also be a drive letter.</p>
<p>Then, let&#8217;s try to `require` the standard library `nkf.so` from the
load path.</p>
<pre class="emlist">
require 'nkf'
</pre>
<p>If the `require`d name has no extension, `require` silently
compensates. First, it tries with `.rb`, then with `.so`. On some
platforms it also tries the platform&#8217;s specific extension for
extension libraries, for example `.dll` in a Windows environment or
`.bundle` on Mac OS X.</p>
<p>Let&#8217;s do a simulation on my environment. `ruby` checks the following
paths in sequential order.</p>
<pre class="emlist">
/usr/lib/ruby/site_ruby/1.7/nkf.rb
/usr/lib/ruby/site_ruby/1.7/nkf.so
/usr/lib/ruby/site_ruby/1.7/i686-linux/nkf.rb
/usr/lib/ruby/site_ruby/1.7/i686-linux/nkf.so
/usr/lib/ruby/site_ruby/nkf.rb
/usr/lib/ruby/site_ruby/nkf.so
/usr/lib/ruby/1.7/nkf.rb
/usr/lib/ruby/1.7/nkf.so
/usr/lib/ruby/1.7/i686-linux/nkf.rb
/usr/lib/ruby/1.7/i686-linux/nkf.so    found!
</pre>
<p>`nkf.so` has been found in `/usr/lib/ruby/1.7/i686-linux`. Once the
file has been found, `require`&#8217;s last feature (not loading the file
more than once) locks the file. The locks are strings put in the
global variable `$&#8220;`. In our case the string `&#8221;nkf.so&quot;` has been put
there. Even if the extension has been omitted when calling `require`,
the file name in `$&quot;` has the extension.</p>
<pre class="emlist">
require 'nkf'   # after loading nkf...
p $"            # ["nkf.so"]  the file is locked

require 'nkf'   # nothing happens if we require it again
p $"            # ["nkf.so"]  the content of the lock array does not change
</pre>
<p>There are two reasons for adding the missing extension. The first one is
not to load it twice if the same file is later `require`d with its
extension. The second one is to be able to load both `nkf.rb` and
`nkf.so`. In fact the extensions are disparate (`.so .dll .bundle`
etc.) depending on the platform, but at locking time they all become
`.so`. That&#8217;s why when writing a Ruby program you can ignore the
differences of extensions and consider it&#8217;s always `so`. So you can
say that `ruby` is quite <span class="caps">UNIX</span> oriented.</p>
<p>By the way, `$&#8220;` can be freely modified even at the Ruby level so we
cannot say it&#8217;s a strong lock. You can for example load an extension
library multiple times if you clear `$&#8221;`.</p>
<h4>`load`</h4>
<p>`load` is a lot easier than `require`. Like `require`, it searches the
file in `$:`. But it can only load Ruby programs. Furthermore, the
extension cannot be omitted: the complete file name must always be
given.</p>
<pre class="emlist">
load 'uri.rb'   # load the URI library that is part of the standard library
</pre>
<p>In this simple example we try to load a library, but the proper way to
use `load` is for example to load a resource file giving its full
path.</p>
<h3>Flow of the whole process</h3>
<p>If we roughly split it, &#8220;loading a file&#8221; can be split in:</p>
<ul>
	<li>finding the file</li>
	<li>reading the file and mapping it to an internal form</li>
	<li>evaluating it</li>
</ul>
<p>The only difference between `require` and `load` is how to find the
file. The rest is the same in both.</p>
<p>We will develop the last evaluation part a little more. Loaded Ruby
programs are basically evaluated at the top-level. It means the
defined constants will be top-level constants and the defined methods
will be function-style methods.</p>
<pre class="emlist">
### mylib.rb
MY_OBJECT = Object.new
def my_p(obj)
  p obj
end

### first.rb
require 'mylib'
my_p MY_OBJECT   # we can use the constants and methods defined in an other file
</pre>
<p>Only the local variable scope of the top-level changes when the file
changes. In other words, local variables cannot be shared between
different files. You can of course share them using for example `Proc`
but this has nothing to do with the load mechanism.</p>
<p>Some people also misunderstand the loading mechanism. Whatever the
class you are in when you call `load`, it does not change
anything. Even if, like in the following example, you load a file in
the `module` statement, it does not serve any purpose, as everything
that is at the top-level of the loaded file is put at the Ruby
top-level.</p>
<pre class="emlist">
require 'mylib'     # whatever the place you require from, be it at the top-level
module SandBox
  require 'mylib'   # or in a module, the result is the same
end
</pre>
<h3>Highlights of this chapter</h3>
<p>With the above knowledge in our mind, we are going to read.
But because this time its specification is defined very particularly,
if we simply read it, it could be just an enumeration of the codes.
Therefore, in this chapter,
we are going to reduce the target to the following 3 points:</p>
<ul>
	<li>loading serialisation</li>
	<li>the repartition of the functions in the different source files</li>
	<li>how extension libraries are loaded</li>
</ul>
<p>Regarding the first point, you will understand it when you see it.</p>
<p>For the second point, the functions that appear in this chapter come
from 4 different files, `eval.c ruby.c file.c dln.c`.
Why is this in this way?
We&#8217;ll try to think about the realistic situation behind it.</p>
<p>The third point is just like its name says. We will see how the
currently popular trend of execution time loading, more commonly
referred to as plug-ins, works. This is the most interesting part of this
chapter, so I&#8217;d like to use as many pages as possible to talk about it.</p>
<h2>Searching the library</h2>
<h3>`rb_f_require()`</h3>
<p>The body of `require` is `rb_f_require`. First, we will only look at
the part concerning the file search. Having many different cases is
bothersome so we will limit ourselves to the case when no file
extension is given.</p>
<p>▼ `rb_f_require()` (simplified version)
<pre class="longlist">
5527  <span class="caps">VALUE</span>
5528  rb_f_require(obj, fname)
5529      <span class="caps">VALUE</span> obj, fname;
5530  {
5531      <span class="caps">VALUE</span> feature, tmp;
5532      char <strong>ext, *ftptr; /</strong> OK <strong>/
5533      int state;
5534      volatile int safe = ruby_safe_level;
5535
5536      SafeStringValue(fname);
5537      ext = strrchr(<acronym title="fname"><span class="caps">RSTRING</span></acronym>&#8594;ptr, &#8216;.&#8217;);
5538      if (ext) {
              /</strong> &#8230;if the file extension has been given&#8230; <strong>/
5584      }
5585      tmp = fname;
5586      switch (rb_find_file_ext(&amp;tmp, loadable_ext)) {
5587        case 0:
5588          break;
5589
5590        case 1:
5591          feature = fname = tmp;
5592          goto load_rb;
5593
5594        default:
5595          feature = tmp;
5596          fname = rb_find_file(tmp);
5597          goto load_dyna;
5598      }
5599      if (rb_feature_p(<acronym title="fname"><span class="caps">RSTRING</span></acronym>&#8594;ptr, Qfalse))
5600          return Qfalse;
5601      rb_raise(rb_eLoadError, &#8220;No such file to load &#8212; %s&#8221;,
                   <acronym title="fname"><span class="caps">RSTRING</span></acronym>&#8594;ptr);
5602
5603    load_dyna:
          /</strong> &#8230;load an extension library&#8230; <strong>/
5623      return Qtrue;
5624
5625    load_rb:
          /</strong> &#8230;load a Ruby program&#8230; */
5648      return Qtrue;
5649  }</p>
<p>5491  static const char <strong>const loadable_ext[] = {
5492      &#8220;.rb&#8221;, <span class="caps">DLEXT</span>,    /</strong> <span class="caps">DLEXT</span>=&#8220;.so&#8221;, &#8220;.dll&#8221;, &#8220;.bundle&#8221;&#8230; <strong>/
5493  #ifdef DLEXT2
5494      DLEXT2,          /</strong> DLEXT2=&#8220;.dll&#8221; on Cygwin, MinGW */
5495  #endif
5496      0
5497  };</p>
<p>(eval.c)
</pre></p>
<p>In this function the `goto` labels `load_rb` and `load_dyna` are
actually like subroutines, and the two variables `feature` and `fname`
are more or less their parameters. These variables have the following
meaning.</p>
<table>
	<tr>
		<th>variable</th>
		<th>meaning</th>
		<th>example</th>
	</tr>
	<tr>
		<td>`feature`</td>
		<td>the library file name that will be put in `$&quot;`</td>
		<td>`uri.rb`、`nkf.so`</td>
	</tr>
	<tr>
		<td>`fname`</td>
		<td>the full path to the library</td>
		<td>`/usr/lib/ruby/1.7/uri.rb`</td>
	</tr>
</table>
<p>The name `feature` can be found in the function `rb_feature_p()`. This
function checks if a file has been locked (we will look at it just
after).</p>
<p>The functions actually searching for the library are `rb_find_file()`
and `rb_find_file_ext()`. `rb_find_file()` searches a file in the load
path `$&#8217;`. `rb_find_file_ext()` does the same but the difference is
that it takes as a second parameter a list of extensions
(i.e. `loadable_ext`) and tries them in sequential order.</p>
<p>Below we will first look entirely at the file searching code, then we
will look at the code of the `require` lock in `load_rb`.</p>
<h3>`rb_find_file()`</h3>
<p>First the file search continues in `rb_find_file()`. This function
searches the file `path` in the global load path `$&#8216;`
(`rb_load_path`). The string contamination check is tiresome so we&#8217;ll
only look at the main part.</p>
<p>▼ `rb_find_file()` (simplified version)
<pre class="longlist">
2494  <span class="caps">VALUE</span>
2495  rb_find_file(path)
2496      <span class="caps">VALUE</span> path;
2497  {
2498      <span class="caps">VALUE</span> tmp;
2499      char *f = <acronym title="path"><span class="caps">RSTRING</span></acronym>&#8594;ptr;
2500      char *lpath;</p>
<p>2530      if (rb_load_path) {
2531          long i;
2532
2533          Check_Type(rb_load_path, T_ARRAY);
2534          tmp = rb_ary_new();
2535          for (i=0;i&lt;<acronym title="rb_load_path"><span class="caps">RARRAY</span></acronym>&#8594;len;i++) {
2536              <span class="caps">VALUE</span> str = <acronym title="rb_load_path"><span class="caps">RARRAY</span></acronym>&#8594;ptr[i];
2537              SafeStringValue(str);
2538              if (<acronym title="str"><span class="caps">RSTRING</span></acronym>&#8594;len &gt; 0) {
2539                  rb_ary_push(tmp, str);
2540              }
2541          }
2542          tmp = rb_ary_join(tmp, rb_str_new2(PATH_SEP));
2543          if (<acronym title="tmp"><span class="caps">RSTRING</span></acronym>&#8594;len == 0) {
2544              lpath = 0;
2545          }
2546          else {
2547              lpath = <acronym title="tmp"><span class="caps">RSTRING</span></acronym>&#8594;ptr;
2551          }
2552      }</p>
<p>2560      f = dln_find_file(f, lpath);
2561      if (file_load_ok(f)) {
2562          return rb_str_new2(f);
2563      }
2564      return 0;
2565  }</p>
<p>(file.c)
</pre></p>
<p>If we write what happens in Ruby we get the following:</p>
<pre class="emlist">
tmp = []                     # make an array
$:.each do |path|            # repeat on each element of the load path
  tmp.push path if path.length &gt; 0 # check the path and push it
end
lpath = tmp.join(PATH_SEP)   # concatenate all elements in one string separated by PATH_SEP

dln_find_file(f, lpath)      # main processing
</pre>
<p>`PATH_SEP` is the `path separator`: `&#8216;:&#8217;` under <span class="caps">UNIX</span>, `&#8216;;&#8217;` under
Windows. `rb_ary_join()` creates a string by putting it between the
different elements. In other words, the load path that had become an
array is back to a string with a separator.</p>
<p>Why? It&#8217;s only because `dln_find_file()` takes the paths as a string
with `PATH_SEP` as a separator. But why is `dln_find_file()`
implemented like that? It&#8217;s just because `dln.c` is not a library for
`ruby`. Even if it has been written by the same author, it&#8217;s a general
purpose library. That&#8217;s precisely for this reason that when I sorted
the files by category in the Introduction I put this file in the
Utility category. General purpose libraries cannot receive Ruby
objects as parameters or read `ruby` global variables.</p>
<p>`dln_find_file()` also expands for example `~` to the home directory,
but in fact this is already done in the omitted part of
`rb_find_file()`. So in `ruby`&#8216;s case it&#8217;s not necessary.</p>
<h3>Loading wait</h3>
<p>Here, file search is finished quickly. Then comes is the loading
code. Or more accurately, it is &#8220;up to just before the load&#8221;. The code
of `rb_f_require()`&#8217;s `load_rb` has been put below.</p>
<p>▼ `rb_f_require():load_rb`
<pre class="longlist">
5625    load_rb:
5626      if (rb_feature_p(<acronym title="feature"><span class="caps">RSTRING</span></acronym>&#8594;ptr, Qtrue))
5627          return Qfalse;
5628      ruby_safe_level = 0;
5629      rb_provide_feature(feature);
5630      /* the loading of Ruby programs is serialised <strong>/
5631      if (!loading_tbl) {
5632          loading_tbl = st_init_strtable();
5633      }
5634      /</strong> partial state <strong>/
5635      ftptr = ruby_strdup(<acronym title="feature"><span class="caps">RSTRING</span></acronym>&#8594;ptr);
5636      st_insert(loading_tbl, ftptr, curr_thread);
          /</strong> &#8230;load the Ruby program and evaluate it&#8230; <strong>/
5643      st_delete(loading_tbl, &amp;ftptr, 0); /</strong> loading done */
5644      free(ftptr);
5645      ruby_safe_level = safe;</p>
<p>(eval.c)
</pre></p>
<p>Like mentioned above, `rb_feature_p()` checks if a lock has been put
in `$&#8220;`. And `rb_provide_feature()` pushes a string in `$&#8221;`, in other
words locks the file.</p>
<p>The problem comes after. Like the comment says &#8220;the loading of Ruby
programs is serialised&#8221;. In other words, a file can only be loaded
from one thread, and if during the loading another thread tries to load the
same file, that thread will wait for the first loading to be finished.
If it were not the case:</p>
<pre class="emlist">
Thread.fork {
    require 'foo'   # At the beginning of require, foo.rb is added to $"
}                   # However the thread changes during the evaluation of foo.rb
require 'foo'   # foo.rb is already in $" so the function returns immediately
# (A) the classes of foo are used...
</pre>
<p>By doing something like this, even though the `foo` library is not
really loaded, the code at (A) ends up being executed.</p>
<p>The process to enter the waiting state is simple. A `st_table` is
created in `loading_tbl`, the association &#8220;`feature=&gt;`waiting thread&#8221;
is recorded in it. `curr_thread` is in `eval.c`&#8217;s functions, its value
is the current running thread.</p>
<p>The mechanism to enter the waiting state is very simple. A `st_table`
is created in the `loading_tbl` global variable, and a
&#8220;`feature`=&gt;`loading thread`&#8221; association is created. `curr_thread` is
a variable from `eval.c`, and its value is the currently running
thread.  That makes an exclusive lock. And in `rb_feature_p()`, we
wait for the loading thread to end like the following.</p>
<p>▼ `rb_feature_p()` (second half)
<pre class="longlist">
5477  rb_thread_t th;
5478
5479  while (st_lookup(loading_tbl, f, &amp;th)) {
5480      if (th == curr_thread) {
5481          return Qtrue;
5482      }
5483      CHECK_INTS;
5484      rb_thread_schedule();
5485  }</p>
<p>(eval.c)
</pre></p>
<p>When `rb_thread_schedule()` is called, the control is transferred to
an other thread, and this function only returns after the control
returned back to the thread where it was called. When the file name
disappears from `loading_tbl`, the loading is finished so the function
can end. The `curr_thread` check is not to lock itself (figure 1).</p>
<div class="image">
<p><img src="images/ch_load_loadwait.jpg" alt="(loadwait)"><br>
Figure 1: Serialisation of loads</p>
</div>
<h2>Loading of Ruby programs</h2>
<h3>`rb_load()`</h3>
<p>We will now look at the loading process itself. Let&#8217;s start by the
part inside `rb_f_require()`&#8217;s `load_rb` loading Ruby programs.</p>
<p>▼ `rb_f_require()-load_rb-` loading
<pre class="longlist">
5638      PUSH_TAG(PROT_NONE);
5639      if ((state = EXEC_TAG()) == 0) {
5640          rb_load(fname, 0);
5641      }
5642      POP_TAG();</p>
<p>(eval.c)
</pre></p>
<p>The `rb_load()` which is called here is actually the &#8220;meat&#8221; of the
Ruby-level `load`.
This means it needs to search once again,
but looking at the same procedure once again is too much trouble.
Therefore, that part is omitted in the below codes.</p>
<p>And the second argument `wrap` is folded with 0
because it is 0 in the above calling code.</p>
<p>▼ `rb_load()` (simplified edition)
<pre class="longlist">
void
rb_load(fname, /* wrap=0 */)
    <span class="caps">VALUE</span> fname;
{
    int state;
    volatile ID last_func;
    volatile <span class="caps">VALUE</span> wrapper = 0;
    volatile <span class="caps">VALUE</span> self = ruby_top_self;
    <span class="caps">NODE</span> *saved_cref = ruby_cref;</p>
PUSH_VARS();
PUSH_CLASS();
ruby_class = rb_cObject;
ruby_cref = top_cref;           /* (A-1) change <span class="caps">CREF</span> */
wrapper = ruby_wrapper;
ruby_wrapper = 0;
PUSH_FRAME();
ruby_frame&#8594;last_func = 0;
ruby_frame&#8594;last_class = 0;
ruby_frame&#8594;self = self;        /* (A-2) change ruby_frame&#8594;cbase */
ruby_frame&#8594;cbase = (<span class="caps">VALUE</span>)rb_node_newnode(NODE_CREF,ruby_class,0,0);
PUSH_SCOPE();
/* at the top-level the visibility is private by default */
SCOPE_SET(SCOPE_PRIVATE);
PUSH_TAG(PROT_NONE);
ruby_errinfo = Qnil;  /* make sure it&#8217;s nil */
state = EXEC_TAG();
last_func = ruby_frame&#8594;last_func;
if (state == 0) {
<span class="caps">NODE</span> *node;
/* (B) this is dealt with as eval for some reasons */
ruby_in_eval++;
rb_load_file(<acronym title="fname"><span class="caps">RSTRING</span></acronym>&#8594;ptr);
ruby_in_eval&#8212;;
node = ruby_eval_tree;
if (ruby_nerrs == 0) {   /* no parse error occurred */
eval_node(self, node);
}
}
ruby_frame&#8594;last_func = last_func;
POP_TAG();
ruby_cref = saved_cref;
POP_SCOPE();
POP_FRAME();
POP_CLASS();
POP_VARS();
ruby_wrapper = wrapper;
if (ruby_nerrs &gt; 0) {   /* a parse error occurred */
ruby_nerrs = 0;
rb_exc_raise(ruby_errinfo);
}
if (state) jump_tag_but_local_jump(state);
if (!NIL_P(ruby_errinfo))   /* an exception was raised during the loading */
rb_exc_raise(ruby_errinfo);
<p>}
</pre></p>
<p>Just after we thought we&#8217;ve been through the storm of stack manipulations
we entered again. Although this is tough,
let&#8217;s cheer up and read it.</p>
<p>As the long functions usually are,
almost all of the code are occupied by the idioms.
`<span class="caps">PUSH</span>`/`<span class="caps">POP</span>`, tag protecting and re-jumping.
Among them, what we want to focus on is the things on (A) which relate to `<span class="caps">CREF</span>`.
Since a loaded program is always executed on the top-level,
it sets aside (not push) `ruby_cref` and brings back `top_cref`.
`ruby_frame&#8594;cbase` also becomes a new one.</p>
<p>And one more place, at (B) somehow `ruby_in_eval` is turned on.
What is the part influenced by this variable?
I investigated it and it turned out that it seems only `rb_compile_error()`.
When `ruby_in_eval` is true, the message is stored in the exception object,
but when it is not true, the message is printed to `stderr`.
In other words, when it is a parse error of the main program of the command,
it wants to print directly to `stderr`, but when inside of the evaluator,
it is not appropriate so it stops to do it.
It seems the &#8220;eval&#8221; of `ruby_in_eval` means neither the `eval` method nor the
`eval()` function but &#8220;evaluate&#8221; as a general noun.
Or, it&#8217;s possible it indicates `eval.c`.</p>
<h3>`rb_load_file()`</h3>
<p>Then, all of a sudden, the source file is `ruby.c` here.
Or to put it more accurately,
essentially it is favorable if the entire loading code was put in `ruby.c`,
but `rb_load()` has no choice but to use `PUSH_TAG` and such.
Therefore, putting it in `eval.c` is inevitable.
If it were not the case,
all of them would be put in `eval.c` in the first place.</p>
<p>Then, it is `rb_load_file()`.</p>
<p>▼ `rb_load_file()`
<pre class="longlist">
 865  void
 866  rb_load_file(fname)
 867      char *fname;
 868  {
 869      load_file(fname, 0);
 870  }</p>
<p>(ruby.c)
</pre></p>
<p>Delegated entirely. The second argument `script` of `load_file()` is a boolean
value and it indicates whether it is loading the file of the argument of the
`ruby` command. Now, because we&#8217;d like to assume we are loading a library,
let&#8217;s fold it by replacing it with `script=0`.
Furthermore, in the below code, also thinking about the meanings,
non essential things have already been removed.</p>
<p class="caption">▼ `load_file()` (simplified edition)</p>
<pre class="longlist">
static void
load_file(fname, /* script=0 */)
    char *fname;
{
    VALUE f;
    {
        FILE *fp = fopen(fname, "r");   (A)
        if (fp == NULL) {
            rb_load_fail(fname);
        }
        fclose(fp);
    }
    f = rb_file_open(fname, "r");       (B)
    rb_compile_file(fname, f, 1);       (C)
    rb_io_close(f);
}
</pre>
<p>(A) The call to `fopen()` is to check if the
file can be opened. If there is no problem, it&#8217;s immediately closed.
It may seem a little useless but it&#8217;s an extremely simple and yet
highly portable and reliable way to do it.</p>
<p>(B) The file is opened once again, this time using the Ruby level
library `File.open`. The file was not opened with `File.open` from the
beginning so as not to raise any Ruby exception.
Here if any exception occurred we would like to have a
loading error, but getting the errors related to `open`, for example
`Errno::<span class="caps">ENOENT</span>`, `Errno::<span class="caps">EACCESS</span>`&#8230;, would be problematic. We are in
`ruby.c` so we cannot stop a tag jump.</p>
<p>(C) Using the parser interface `rb_compile_file()`, the program is
read from an `IO` object, and compiled in a syntax tree. The syntax
tree is added to `ruby_eval_tree` so there is no need to get the
result.</p>
<p>That&#8217;s all for the loading code. Finally, the calls were quite deep so
the callgraph of `rb_f_require()` is shown bellow.</p>
<pre class="emlist">
rb_f_require           ....eval.c
    rb_find_file            ....file.c
        dln_find_file           ....dln.c
            dln_find_file_1
    rb_load
        rb_load_file            ....ruby.c
            load_file
                rb_compile_file     ....parse.y
        eval_node
</pre>
<p>You must bring callgraphs on a long trip. It&#8217;s common knowledge.</p>
<h4>The number of `open` required for loading</h4>
<p>Previously, there was `open` used just to check if a file can be open,
but in fact, during the loading process of `ruby`, additionally other functions
such as `rb_find_file_ext()` also internally do checks by using `open`. How
many times is `open()` called in the whole process?</p>
<p>If you&#8217;re wondering that, just actually counting it is the right attitude as a
programmer. We can easily count it by using a system call tracer.
The tool to use would be `strace` on Linux, `truss` on Solaris, `ktrace` or
`truss` on <span class="caps">BSD</span>. Like this, for each OS, the name is different
and there&#8217;s no consistency, but you can find them by googling.</p>
<p>If you&#8217;re using Windows, probably your <span class="caps">IDE</span> will have a tracer built in. Well, as my main environment is Linux, I looked using `strace`.</p>
<p>The output is done on `stderr` so it was redirected using `2&gt;&amp;1`.</p>
<pre class="screen">
% strace ruby -e 'require "rational"' 2&gt;&amp;1 | grep '^open'
open("/etc/ld.so.preload", O_RDONLY)    = -1 ENOENT
open("/etc/ld.so.cache", O_RDONLY)      = 3
open("/usr/lib/libruby-1.7.so.1.7", O_RDONLY) = 3
open("/lib/libdl.so.2", O_RDONLY)       = 3
open("/lib/libcrypt.so.1", O_RDONLY)    = 3
open("/lib/libc.so.6", O_RDONLY)        = 3
open("/usr/lib/ruby/1.7/rational.rb", O_RDONLY|O_LARGEFILE) = 3
open("/usr/lib/ruby/1.7/rational.rb", O_RDONLY|O_LARGEFILE) = 3
open("/usr/lib/ruby/1.7/rational.rb", O_RDONLY|O_LARGEFILE) = 3
open("/usr/lib/ruby/1.7/rational.rb", O_RDONLY|O_LARGEFILE) = 3
</pre>
<p>Until the `open` of `libc.so.6`, it is the `open` used in the implementation of
dynamic links, and there are the other four `open`s.
Thus it seems the three of them are useless.</p>
<h2>Loading of extension libraries</h2>
<h3>`rb_f_require()`-`load_dyna`</h3>
<p>This time we will see the loading of extension libraries. We will
start with `rb_f_require()`&#8217;s `load_dyna`. However, we do not need the
part about locking anymore so it was removed.</p>
<p>▼ `rb_f_require()`-`load_dyna`
<pre class="longlist">
5607  {
5608      int volatile old_vmode = scope_vmode;
5609
5610      PUSH_TAG(PROT_NONE);
5611      if ((state = EXEC_TAG()) == 0) {
5612          void *handle;
5613
5614          SCOPE_SET(SCOPE_PUBLIC);
5615          handle = dln_load(<acronym title="fname"><span class="caps">RSTRING</span></acronym>&#8594;ptr);
5616          rb_ary_push(ruby_dln_librefs, <acronym title="(long"><span class="caps">LONG2NUM</span></acronym>handle));
5617      }
5618      POP_TAG();
5619      SCOPE_SET(old_vmode);
5620  }
5621  if (state) JUMP_TAG(state);</p>
<p>(eval.c)
</pre></p>
<p>By now, there is very little here which is novel.
The tags are used only in the way of the idiom,
and to save/restore the visibility scope is done in the way we get used to see.
All that remains is `dln_load()`. What on earth is that for? For the answer, continue to the next section.</p>
<h3>Brush up about links</h3>
<p>`dln_load()` is loading an extension library,
but what does loading an extension library mean?
To talk about it, we need to dramatically roll back the talk to the physical world,
and start with about links.</p>
<p>I think compiling C programs is, of course, not a new thing for you.
Since I&#8217;m using `gcc` on Linux, I can create a runnable program in the following
manner.</p>
<pre class="screen">
% gcc hello.c
</pre>
<p>According to the file name, this is probably an &#8220;Hello, World!&#8221; program.
In <span class="caps">UNIX</span>, `gcc` outputs a program into a file named `a.out` by default,
so you can subsequently execute it in the following way:</p>
<pre class="screen">
% ./a.out
Hello, World!
</pre>
<p>It is created properly.</p>
<p>By the way, what is `gcc` actually doing here?
Usually we just say &#8220;compile&#8221; or &#8220;compile&#8221;, but actually</p>
<ol>
	<li>preprocess (`cpp`)</li>
	<li>compile C into assembly (`cc`)</li>
	<li>assemble the assembly language into machine code (`as`)</li>
	<li>link (`ld`)</li>
</ol>
<p>there are these four steps. Among them, preprocessing and compiling and
assembling are described in a lot of places, but the description often ends
without clearly describing about the linking phase.
It is like a history class in school which would never reach &#8220;modern age&#8221;.
Therefore, in this book, trying to provide the extinguished part,
I&#8217;ll briefly summarize what is linking.</p>
<p>A program finished the assembling phase becomes an &#8220;object file&#8221; in
somewhat format. The following formats are some of such formats which are major.</p>
<ul>
	<li><span class="caps">ELF</span>, Executable and Linking Format (recent <span class="caps">UNIX</span>)</li>
	<li>`a.out`, assembler output (relatively old <span class="caps">UNIX</span>)</li>
	<li><span class="caps">COFF</span>, Common Object File Format (Win32)</li>
</ul>
<p>It might go without saying that the `a.out` as an object file format and
the `a.out` as a default output file name of `cc` are totally different things.
For example, on modern Linux, when we create it ordinarily, the `a.out` file
in <span class="caps">ELF</span> format is created.</p>
<p>And, how these object file formats differ each other is not important now.
What we have to recognize now is, all of these object files
can be considered as &#8220;a set of names&#8221;.
For example, the function names and the variable names which exist in this file.</p>
<p>And, sets of names contained in the object file have two types.</p>
<ul>
	<li>set of necessary names
(for instance, the external functions called internally. e.g. `printf`)</li>
</ul>
<ul>
	<li>set of providing names
(for instance, the functions defined internally. e.g. `hello`)</li>
</ul>
<p>And linking is, when gathering multiple object files,
checking if &#8220;the set of providing names&#8221; contains &#8220;the set of necessary names&#8221;
entirely, and connecting them each other.
In other words, pulling the lines from all of &#8220;the necessary names&#8221;,
each line must be connected to one of &#8220;the providing names&#8221; of a particular
object file. (Figure. 2)
To put this in technical terms,
it is resolving undefined symbols.</p>
<div class="image">
<p><img src="images/ch_load_link.jpg" alt="(link)"><br>
Figure 2: object files and linking</p>
</div>
<p>Logically this is how it is, but in reality a program can&#8217;t run only because of
this. At least, C programs cannot run without converting the names to the
addresses (numbers).</p>
<p>So, after the logical conjunctions, the physical conjunctions become necessary.
We have to map object files into the real memory space
and substitute the all names with numbers.
Concretely speaking, for instance, the addresses to jump to on function calls
are adjusted here.</p>
<p>And, based on the timing when to do these two conjunctions,
linking is divided into two types:
static linking and dynamic linking.
Static linking finishes the all phases during the compile time.
On the other hand, dynamic linking defers some of the conjunctions to the
executing time. And linking is finally completed when executing.</p>
<p>However, what explained here is a very simple idealistic model,
and it has an aspect distorting the reality a lot.
Logical conjunctions and physical conjunctions are not so completely separated,
and &#8220;an object file is a set of names&#8221; is too naive.
But the behavior around this considerably differs depending on each platform,
describing seriously would end up with one more book.
To obtain the realistic level knowledge, additionally,
&#8220;Expert C Programming: Deep C Secrets&#8221; by Peter van der Linden,
&#8220;Linkers and Loaders&#8221; by John R.Levine
I recommend to read these books.</p>
<h3>Linking that is truly dynamic</h3>
<p>And finally we get into our main topic. The &#8220;dynamic&#8221; in &#8220;dynamic linking&#8221; naturally means it &#8220;occurs at execution time&#8221;, but what people usually refer to as &#8220;dynamic linking&#8221; is pretty much decided already at compile time. For example, the names of the needed functions, and which library they can be found in, are already known. For instance, if you need `cos()`, you know it&#8217;s in `libm`, so you use `gcc -lm`. If you didn&#8217;t specify the correct library at compile time, you&#8217;d get a link error.</p>
<p>But extension libraries are different. Neither the names of the needed functions, or the name of the library which defines them are known at compile time.
We need to construct a string at execution time and load and link.
It means that even &#8220;the logical conjunctions&#8221; in the sense of the previous words
should be done entirely at execution time.
In order to do it, another mechanism that is a little different form the ordinal
dynamic linkings is required.</p>
<p>This manipulation, linking that is entirely decided at runtime,
is usually called &#8220;dynamic load&#8221;.</p>
<h3>Dynamic load <span class="caps">API</span></h3>
<p>I&#8217;ve finished to explain the concept. The rest is how to do that dynamic loading.
This is not a difficult thing. Usually there&#8217;s a specific <span class="caps">API</span> prepared in the
system, we can accomplish it by merely calling it.</p>
<p>For example, what is relatively broad for <span class="caps">UNIX</span> is the <span class="caps">API</span> named `dlopen`.
However, I can&#8217;t say &#8220;It is always available on <span class="caps">UNIX</span>&#8221;.
For example, for a little previous HP-UX has a totally different interface,
and a NeXT-flavor <span class="caps">API</span> is used on Mac OS X.
And even if it is the same `dlopen`,
it is included in `libc` on <span class="caps">BSD</span>-derived OS,
and it is attached from outside as `libdl` on Linux.
Therefore, it is desperately not portable.
It differs even among <span class="caps">UNIX</span>-based platforms,
it is obvious to be completely different in the other Operating Systems.
It is unlikely that the same <span class="caps">API</span> is used.</p>
<p>Then, how `ruby` is doing is, in order to absorb the totally different
interfaces, the file named `dln.c` is prepared.
`dln` is probably the abbreviation of &#8220;dynamic link&#8221;.
`dln_load()` is one of functions of `dln.c`.</p>
<p>Where dynamic loading APIs are totally different each other,
the only saving is the usage pattern of <span class="caps">API</span> is completely the same.
Whichever platform you are on,</p>
<ol>
	<li>map the library to the address space of the process</li>
	<li>take the pointers to the functions contained in the library</li>
	<li>unmap the library</li>
</ol>
<p>it consists of these three steps.
For example, if it is `dlopen`-based <span class="caps">API</span>,</p>
<ol>
	<li>`dlopen`</li>
	<li>`dlsym`</li>
	<li>`dlclose`</li>
</ol>
<p>are the correspondences. If it is Win32 <span class="caps">API</span>,</p>
<ol>
	<li>`LoadLibrary` (or `LoadLibraryEx`)</li>
	<li>`GetProcAddress`</li>
	<li>`FreeLibrary`</li>
</ol>
<p>are the correspondences.</p>
<p>At last, I&#8217;ll talk about what `dln_load()` is doing by using these APIs.
It is, in fact, calling `Init_xxxx()`.
By reaching here, we finally become to be able to illustrate the entire process
of `ruby` from the invocation to the completion without any lacks.
In other words, when `ruby` is invoked, it initializes the evaluator and starts
evaluating a program passed in somewhat way.
If `require` or `load` occurs during the process,
it loads the library and transfers the control.
Transferring the control means parsing and evaluating if it is a Ruby library
and it means loading and linking and finally calling `Init_xxxx()`
if it is an extension library.</p>
<h3>`dln_load()`</h3>
<p>Finally, we&#8217;ve reached the content of `dln_load()`.
`dln_load()` is also a long function,
but its structure is simple because of some reasons.
Take a look at the outline first.</p>
<p>▼ `dln_load()` (outline)
<pre class="longlist">
void*
dln_load(file)
    const char <strong>file;
{
#if defined _WIN32 &amp;&amp; !defined <i><span class="caps">CYGWIN</span></i>
    load with Win32 <span class="caps">API</span>
#else
    initialization depending on each platform
#ifdef each platform
    ……routines for each platform……
#endif
#endif
#if !defined(<em><span class="caps">AIX</span>) &amp;&amp; !defined(NeXT)
  failed:
    rb</em>loaderror(&#8220;%s &#8211; %s&#8221;, error, file);
#endif
    return 0;                   /</strong> dummy return */
}
</pre></p>
<p>This way, the part connecting to the main is completely separated based on each
platform. When thinking, we only have to think about one platform at a time.
Supported APIs are as follows:</p>
<ul>
	<li>`dlopen` (Most of <span class="caps">UNIX</span>)</li>
	<li>`LoadLibrary` (Win32)</li>
	<li>`shl_load` (a bit old HP-UX)</li>
	<li>`a.out` (very old <span class="caps">UNIX</span>)</li>
	<li>`rld_load` (before `NeXT4`)</li>
	<li>`dyld` (`NeXT` or Mac OS X)</li>
	<li>`get_image_symbol` (BeOS)</li>
	<li>`GetDiskFragment` (Mac Os 9 and before)</li>
	<li>`load` (a bit old <span class="caps">AIX</span>)</li>
</ul>
<h3>`dln_load()`-`dlopen()`</h3>
<p>First, let&#8217;s start with the <span class="caps">API</span> code for the `dlopen` series.</p>
<p>▼ `dln_load()`-`dlopen()`
<pre class="longlist">
1254  void*
1255  dln_load(file)
1256      const char <strong>file;
1257  {
1259      const char *error = 0;
1260  #define DLN_ERROR() (error = dln_strerror(),\
                           strcpy(ALLOCA_N(char, strlen(error) + 1), error))
1298      char *buf;
1299      /</strong> write a string &#8220;Init_xxxx&#8221; to buf (the space is allocated with alloca) */
1300      init_funcname(&amp;buf, file);</p>
<p>1304      {
1305          void <strong>handle;
1306          void (</strong>init_fct)();
1307
1308  #ifndef RTLD_LAZY
1309  # define RTLD_LAZY 1
1310  #endif
1311  #ifndef RTLD_GLOBAL
1312  # define RTLD_GLOBAL 0
1313  #endif
1314
1315          /* (A) load the library <strong>/
1316          if ((handle = (void</strong>)dlopen(file, RTLD_LAZY | RTLD_GLOBAL))
                                                                 == <span class="caps">NULL</span>) {
1317              error = dln_strerror();
1318              goto failed;
1319          }
1320
              /* (B) get the pointer to Init_xxxx() <strong>/
1321          init_fct = (void(</strong>)())dlsym(handle, buf);
1322          if (init_fct == <span class="caps">NULL</span>) {
1323              error = DLN_ERROR();
1324              dlclose(handle);
1325              goto failed;
1326          }
1327          /* &#169; call Init_xxxx() <strong>/
1328          (</strong>init_fct)();
1329
1330          return handle;
1331      }</p>
<p>1576    failed:
1577      rb_loaderror(&#8220;%s &#8211; %s&#8221;, error, file);
1580  }</p>
<p>(dln.c)
</pre></p>
<p>(A) the `RTLD_LAZY` as the argument of `dlopen()` indicates &#8220;resolving the
undefined symbols when the functions are actually demanded&#8221;
The return value is the mark (handle) to distinguish the library and
we always need to pass it when using `dl*()`.</p>
<p>(B) `dlsym()` gets the function pointer from the library specified by the
handle. If the return value is `<span class="caps">NULL</span>`, it means failure.
Here, getting the pointer to `Init_xxxx()`
If the return value is `<span class="caps">NULL</span>`, it means failure. Here, the pointer to
`Init_xxxx()` is obtained and called.</p>
<p>`dlclose()` is not called here. Since the pointers to the
functions of the loaded library are possibly returned inside `Init_xxx()`,
it is troublesome if `dlclose()` is done
because the entire library would be disabled to use.
Thus, we can&#8217;t call `dlclose()` until the process will be finished.</p>
<h3>`dln_load()` &#8212; Win32</h3>
<p>As for Win32, `LoadLibrary()` and `GetProcAddress()` are used.
It is very general Win32 <span class="caps">API</span> which also appears on <span class="caps">MSDN</span>.</p>
<p>▼ `dln_load()`-Win32
<pre class="longlist">
1254  void*
1255  dln_load(file)
1256      const char *file;
1257  {</p>
<p>1264      <span class="caps">HINSTANCE</span> handle;
1265      char winfile[<span class="caps">MAXPATHLEN</span>];
1266      void (<strong>init_fct)();
1267      char *buf;
1268
1269      if (strlen(file) &gt;= <span class="caps">MAXPATHLEN</span>) rb_loaderror(&#8220;filename too long&#8221;);
1270
1271      /</strong> write the &#8220;Init_xxxx&#8221; string to buf (the space is allocated with alloca) <strong>/
1272      init_funcname(&amp;buf, file);
1273
1274      strcpy(winfile, file);
1275
1276      /</strong> load the library <strong>/
1277      if ((handle = LoadLibrary(winfile)) == <span class="caps">NULL</span>) {
1278          error = dln_strerror();
1279          goto failed;
1280      }
1281
1282      if ((init_fct = (void(</strong>)())GetProcAddress(handle, buf)) == <span class="caps">NULL</span>) {
1283          rb_loaderror(&#8220;%s &#8211; %s\n%s&#8221;, dln_strerror(), buf, file);
1284      }
1285
1286      /* call Init_xxxx() <strong>/
1287      (</strong>init_fct)();
1288      return handle;</p>
<p>1576    failed:
1577      rb_loaderror(&#8220;%s &#8211; %s&#8221;, error, file);
1580  }</p>
<p>(dln.c)
</pre></p>
<p>Doing `LoadLibrary()` then `GetProcAddress()`.
The pattern is so equivalent that nothing is left to say,
I decided to end this chapter.</p>

    <footer>
      The original work is Copyright © 2002 - 2004 Minero AOKI.
      Translated by Vincent ISAMBART and Clifford Escobar CAOILE
      This work is licensed under a
      <p>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/">Creative Commons Attribution-NonCommercial-ShareAlike2.5 License</a>
      </p>
    </footer>

  </div>
</body>
</html>
