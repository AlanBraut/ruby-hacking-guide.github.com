<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>  Ruby Language Details |  Ruby Hacking Guide </title>
  <link rel="stylesheet" href="/css/styles.css" />
</head>
<body>

  <div id="main">

    <header>
      <h1><a href="/">Ruby Hacking Guide</a></h1>
    </header>

    <nav role="navigation">
      <ul>
      </ul>
    </nav>

    <h1 id="chapter-8--ruby-language-details">Chapter 8 : Ruby Language Details</h1>

<p>I’ll talk about the details of Ruby’s syntax and evaluation,
which haven’t been covered yet. I didn’t intend a complete exposition,
so I left out everything which doesn’t come up in this book.
That’s why you won’t be able to write Ruby programs just by
reading this. A complete exposition can be found in the
\footnote{Ruby reference manual: `archives/ruby-refm.tar.gz` in the attached CD-ROM}</p>

<p>Readers who know Ruby can skip over this chapter.</p>

<h2 id="literals">Literals</h2>

<p>The expressiveness of Ruby’s literals is extremely high.
In my opinion, what makes Ruby a script language
is firstly the existence of
the toplevel, secondly it’s the expressiveness of its literals.
Thirdly it might be the richness of its standard library.</p>

<p>A single literal already has enormous power, but even more
when multiple literals are combined.
Especially the ability of creating complex literals that hash and array literals
are combined is the biggest advantage of Ruby’s literal.
One can write, for instance, a hash of arrays of regular expressions
by constructing straightforwardly.</p>

<p>What kind of expressions are valid?
Let’s look at them one by one.</p>

<h3 id="strings">Strings</h3>

<p>Strings and regular expressions can’t be missing in a scripting language.
The expressiveness of Ruby’s string is very various even more than the
other Ruby’s literals.</p>

<h4 id="single-quoted-strings">Single Quoted Strings</h4>

<pre><code class="language-emlist">'string'              # 「string」
'\\begin{document}'   # 「\begin{document}」
'\n'                  # 「\n」backslash and an n, not a newline
'\1'                  # 「\1」backslash and 1
'\''                  # 「'」
</code></pre>

<p>This is the simplest form.
In C, what enclosed in single quotes becomes a character,
but in Ruby, it becomes a string.
Let’s call this a `’`-string. The backslash escape
is in effect only for `\` itself and `’`. If one puts a backslash
in front of another character the backslash remains as
in the fourth example.</p>

<p>And Ruby’s strings aren’t divided by newline characters.
If we write a string over several lines the newlines are contained
in the string.</p>

<pre><code class="language-emlist">'multi
    line
        string'
</code></pre>

<p>And if the `-K` option is given to the `ruby` command, multibyte strings
will be accepted. At present the three encodings EUC-JP (`-Ke`),
Shift JIS (`-Ks`), and UTF8 (`-Ku`) can be specified.</p>

<pre><code class="language-emlist">'「漢字が通る」と「マルチバイト文字が通る」はちょっと違う'
# 'There's a little difference between "Kanji are accepted" and "Multibyte characters are accepted".'
</code></pre>

<h4 id="double-quoted-strings">Double Quoted Strings</h4>

<pre><code class="language-emlist">"string"              # 「string」
"\n"                  # newline
"\x0f"               # a byte given in hexadecimal form
"page#{n}.html"       # embedding a command
</code></pre>

<p>With double quotes we can use command expansion and backslash notation.
The backslash notation is something classical that is also supported in C,
for instance, `\n` is a newline, `\b` is a backspace.
In Ruby, `Ctrl-C` and ESC can also be expressed, that’s convenient.
However, merely listing the whole notation is not fun,
regarding its implementation, it just means a large number of cases to be
handled and there’s nothing especially interesting.
Therefore, they are entirely left out here.</p>

<p>On the other hand, expression expansion is even more fantastic.
We can write an arbitrary Ruby expression inside `#{ }` and it
will be evaluated at runtime and embedded into the string. There
are no limitations like only one variable or only one method.
Getting this far, it is not a mere literal anymore but
the entire thing can be considered as an expression to express a string.</p>

<pre><code class="language-emlist">"embedded #{lvar} expression"
"embedded #{@ivar} expression"
"embedded #{1 + 1} expression"
"embedded #{method_call(arg)} expression"
"embedded #{"string in string"} expression"
</code></pre>

<h4 id="strings-with-">Strings with `%`</h4>

<pre><code class="language-emlist">%q(string)            # same as 'string'
%Q(string)            # same as "string"
%(string)             # same as %Q(string) or "string"
</code></pre>

<p>If a lot of separator characters appear in a string, escaping all of them
becomes a burden. In that case the separator characters can be
changed by using `%`.
In the following example, the same string is written as a `”`-string and
`%`-string.</p>

<pre><code class="language-emlist">""
%Q()
</code></pre>

<p>The both expressions has the same length,
but the `%`-one is a lot nicer to look at.
When we have more characters to escape in it,
`%`-string would also have advantage in length.</p>

<p>Here we have used parentheses as delimiters, but something else is fine,
too. Like brackets or braces or `#`. Almost every symbol is fine, even
`%`.</p>

<pre><code class="language-emlist">%q#this is string#
%q[this is string]
%q%this is string%
</code></pre>

<h4 id="here-documents">Here Documents</h4>

<p>Here document is a syntax which can express strings spanning multiple lines.
A normal string starts right after the delimiter `”`
and everything until the ending `”` would be the content.
When using here document,
the lines between the line which contains the starting `&lt;&lt;EOS<code class="highlighter-rouge"> and
the line which contains the ending </code>EOS` would be the content.</p>

<pre class="emlist">
"the characters between the starting symbol and the ending symbol
will become a string."

&lt;&lt;EOS
All lines between the starting and
the ending line are in this
here document
EOS
</pre>

<p>Here we used `EOS` as identifier but any word is fine.
Precisely speaking, all the character matching `[a-zA-Z_0-9]` and multi-byte
characters can be used.</p>

<p>The characteristic of here document is that the delimiters are
“the lines containing the starting identifier or the ending identifier”.
The line which contains the start symbol is the starting delimiter.
Therefore, the position of the start identifier in the line is not important.
Taking advantage of this, it doesn’t matter that,
for instance, it is written in the middle of an expression:</p>

<pre><code class="language-emlist">printf(&lt;
</code></pre>

<p>In this case the string `“count=%d\n”` goes in the place of `&lt;&lt;EOS`.
So it’s the same as the following.</p>

<pre><code class="language-emlist">printf("count=%d\n", count_n(str))
</code></pre>

<p>The position of the starting identifier is really not restricted,
but on the contrary, there are strict
rules for the ending symbol: It must be at the beginning of the line
and there must not be another letter in that line. However
if we write the start symbol with a minus like this `&lt;&lt;-EOS` we
can indent the line with the end symbol.</p>

<pre><code class="language-emlist">     &lt;&lt;-EOS
It would be convenient if one could indent the content
of a here document. But that's not possible.
If you want that, writing a method to delete indents is
usually a way to go. But beware of tabs.
     EOS
</code></pre>

<p>Furthermore, the start symbol can be enclosed in single or double quotes.
Then the properties of the whole here document change.
When we change `&lt;&lt;EOS<code class="highlighter-rouge"> to </code>«“EOS”` we can use embedded expressions
and backslash notation.</p>

<pre class="emlist">
&lt;&lt;"EOS"
One day is \#{24 \* 60 \* 60} seconds.
Incredible.
EOS

</pre>
<p>But `&lt;&lt;‘EOS’` is not the same as a single quoted string. It starts
the complete literal mode. Everything even backslashes go
into the string as they are typed. This is useful for a string which
contains many backslashes.</p>

<p>In Part 2, I’ll explain how to parse a here document.
But I’d like you to try to guess it before.</p>

<h3 id="characters">Characters</h3>

<p>Ruby strings are byte sequences, there are no character objects.
Instead there are the following expressions which return the
integers which correspond a certain character in ASCII code.</p>

<pre><code class="language-emlist">?a                    # the integer which corresponds to "a"
?.                    # the integer which corresponds to "."
?\n                   # LF
?\C-a                 # Ctrl-a
</code></pre>

<h3 id="regular-expressions">Regular Expressions</h3>

<pre><code class="language-emlist">/regexp/
/^Content-Length:/i
/正規表現/
/\/\*.*?\*\//m        # An expression which matches C comments
/reg#{1 + 1}exp/      # the same as /reg2exp/
</code></pre>

<p>What is contained between slashes is a regular expression.
Regular expressions are a language to designate string patterns.
For example</p>

<pre><code class="language-emlist">/abc/
</code></pre>

<p>This regular expression matches a string where there’s an `a` followed
by a `b` followed by a `c`. It matches “abc” or “fffffffabc” or
“abcxxxxx”.</p>

<p>One can designate more special patterns.</p>

<pre><code class="language-emlist">/^From:/
</code></pre>

<p>This matches a string where there’s a `From` followed by a `:` at
the beginning of a line. There are several more expressions of this kind,
such that one can create quite complex patterns.</p>

<p>The uses are infinite:
Changing the matched part to another string, deleting the matched part,
determining if there’s one match and so on…</p>

<p>A more concrete use case would be, for instance, extracting the `From:` header
from a mail, or changing the `\n` to an `\r`,
or checking if a string looks like a mail address.</p>

<p>Since the regular expression itself is an independent language, it has
its own parser and evaluator which are different from `ruby`.
They can be found in `regex.c`.
Hence, it’s enough for `ruby` to be able to cut out the regular expression part
from a Ruby program and feed it. As a consequence, they are treated almost the
same as strings from the grammatical point of view.
Almost all of the features which strings have like escapes, backslash notations
and embedded expressions can be used in the same way in regular expressions.</p>

<p>However, we can say they are treated as the same as strings only when we are in
the viewpoint of “Ruby’s syntax”. As mentioned before, since regular expression
itself is a language, naturally we have to follow its language constraints.
To describe regular expression in detail, it’s so large that one more can be
written, so I’d like you to read another book for this subject.
I recommend “Mastering Regular Expression” by Jeffrey E.F. Friedl.</p>

<h4 id="regular-expressions-with-">Regular Expressions with `%`</h4>

<p>Also as with strings, regular expressions also have a syntax for changing
delimiters. In this case it is `%r`. To understand this, looking at some
examples are enough to understand.</p>

<pre><code class="language-emlist">%r(regexp)
%r[/\*.*?\*/]            # matches a C comment
%r("(?:[^"\\]+|\\.)*")   # matches a string in C
%r{reg#{1 + 1}exp}       # embedding a Ruby expression
</code></pre>

<h3 id="arrays">Arrays</h3>

<p>A comma-separated list enclosed in brackets `[]` is an array literal.</p>

<pre><code class="language-emlist">[1, 2, 3]
['This', 'is', 'an', 'array', 'of', 'string']

[/regexp/, {'hash'=&gt;3}, 4, 'string', ?\C-a]

lvar = $gvar = @ivar = @@cvar = nil
[lvar, $gvar, @ivar, @@cvar]
[Object.new(), Object.new(), Object.new()]
</code></pre>

<p>Ruby’s array (`Array`) is a list of arbitrary objects. From a syntactical
standpoint, it’s characteristic is that arbitrary expressions can be elements.
As mentioned earlier,
an array of hashes of regular expressions can easily be made.
Not just literals but also expressions which variables or method calls combined
together can also be written straightforwardly.</p>

<p>Note that this is “an expression which generates an array object” as with the
other literals.</p>

<pre><code class="language-emlist">i = 0
while i &lt; 5
  p([1,2,3].id)    # Each time another object id is shown.
  i += 1
end
</code></pre>

<h4 id="word-arrays">Word Arrays</h4>

<p>When writing scripts one uses arrays of strings a lot, hence
there is a special notation only for arrays of strings.
That is `%w`. With an example it’s immediately obvious.</p>

<pre><code class="language-emlist">%w( alpha beta gamma delta )   # ['alpha','beta','gamma','delta']
%w( 月 火 水 木 金 土 日 )
%w( Jan Feb Mar Apr May Jun
    Jul Aug Sep Oct Nov Dec )
</code></pre>

<p>There’s also `%W` where expressions can be embedded.
It’s a feature implemented fairly recently.</p>

<pre><code class="language-emlist">n = 5
%w( list0 list#{n} )   # ['list0', 'list#{n}']
%W( list0 list#{n} )   # ['list0', 'list5']
</code></pre>

<p>The author hasn’t come up with a good use of `%W` yet.</p>

<h3 id="hashes">Hashes</h3>

<p>Hash tables are data structure which store a one-to-one relation between
arbitrary objects.
By writing as follows, they will be expressions to generate tables.</p>

<pre><code class="language-emlist">{ 'key' =&gt; 'value', 'key2' =&gt; 'value2' }
{ 3 =&gt; 0, 'string' =&gt; 5, ['array'] =&gt; 9 }
{ Object.new() =&gt; 3, Object.new() =&gt; 'string' }

# Of course we can put it in several lines.
{ 0 =&gt; 0,
  1 =&gt; 3,
  2 =&gt; 6 }
</code></pre>

<p>We explained hashes in detail in the third chapter “Names and
Nametables”. They are fast lookup tables which allocate memory slots depending
on the hash values. In Ruby grammar,
both keys and values can be arbitrary expressions.</p>

<p>Furthermore, when used as an argument of a method call,
the `{…}` can be omitted under a certain condition.</p>

<pre><code class="language-emlist">  some_method(arg, key =&gt; value, key2 =&gt; value2)
# some_method(arg, {key =&gt; value, key2 =&gt; value2}) # same as above
</code></pre>

<p>With this we can imitate named (keyword) arguments.</p>

<pre><code class="language-emlist">button.set_geometry('x' =&gt; 80, 'y' =&gt; '240')
</code></pre>

<p>Of course in this case `set_geometry` must accept a hash as input.
Though real keyword arguments will be transformed into parameter variables,
it’s not the case for this because this is just a “imitation”.</p>

<h3 id="ranges">Ranges</h3>

<p>Range literals are oddballs which don’t appear in most other languages.
Here are some expressions which generate Range objects.</p>

<pre><code class="language-emlist">0..5          # from 0 to 5 containing 5
0...5         # from 0 to 5 not containing 5
1+2 .. 9+0    # from 3 to 9 containing 9
'a'..'z'      # strings from 'a' to 'z' containing 'z'
</code></pre>

<p>If there are two dots the last element is included. If there
are three dots it is not included. Not only integers but also floats
and strings can be made into ranges, even a range between arbitrary objects can
be created if you’d attempt.
However, this is a specification of `Range` class, which is the class of range
objects, (it means a library), this is not a matter of grammar.
From the parser’s standpoint,
it just enables to concatenate arbitrary expressions with `..`.
If a range cannot be generated with the objects as the evaluated results,
it would be a runtime error.</p>

<p>By the way, because the precedence of `..` and `…` is quite low,
sometimes it is interpreted in a surprising way.</p>

<pre><code class="language-emlist">1..5.to_a()   # 1..(5.to_a())
</code></pre>

<p>I think my personality is relatively bent for Ruby grammar,
but somehow I don’t like only this specification.</p>

<h3 id="symbols">Symbols</h3>

<p>In Part 1, we talked about symbols at length.
It’s something corresponds one-to-one to an arbitrary string.
In Ruby symbols are expressed with a `:` in front.</p>

<pre><code class="language-emlist">:identifier
:abcde
</code></pre>

<p>These examples are pretty normal.
Actually, besides them, all variable names and method names
can become symbols with a `:` in front. Like this:</p>

<pre><code class="language-emlist">:$gvar
:@ivar
:@@cvar
:CONST
</code></pre>

<p>Moreover, though we haven’t talked this yet,
`[]` or `attr=` can be used as method names,
so naturally they can also be used as symbols.</p>

<pre><code class="language-emlist">:[]
:attr=
</code></pre>

<p>When one uses these symbols as values in an array, it’ll look quite
complicated.</p>

<h3 id="numerical-values">Numerical Values</h3>

<p>This is the least interesting.
One possible thing I can introduce here is that,
when writing a million,</p>

<pre><code class="language-emlist">1_000_000
</code></pre>

<p>as written above, we can use underscore delimiters in the middle.
But even this isn’t particularly interesting.
From here on in this book,
we’ll completely forget about numerical values.</p>

<h2 id="methods">Methods</h2>

<p>Let’s talk about the definition and calling of methods.</p>

<h3 id="definition-and-calls">Definition and Calls</h3>

<pre><code class="language-emlist">def some_method( arg )
  ....
end

class C
  def some_method( arg )
    ....
  end
end
</code></pre>

<p>Methods are defined with `def`. If they are defined at toplevel
they become function style methods, inside a class they become
methods of this class. To call a method which was defined in a class,
one usually has to create an instance with `new` as shown below.</p>

<pre><code class="language-emlist">C.new().some_method(0)
</code></pre>

<h3 id="the-return-value-of-methods">The Return Value of Methods</h3>

<p>The return value of a method is,
if a `return` is executed in the middle, its value.
Otherwise, it’s the value of the statement which was executed last.</p>

<pre><code class="language-emlist">def one()     # 1 is returned
  return 1
  999
end

def two()     # 2 is returned
  999
  2
end

def three()   # 3 is returned
  if true then
    3
  else
    999
  end
end
</code></pre>

<p>If the method body is empty,
it would automatically be `nil`,
and an expression without a value cannot put at the end.
Hence every method has a return value.</p>

<h3 id="optional-arguments">Optional Arguments</h3>

<p>Optional arguments can also be defined. If the number of arguments
doesn’t suffice, the parameters are automatically assigned to
default values.</p>

<pre><code class="language-emlist">def some_method( arg = 9 )  # default value is 9
  p arg
end

some_method(0)    # 0 is shown.
some_method()     # The default value 9 is shown.
</code></pre>

<p>There can also be several optional arguments.
But in that case they must all come at the end of the argument list.
If elements in the middle of the list were optional,
how the correspondences of the arguments would be very unclear.</p>

<pre><code class="language-emlist">def right_decl( arg1, arg2, darg1 = nil, darg2 = nil )
  ....
end

# This is not possible
def wrong_decl( arg, default = nil, arg2 )  # A middle argument cannot be optional
  ....
end
</code></pre>

<h3 id="omitting-argument-parentheses">Omitting argument parentheses</h3>

<p>In fact, the parentheses of a method call can be omitted.</p>

<pre><code class="language-emlist">puts 'Hello, World!'   # puts("Hello, World")
obj = Object.new       # obj = Object.new()
</code></pre>

<p>In Python we can get the method object by leaving out parentheses,
but there is no such thing in Ruby.</p>

<p>If you’d like to, you can omit more parentheses.</p>

<pre><code class="language-emlist">  puts(File.basename fname)
# puts(File.basename(fname)) same as the above
</code></pre>

<p>If we like we can even leave out more</p>

<pre><code class="language-emlist">  puts File.basename fname
# puts(File.basename(fname))  same as the above
</code></pre>

<p>However, recently this kind of “nested omissions” became a cause of warnings.
It’s likely that this will not pass anymore in Ruby 2.0.</p>

<p>Actually even the parentheses of the parameters definition can also be omitted.</p>

<pre><code class="language-emlist">def some_method param1, param2, param3
end

def other_method    # without arguments ... we see this a lot
end
</code></pre>

<p>Parentheses are often left out in method calls, but leaving out
parentheses in the definition is not very popular.
However if there are no arguments, the parentheses are frequently omitted.</p>

<h3 id="arguments-and-lists">Arguments and Lists</h3>

<p>Because Arguments form a list of objects,
there’s nothing odd if we can do something converse: extracting a list (an
array) as arguments,
as the following example.</p>

<pre><code class="language-emlist">def delegate(a, b, c)
  p(a, b, c)
end

list = [1, 2, 3]
delegate(*list)   # identical to delegate(1, 2, 3)
</code></pre>

<p>In this way we can distribute an array into arguments.
Let’s call this device a `*`argument now. Here we used a local variable
for demonstration, but of course there is no limitation.
We can also directly put a literal or a method call instead.</p>

<pre><code class="language-emlist">m(*[1,2,3])    # We could have written the expanded form in the first place...
m(*mcall())
</code></pre>

<p>The <code class="highlighter-rouge">*</code> argument can be used together with ordinary arguments,
but the <code class="highlighter-rouge">*</code> argument must come last.
Otherwise, the correspondences to parameter variables cannot be determined in a
single way.</p>

<p>In the definition on the other hand we can handle the arguments in
bulk when we put a `*` in front of the parameter variable.</p>

<pre><code class="language-emlist">def some_method( *args )
  p args
end

some_method()          # prints []
some_method(0)         # prints [0]
some_method(0, 1)      # prints [0,1]
</code></pre>

<p>The surplus arguments are gathered in an array. Only one `*`parameter
can be declared. It must also come after the default arguments.</p>

<pre><code class="language-emlist">def some_method0( arg, *rest )
end
def some_method1( arg, darg = nil, *rest )
end
</code></pre>

<p>If we combine list expansion and bulk reception together, the arguments
of one method can be passed as a whole to another method. This might
be the most practical use of the `*`parameter.</p>

<pre><code class="language-emlist"># a method which passes its arguments to other_method
def delegate(*args)
  other_method(*args)
end

def other_method(a, b, c)
  return a + b + c
end

delegate(0, 1, 2)      # same as other_method(0, 1, 2)
delegate(10, 20, 30)   # same as other_method(10, 20, 30)
</code></pre>

<h3 id="various-method-call-expressions">Various Method Call Expressions</h3>

<p>Being just a single feature as ‘method call’ does not mean its representation
is also single. Here is about so-called syntactic sugar.
In Ruby there is a ton of it,
and they are really attractive for a person who has a fetish for parsers.
For instance the examples below are all method calls.</p>

<pre><code class="language-emlist">1 + 2                   # 1.+(2)
a == b                  # a.==(b)
~/regexp/               # /regexp/.~
obj.attr = val          # obj.attr=(val)
obj[i]                  # obj.[](i)
obj[k] = v              # obj.[]=(k,v)
`cvs diff abstract.rd`  # Kernel.`('cvs diff abstract.rd')
</code></pre>

<p>It’s hard to believe until you get used to it, but `attr=`, `[]=`, `\``
are (indeed) all method names. They can appear as names in a method definition
and can also be used as symbols.</p>

<pre><code class="language-emlist">class C
  def []( index )
  end
  def +( another )
  end
end
p(:attr=)
p(:[]=)
p(:`)
</code></pre>

<p>As there are people who don’t like sweets, there are also many people who
dislike syntactic sugar. Maybe they feel unfair when the things which are
essentially the same appear in faked looks.
(Why’s everyone so serious?)</p>

<p>Let’s see some more details.</p>

<h4 id="symbol-appendices">Symbol Appendices</h4>

<pre><code class="language-emlist">obj.name?
obj.name!
</code></pre>

<p>First a small thing. It’s just appending a `?` or a `!`. Call and Definition
do not differ, so it’s not too painful. There are convention for what
to use these method names, but there is no enforcement on language level.
It’s just a convention at human level.
This is probably influenced from Lisp in which a great variety
of characters can be used in procedure names.</p>

<h4 id="binary-operators">Binary Operators</h4>

<pre><code class="language-emlist">1 + 2    # 1.+(2)
</code></pre>

<p>Binary Operators will be converted to a method call to the object on the
left hand side. Here the method `+` from the object `1` is called.
As listed below there are many of them. There are the general operators
`+` and `-`, also the equivalence operator `==` and the spaceship operator
`&lt;=&gt;’ as in Perl, all sorts. They are listed in order of their precedence.</p>

<pre><code class="language-emlist">**
* / %
+ -
&lt;&lt; &gt;&gt;
&amp;
| ^
&gt; &gt;= &lt; &lt;=
&lt;=&gt; == === =~
</code></pre>

<p>The symbols `&amp;` and `|` are methods, but the double symbols `&amp;&amp;` and `||`
are built-in operators. Remember how it is in C.</p>

<h4 id="unary-operators">Unary Operators</h4>

<pre><code class="language-emlist">+2
-1.0
~/regexp/
</code></pre>

<p>These are the unary operators. There are only three of them: `+ - ~`.
`+` and `-` work as they look like (by default).
The operator `~` matches a string or a regular expression
with the variable `$_`. With an integer it stands for bit conversion.</p>

<p>To distinguish the unary `+` from the binary `+` the method names
for the unary operators are `+<code class="highlighter-rouge">` and `-</code>` respectively.
Of course they can be called by just writing `+n` or `-n`.</p>

<p>((errata: + or - as the prefix of a numeric literal is actually scanned as a
part of the literal. This is a kind of optimizations.))</p>

<h4 id="attribute-assignment">Attribute Assignment</h4>

<pre><code class="language-emlist">obj.attr = val   # obj.attr=(val)
</code></pre>

<p>This is an attribute assignment fashion. The above will be translated
into the method call `attr=`. When using this together with method calls whose
parentheses are omitted, we can write code which looks like attribute access.</p>

<pre><code class="language-emlist">class C
  def i() @i end          # We can write the definition in one line
  def i=(n) @i = n end
end

c = C.new
c.i = 99
p c.i    # prints 99
</code></pre>

<p>However it will turn out both are method calls.
They are similar to get/set property in Delphi or slot accessors in CLOS.</p>

<p>Besides, we cannot define a method such as `obj.attr(arg)=`,
which can take another argument in the attribute assignment fashion.</p>

<h4 id="index-notation">Index Notation</h4>

<pre><code class="language-emlist">obj[i]    # obj.[](i)
</code></pre>

<p>The above will be translated into a method call for `[]`.
Array and hash access are also implemented with this device.</p>

<pre><code class="language-emlist">obj[i] = val   # obj.[]=(i, val)
</code></pre>

<p>Index assignment fashion.
This is translated into a call for a method named `[]=`.</p>

<h3 id="super">`super`</h3>

<p>We relatively often have
a situation where we want add a little bit to the behaviour of an already
existing method rather than replacing it.
Here a mechanism to call a method of the superclass when overwriting a method
is required.
In Ruby, that’s `super`.</p>

<pre><code class="language-emlist">class A
  def test
    puts 'in A'
  end
end
class B &lt; A
  def test
    super   # invokes A#test
  end
end
</code></pre>

<p>Ruby’s `super` differs from the one in Java. This single word
means “call the method with the same name in the superclass”.
`super` is a reserved word.</p>

<p>When using `super`, be careful about the difference between
`super` with no arguments and `super` whose arguments are omitted.
The `super` whose arguments are omitted passes all the given parameter variables.</p>

<pre><code class="language-emlist">class A
  def test( *args )
    p args
  end
end

class B &lt; A
  def test( a, b, c )
    # super with no arguments
    super()    # shows []

    # super with omitted arguments. Same result as super(a, b, c)
    super      # shows [1, 2, 3]
  end
end

B.new.test(1,2,3)
</code></pre>

<h4 id="visibility">Visibility</h4>

<p>In Ruby, even when calling the same method,
it can be or cannot be called depending on the location (meaning the
object). This functionality is usually called “visibility”
(whether it is visible).
In Ruby, the below three types of methods can be defined.</p>

<ul>
  <li>`public`</li>
  <li>`private`</li>
  <li>`protected`</li>
</ul>

<p>`public` methods can be called from anywhere in any form.
`private` methods can only be called in a form “syntactically” without a receiver.
In effect they can only be called by instances of the class
in which they were defined and in instances of its subclass.
`protected` methods can only be called by instances of the defining class
and its subclasses.
It differs from `private` that methods can still be called from other
instances of the same class.</p>

<p>The terms are the same as in C++ but the meaning is slightly different.
Be careful.</p>

<p>Usually we control visibility as shown below.</p>

<pre><code class="language-emlist">class C
  public
  def a1() end   # becomes public
  def a2() end   # becomes public

  private
  def b1() end   # becomes private
  def b2() end   # becomes private

  protected
  def c1() end   # becomes protected
  def c2() end   # becomes protected
end
</code></pre>

<p>Here `public`, `private` and `protected are method calls without
parentheses. These aren’t even reserved words.</p>

<p>`public` and `private` can also be used with an argument to set
the visibility of a particular method. But its mechanism is not interesting.
We’ll leave this out.</p>

<h4 id="module-functions">Module functions</h4>

<p>Given a module ‘M’. If there are two methods with the exact same
content</p>

<ul>
  <li>`M.method_name`</li>
  <li>`M#method_name`(Visibility is `private`)</li>
</ul>

<p>then we call this a module function.</p>

<p>It is not apparent why this should be useful. But let’s look
at the next example which is happily used.</p>

<pre><code class="language-emlist">Math.sin(5)       # If used for a few times this is more convenient

include Math
sin(5)            # If used more often this is more practical
</code></pre>

<p>It’s important that both functions have the same content.
With a different `self` but with the same code the behavior should
still be the same. Instance variables become extremely difficult to use.
Hence such method is very likely a method in which only procedures are written
(like `sin`). That’s why they are called module “functions”.</p>

<h2 id="iterators">Iterators</h2>

<p>Ruby’s iterators differ a bit from Java’s or C++’s iterator classes
or ‘Iterator’ design pattern. Precisely speaking, those iterators
are called exterior iterators, Ruby’s iterators are interior iterators.
Regarding this, it’s difficult to understand from the definition so
let’s explain it with a concrete example.</p>

<pre><code class="language-emlist">arr = [0,2,4,6.8]
</code></pre>

<p>This array is given and we want to access the elements in
order. In C style we would write the following.</p>

<pre><code class="language-emlist">i = 0
while i &lt; arr.length
  print arr[i]
  i += 1
end
</code></pre>

<p>Using an iterator we can write:</p>

<pre><code class="language-emlist">arr.each do |item|
  print item
end
</code></pre>

<p>Everything from `each do` to `end` is the call to an iterator method.
More precisely `each` is the iterator method and between
`do` and `end` is the iterator block.
The part between the vertical bars are called block parameters,
which become variables to receive the parameters passed from the iterator method
to the block.</p>

<p>Saying it a little abstractly, an iterator is something like
a piece of code which has been cut out and passed. In our example the
piece `print item` has been cut out and is passed to the `each` method.
Then `each` takes all the elements of the array in order and passes them
to the cut out piece of code.</p>

<p>We can also think the other way round. The other parts except `print item`
are being cut out and enclosed into the `each` method.</p>

<pre><code class="language-emlist">i = 0
while i &lt; arr.length
  print arr[i]
  i += 1
end

arr.each do |item|
  print item
end
</code></pre>

<h3 id="comparison-with-higher-order-functions">Comparison with higher order functions</h3>

<p>What comes closest in C to iterators are functions which receive function pointers,
it means higher order functions. But there are two points in which iterators in Ruby
and higher order functions in C differ.</p>

<p>Firstly, Ruby iterators can only take one block. For instance we can’t
do the following.</p>

<pre><code class="language-emlist"># Mistake. Several blocks cannot be passed.
array_of_array.each do |i|
  ....
end do |j|
  ....
end
</code></pre>

<p>Secondly, Ruby’s blocks can share local variables with the code outside.</p>

<pre><code class="language-emlist">lvar = 'ok'
[0,1,2].each do |i|
  p lvar    # Can acces local variable outside the block.
end
</code></pre>

<p>That’s where iterators are convenient.</p>

<p>But variables can only be shared with the outside. They cannot be shared
with the inside of the iterator method ( e.g. `each`). Putting it intuitively,
only the variables in the place which looks of the source code continued are
visible.</p>

<h3 id="block-local-variables">Block Local Variables</h3>

<p>Local variables which are assigned inside a block stay local to that block,
it means they become block local variables. Let’s check it out.</p>

<pre><code class="language-emlist">[0].each do
  i = 0
  p i     # 0
end
</code></pre>

<p>For now, to create a block, we apply `each` on an array of length 1
(We can fully leave out the block parameter).
In that block, the `i` variable is first assigned .. meaning declared.
This makes `i` block local.</p>

<p>It is said block local, so it should not be able to access from the outside.
Let’s test it.</p>

<pre><code class="language-screen">% ruby -e '
[0].each do
  i = 0
end
p i     # Here occurs an error.
'
-e:5: undefined local variable or method `i'
for # (NameError)
</code></pre>

<p>When we referenced a block local variable from outside the block,
surely an error occured. Without a doubt it stayed local to the block.</p>

<p>Iterators can also be nested repeatedly. Each time
the new block creates another scope.</p>

<pre><code class="language-emlist">lvar = 0
[1].each do
  var1 = 1
  [2].each do
    var2 = 2
    [3].each do
      var3 = 3
      #  Here lvar, var1, var2, var3 can be seen
    end
    # Here lvar, var1, var2 can be seen
  end
  # Here lvar, var1 can be seen
end
# Here only lvar can be seen
</code></pre>

<p>There’s one point which you have to keep in mind. Differing from
nowadays’ major languages Ruby’s block local variables don’t do shadowing.
Shadowing means for instance in C that in the code below the two declared
variables `i` are different.</p>

<pre><code class="language-emlist">{
    int i = 3;
    printf("%d\n", i);         /* 3 */
    {
        int i = 99;
        printf("%d\n", i);     /* 99 */
    }
    printf("%d\n", i);         /* 3 (元に戻った) */
}
</code></pre>

<p>Inside the block the <code class="highlighter-rouge">i</code> inside overshadows the <code class="highlighter-rouge">i</code> outside.
That’s why it’s called shadowing.</p>

<p>But what happens with block local variables of Ruby where there’s no shadowing.
Let’s look at this example.</p>

<pre><code class="language-emlist">i = 0
p i           # 0
[0].each do
  i = 1
  p i         # 1
end
p i           # 1 the change is preserved
</code></pre>

<p>Even when we assign <code class="highlighter-rouge">i</code> inside the block,
if there is the same name outside, it would be used.
Therefore when we assign to inside <code class="highlighter-rouge">i</code>, the value of outside <code class="highlighter-rouge">i</code> would be
changed. On this point there
came many complains: “This is error prone. Please do shadowing.”
Each time there’s nearly flaming but till now no conclusion was reached.</p>

<h3 id="the-syntax-of-iterators">The syntax of iterators</h3>

<p>There are some smaller topics left.</p>

<p>First, there are two ways to write an iterator. One is the
`do` ~ `end` as used above, the other one is the enclosing in braces.
The two expressions below have exactly the same meaning.</p>

<pre><code class="language-emlist">arr.each do |i|
  puts i
end

arr.each {|i|    # The author likes a four space indentation for
    puts i       # an iterator with braces.
}
</code></pre>

<p>But grammatically the precedence is different.
The braces bind much stronger than `do`~`end`.</p>

<pre><code class="language-emlist">m m do .... end    # m(m) do....end
m m { .... }       # m(m() {....})
</code></pre>

<p>And iterators are definitely methods,
so there are also iterators that take arguments.</p>

<pre><code class="language-emlist">re = /^\d/                 # regular expression to match a digit at the beginning of the line
$stdin.grep(re) do |line|  # look repeatedly for this regular expression
  ....
end
</code></pre>

<h3 id="yield">`yield`</h3>

<p>Of course users can write their own iterators. Methods which have
a `yield` in their definition text are iterators.
Let’s try to write an iterator with the same effect as `Array#each`:</p>

<pre><code class="language-emlist"># adding the definition to the Array class
class Array
  def my_each
    i = 0
    while i &lt; self.length
      yield self[i]
      i += 1
    end
  end
end

# this is the original each
[0,1,2,3,4].each do |i|
  p i
end

# my_each works the same
[0,1,2,3,4].my_each do |i|
  p i
end
</code></pre>

<p><code class="highlighter-rouge">yield</code> calls the block. At this point control is passed to the block,
when the execution of the block finishes it returns back to the same
location. Think about it like a characteristic function call. When the
present method does not have a block a runtime error will occur.</p>

<pre><code class="language-screen">% ruby -e '[0,1,2].each'
-e:1:in `each': no block given (LocalJumpError)
        from -e:1
</code></pre>

<h3 id="proc">`Proc`</h3>

<p>I said, that iterators are like cut out code which is passed as an
argument. But we can even more directly make code to an object
and carry it around.</p>

<pre><code class="language-emlist">twice = Proc.new {|n| n * 2 }
p twice.call(9)   # 18 will be printed
</code></pre>

<p>In short, it is like a function. As might be expected from the fact it is
created with <code class="highlighter-rouge">new</code>, the return value of <code class="highlighter-rouge">Proc.new</code> is an instance
of the <code class="highlighter-rouge">Proc</code> class.</p>

<p><code class="highlighter-rouge">Proc.new</code> looks surely like an iterator and it is indeed so.
It is an ordinary iterator. There’s only some mystic mechanism inside <code class="highlighter-rouge">Proc.new</code>
which turns an iterator block into an object.</p>

<p>Besides there is a function style method <code class="highlighter-rouge">lambda</code> provided which
has the same effect as <code class="highlighter-rouge">Proc.new</code>. Choose whatever suits you.</p>

<pre><code class="language-emlist">twice = lambda {|n| n * 2 }
</code></pre>

<h4 id="iterators-and-proc">Iterators and `Proc`</h4>

<p>Why did we start talking all of a sudden about <code class="highlighter-rouge">Proc</code>? Because there
is a deep relationship between iterators and <code class="highlighter-rouge">Proc</code>.
In fact, iterator blocks and <code class="highlighter-rouge">Proc</code> objects are quite the same thing.
That’s why one can be transformed into the other.</p>

<p>First, to turn an iterator block into a <code class="highlighter-rouge">Proc</code> object
one has to put an <code class="highlighter-rouge">&amp;</code> in front of the parameter name.</p>

<pre><code class="language-emlist">def print_block( &amp;block )
  p block
end

print_block() do end   # Shows something like 
print_block()          # Without a block nil is printed
</code></pre>

<p>With an <code class="highlighter-rouge">&amp;</code> in front of the argument name, the block is transformed to
a <code class="highlighter-rouge">Proc</code> object and assigned to the variable. If the method is not an
iterator (there’s no block attached) <code class="highlighter-rouge">nil</code> is assigned.</p>

<p>And in the other direction, if we want to pass a <code class="highlighter-rouge">Proc</code> to an iterator
we also use <code class="highlighter-rouge">&amp;</code>.</p>

<pre><code class="language-emlist">block = Proc.new {|i| p i }
[0,1,2].each(&amp;block)
</code></pre>

<p>This code means exactly the same as the code below.</p>

<pre><code class="language-emlist">[0,1,2].each {|i| p i }
</code></pre>

<p>If we combine these two, we can delegate an iterator
block to a method somewhere else.</p>

<pre><code class="language-emlist">def each_item( &amp;block )
  [0,1,2].each(&amp;block)
end

each_item do |i|    # same as [0,1,2].each do |i|
  p i
end
</code></pre>

<h2 id="expressions">Expressions</h2>

<p>“Expressions” in Ruby are things with which we can create other expressions or
statements by combining with the others.
For instance a method call can be another method call’s argument,
so it is an expression. The same goes for literals.
But literals and method calls are not always combinations of elements.
On the contrary, “expressions”, which I’m going to introduce,
always consists of some elements.</p>

<h3 id="if">`if`</h3>

<p>We probably do not need to explain the <code class="highlighter-rouge">if</code> expression. If the conditional
expression is true, the body is executed. As explained in Part 1,
every object except <code class="highlighter-rouge">nil</code> and <code class="highlighter-rouge">false</code> is true in Ruby.</p>

<pre><code class="language-emlist">if cond0 then
  ....
elsif cond1 then
  ....
elsif cond2 then
  ....
else
  ....
end
</code></pre>

<p>`elsif`/`else`-clauses can be omitted. Each `then` as well.
But there are some finer requirements concerning <code class="highlighter-rouge">then</code>.
For this kind of thing, looking at some examples is the best way to understand.
Here only thing I’d say is that the below codes are valid.</p>

<pre><code class="language-emlist"># 1                                    # 4
if cond then ..... end                 if cond
                                       then .... end
# 2
if cond; .... end                      # 5
                                       if cond
# 3                                    then
if cond then; .... end                   ....
                                       end
</code></pre>

<p>And in Ruby, `if` is an expression, so there is the value of the entire `if`
expression. It is the value of the body where a condition expression is met.
For example, if the condition of the first `if` is true,
the value would be the one of its body.</p>

<pre><code class="language-emlist">p(if true  then 1 else 2 end)   #=&gt; 1
p(if false then 1 else 2 end)   #=&gt; 2
p(if false then 1 elsif true then 2 else 3 end)   #=&gt; 2
</code></pre>

<p>If there’s no match, or the matched clause is empty,
the value would be <code class="highlighter-rouge">nil</code>.</p>

<pre><code class="language-emlist">p(if false then 1 end)    #=&gt; nil
p(if true  then   end)    #=&gt; nil
</code></pre>

<h3 id="unless">`unless`</h3>

<p>An <code class="highlighter-rouge">if</code> with a negated condition is an <code class="highlighter-rouge">unless</code>.
The following two expressions have the same meaning.</p>

<pre><code class="language-emlist">unless cond then          if not (cond) then
  ....                      ....
end                       end
</code></pre>

<p><code class="highlighter-rouge">unless</code> can also have attached <code class="highlighter-rouge">else</code> clauses but any <code class="highlighter-rouge">elsif</code> cannot be
attached.
Needless to say, <code class="highlighter-rouge">then</code> can be omitted.</p>

<p><code class="highlighter-rouge">unless</code> also has a value and its condition to decide is completely the same as
`if`. It means the entire value would be the value of the body of the matched
clause. If there’s no match or the matched clause is empty,
the value would be <code class="highlighter-rouge">nil</code>.</p>

<h3 id="and--or-">`and &amp;&amp; or ||`</h3>

<p>The most likely utilization of the <code class="highlighter-rouge">and</code> is probably a boolean operation.
For instance in the conditional expression of an <code class="highlighter-rouge">if</code>.</p>

<pre><code class="language-emlist">if cond1 and cond2
  puts 'ok'
end
</code></pre>

<p>But as in Perl, `sh` or Lisp, it can also be used as a conditional
branch expression.
The two following expressions have the same meaning.</p>

<pre><code class="language-emlist">                                        if invalid?(key)
invalid?(key) and return nil              return nil
                                        end
</code></pre>

<p><code class="highlighter-rouge">&amp;&amp;</code> and <code class="highlighter-rouge">and</code> have the same meaning. Different is the binding order.</p>

<pre><code class="language-emlist">method arg0 &amp;&amp;  arg1    # method(arg0 &amp;&amp; arg1)
method arg0 and arg1    # method(arg0) and arg1
</code></pre>

<p>Basically the symbolic operator creates an expression which can be an argument
(`arg`).
The alphabetical operator creates an expression which cannot become
an argument (`expr`).</p>

<p>As for <code class="highlighter-rouge">and</code>, if the evaluation of the left hand side is true,
the right hand side will also be evaluated.</p>

<p>On the other hand <code class="highlighter-rouge">or</code> is the opposite of <code class="highlighter-rouge">and</code>. If the evaluation of the left hand
side is false, the right hand side will also be evaluated.</p>

<pre><code class="language-emlist">valid?(key) or return nil
</code></pre>

<p><code class="highlighter-rouge">or</code> and <code class="highlighter-rouge">||</code> have the same relationship as <code class="highlighter-rouge">&amp;&amp;</code> and <code class="highlighter-rouge">and</code>. Only the precedence is
different.</p>

<h3 id="the-conditional-operator">The Conditional Operator</h3>

<p>There is a conditional operator similar to C:</p>

<pre><code class="language-emlist">cond ? iftrue : iffalse
</code></pre>

<p>The space between the symbols is important.
If they bump together the following weirdness happens.</p>

<pre><code class="language-emlist">cond?iftrue:iffalse   # cond?(iftrue(:iffalse))
</code></pre>

<p>The value of the conditional operator is the value of the last executed expression.
Either the value of the true side or the value of the false side.</p>

<h3 id="while-until">`while until`</h3>

<p>Here’s a `while` expression.</p>

<pre><code class="language-emlist">while cond do
  ....
end
</code></pre>

<p>This is the simplest loop syntax. As long as <code class="highlighter-rouge">cond</code> is true
the body is executed. The <code class="highlighter-rouge">do</code> can be omitted.</p>

<pre><code class="language-emlist">until io_ready?(id) do
  sleep 0.5
end
</code></pre>

<p><code class="highlighter-rouge">until</code> creates a loop whose condition definition is opposite.
As long as the condition is false it is executed.
The <code class="highlighter-rouge">do</code> can be omitted.</p>

<p>Naturally there is also jump syntaxes to exit a loop.
<code class="highlighter-rouge">break</code> as in C/C++/Java is also <code class="highlighter-rouge">break</code>,
but <code class="highlighter-rouge">continue</code> is <code class="highlighter-rouge">next</code>.
Perhaps <code class="highlighter-rouge">next</code> has come from Perl.</p>

<pre><code class="language-emlist">i = 0
while true
  if i &gt; 10
    break   # exit the loop
  elsif i % 2 == 0
    i *= 2
    next    # next loop iteration
  end
  i += 1
end
</code></pre>

<p>And there is another Perlism: the <code class="highlighter-rouge">redo</code>.</p>

<pre><code class="language-emlist">while cond
  # (A)
  ....
  redo
  ....
end
</code></pre>

<p>It will return to (A) and repeat from there.
What differs from <code class="highlighter-rouge">next</code> is it does not check the condition.</p>

<p>I might come into the world top 100, if the amount of Ruby programs
would be counted, but I haven’t used <code class="highlighter-rouge">redo</code> yet. It does not seem to be
necessary after all because I’ve lived happily despite of it.</p>

<h3 id="case">`case`</h3>

<p>A special form of the <code class="highlighter-rouge">if</code> expression. It performs branching on a series of
conditions. The following left and right expressions are identical in meaning.</p>

<pre><code class="language-emlist">case value
when cond1 then                if cond1 === value
  ....                           ....
when cond2 then                elsif cond2 === value
  ....                           ....
when cond3, cond4 then         elsif cond3 === value or cond4 === value
  ....                           ....
else                           else
  ....                           ....
end                            end
</code></pre>

<p>The threefold equals <code class="highlighter-rouge">===</code> is, as the same as the <code class="highlighter-rouge">==</code>, actually a method call.
Notice that the receiver is the object on the left hand side. Concretely,
if it is the `===` of an `Array`, it would check if it contains the `value`
as its element.
If it is a `Hash`, it tests whether it has the `value` as its key.
If its is an regular expression, it tests if the <code class="highlighter-rouge">value</code> matches.
And so on.
Since `case` has many grammatical elements,
to list them all would be tedious, thus we will not cover them in this book.</p>

<h3 id="exceptions">Exceptions</h3>

<p>This is a control structure which can pass over method boundaries and
transmit errors. Readers who are acquainted to C++ or Java
will know about exceptions. Ruby exceptions are basically the
same.</p>

<p>In Ruby exceptions come in the form of the function style method `raise`.
`raise` is not a reserved word.</p>

<pre><code class="language-emlist">raise ArgumentError, "wrong number of argument"
</code></pre>

<p>In Ruby exception are instances of the <code class="highlighter-rouge">Exception</code> class and it’s
subclasses. This form takes an exception class as its first argument
and an error message as its second argument. In the above case
an instance of <code class="highlighter-rouge">ArgumentError</code> is created and “thrown”. Exception
object would ditch the part after the <code class="highlighter-rouge">raise</code> and start to return upwards the
method call stack.</p>

<pre><code class="language-emlist">def raise_exception
  raise ArgumentError, "wrong number of argument"
  # the code after the exception will not be executed
  puts 'after raise'
end
raise_exception()
</code></pre>

<p>If nothing blocks the exception it will move on and on and
finally it will reach the top level.
When there’s no place to return any more, <code class="highlighter-rouge">ruby</code> gives out a message and ends
with a non-zero exit code.</p>

<pre><code class="language-screen">% ruby raise.rb
raise.rb:2:in `raise_exception': wrong number of argument (ArgumentError)
        from raise.rb:7
</code></pre>

<p>However an <code class="highlighter-rouge">exit</code> would be sufficient for this, and for an exception there
should be a way to set handlers.
In Ruby, <code class="highlighter-rouge">begin</code><sub><code class="highlighter-rouge">rescue</code></sub><code class="highlighter-rouge">end</code> is used for this.
It resembles the <code class="highlighter-rouge">try</code>~<code class="highlighter-rouge">catch</code> in C++ and Java.</p>

<pre><code class="language-emlist">def raise_exception
  raise ArgumentError, "wrong number of argument"
end

begin
  raise_exception()
rescue ArgumentError =&gt; err then
  puts 'exception catched'
  p err
end
</code></pre>

<p><code class="highlighter-rouge">rescue</code> is a control structure which captures exceptions, it catches
exception objects of the specified class and its subclasses. In the
above example, an instance of <code class="highlighter-rouge">ArgumentError</code> comes flying into the place
where <code class="highlighter-rouge">ArgumentError</code> is targeted, so it matches this <code class="highlighter-rouge">rescue</code>.
By <code class="highlighter-rouge">=&gt;err</code> the exception object will be assigned to the local variable
<code class="highlighter-rouge">err</code>, after that the <code class="highlighter-rouge">rescue</code> part is executed.</p>

<pre><code class="language-screen">% ruby rescue.rb
exception catched
#
</code></pre>

<p>When an exception is rescued, it will go through the `rescue` and
it will start to execute the subsequent as if nothing happened,
but we can also make it retry from the `begin`.
To do so, `retry` is used.</p>

<pre><code class="language-emlist">begin    # the place to return
  ....
rescue ArgumentError =&gt; err then
  retry  # retry your life
end
</code></pre>

<p>We can omit the <code class="highlighter-rouge">=&gt;err</code> and the <code class="highlighter-rouge">then</code> after <code class="highlighter-rouge">rescue</code>. We can also leave
out the exception class. In this case, it means as the same as when the
<code class="highlighter-rouge">StandardError</code> class is specified.</p>

<p>If we want to catch more exception classes, we can just write them in line.
When we want to handle different errors differently, we can specify several
`rescue` clauses.</p>

<pre><code class="language-emlist">begin
  raise IOError, 'port not ready'
rescue ArgumentError, TypeError
rescue IOError
rescue NameError
end
</code></pre>

<p>When written in this way, a `rescue` clause that matches the exception class is
searched in order from the top. Only the matched clause will be executed.
For instance, only the clause of <code class="highlighter-rouge">IOError</code> will be executed in the above case.</p>

<p>On the other hand, when there is an <code class="highlighter-rouge">else</code> clause, it is executed
only when there is no exception.</p>

<pre><code class="language-emlist">begin
  nil    # Of course here will no error occur
rescue ArgumentError
  # This part will not be executed
else
  # This part will be executed
end
</code></pre>

<p>Moreover an <code class="highlighter-rouge">ensure</code> clause will be executed in every case:
when there is no exception, when there is an exception, rescued or not.</p>

<pre><code class="language-emlist">begin
  f = File.open('/etc/passwd')
  # do stuff
ensure   # this part will be executed anyway
  f.close
end
</code></pre>

<p>By the way, this <code class="highlighter-rouge">begin</code> expression also has a value. The value of the
whole <code class="highlighter-rouge">begin</code>~<code class="highlighter-rouge">end</code> expression is the value of the part which was executed
last among <code class="highlighter-rouge">begin</code>/@rescue@/@else@ clauses.
It means the last statement of the clauses aside from `ensure`.
The reason why the <code class="highlighter-rouge">ensure</code> is not counted is probably because
<code class="highlighter-rouge">ensure</code> is usually used for cleanup (thus it is not a main line).</p>

<h3 id="variables-and-constants">Variables and Constants</h3>

<p>Referring a variable or a constant. The value is the object the variable points to.
We already talked in too much detail about the various behaviors.</p>

<pre><code class="language-emlist">lvar
@ivar
@@cvar
CONST
$gvar
</code></pre>

<p>I want to add one more thing.
Among the variables starting with <code class="highlighter-rouge">$</code>,
there are special kinds.
They are not necessarily global variables and
some have strange names.</p>

<p>First the Perlish variables <code class="highlighter-rouge">$_</code> and <code class="highlighter-rouge">$~</code>. <code class="highlighter-rouge">$_</code> saves the return
value of <code class="highlighter-rouge">gets</code> and other methods, <code class="highlighter-rouge">$~</code> contains the last match
of a regular expression.
They are incredible variables which are local variables and simultaneously
thread local variables.</p>

<p>And the <code class="highlighter-rouge">$!</code> to hold the exception object when an error is occured,
the <code class="highlighter-rouge">$?</code> to hold the status of a child process,
the <code class="highlighter-rouge">$SAFE</code> to represent the security level,
they are all thread local.</p>

<h3 id="assignment">Assignment</h3>

<p>Variable assignments are all performed by `=`. All variables are
typeless. What is saved is a reference to an object.
As its implementation, it was a `VALUE` (pointer).</p>

<pre><code class="language-emlist">var = 1
obj = Object.new
@ivar = 'string'
@@cvar = ['array']
PI = 3.1415926535
$gvar = {'key' =&gt; 'value'}
</code></pre>

<p>However, as mentioned earlier `obj.attr=val` is not an assignment
but a method call.</p>

<h3 id="self-assignment">Self Assignment</h3>

<pre><code class="language-emlist">var += 1
</code></pre>

<p>This syntax is also in C/C++/Java. In Ruby,</p>

<pre><code class="language-emlist">var = var + 1
</code></pre>

<p>it is a shortcut of this code.
Differing from C, the Ruby <code class="highlighter-rouge">+</code> is a method and thus part of the library.
In C, the whole meaning of <code class="highlighter-rouge">+=</code> is built in the language processor itself.
And in `C++`, <code class="highlighter-rouge">+=</code> and <code class="highlighter-rouge">*=</code> can be wholly overwritten,
but we cannot do this in Ruby.
In Ruby <code class="highlighter-rouge">+=</code> is always defined as an operation of the combination of <code class="highlighter-rouge">+</code> and assignment.</p>

<p>We can also combine self assignment and an attribute-access-flavor method.
The result more looks like an attribute.</p>

<pre><code class="language-emlist">class C
  def i() @i end          # A method definition can be written in one line.
  def i=(n) @i = n end
end

obj = C.new
obj.i = 1
obj.i += 2    # obj.i = obj.i + 2
p obj.i       # 3
</code></pre>

<p>If there is `+=` there might also be `++` but this is not the case.
Why is that so? In Ruby assignment is dealt with on the language level.
But on the other hand methods are in the library. Keeping these two,
the world of variables and the world of objects, strictly apart is an
important peculiarity of Ruby. If <code class="highlighter-rouge">++</code> were introduced the separation
might easily be broken. That’s why there’s no <code class="highlighter-rouge">++</code></p>

<p>Some people don’t want to go without the brevity of <code class="highlighter-rouge">++</code>. It has been
proposed again and again in the mailing list but was always turned down.
I am also in favor of <code class="highlighter-rouge">++</code> but not as much as I can’t do without,
and I have not felt so much needs of <code class="highlighter-rouge">++</code> in Ruby in the first place,
so I’ve kept silent and decided to forget about it.</p>

<h3 id="defined">`defined?`</h3>

<p><code class="highlighter-rouge">defined?</code> is a syntax of a quite different color in Ruby. It tells whether an
expression value is “defined” or not at runtime.</p>

<pre><code class="language-emlist">var = 1
defined?(var)   #=&gt; true
</code></pre>

<p>In other words it tells whether a value can be obtained from the expression
received as its argument (is it okay to call it so?) when the expression is
evaluated. That said but of course you can’t write an expression causing a parse
error, and it could not detect if the expression is something containing a
method call which raises an error in it.</p>

<p>I would have loved to tell you more about <code class="highlighter-rouge">defined?</code>
but it will not appear again in this book. What a pity.</p>

<h2 id="statements">Statements</h2>

<p>A statement is what basically cannot be combined with the other syntaxes,
in other words, they are lined vertically.</p>

<p>But it does not mean there’s no evaluated value.
For instance there are return values
for class definition statements and method definition statements.
However this is rarely recommended and isn’t useful,
you’d better regard them lightly in this way.
Here we also skip about the value of each statement.</p>

<h3 id="the-ending-of-a-statement">The Ending of a statement</h3>

<p>Up to now we just said “For now one line’s one statement”.
But Ruby’s statement ending’s aren’t that straightforward.</p>

<p>First a statement can be ended explicitly with a semicolon as in C.
Of course then we can write two and more statements in one line.</p>

<pre><code class="language-emlist">puts 'Hello, World!'; puts 'Hello, World once more!'
</code></pre>

<p>On the other hand,
when the expression apparently continues,
such as just after opened parentheses, dyadic operators, or a comma,
the statement continues automatically.</p>

<pre><code class="language-emlist"># 1 + 3 * method(6, 7 + 8)
1 +
  3 *
     method(
            6,
            7 + 8)
</code></pre>

<p>But it’s also totally no problem to use a backslash to explicitly indicate the
continuation.</p>

<pre><code class="language-emlist">p 1 + \
  2
</code></pre>

<h3 id="the-modifiers-if-and-unless">The Modifiers `if` and `unless`</h3>

<p>The `if` modifier is an irregular version of the normal `if`
The programs on the left and right mean exactly the same.</p>

<pre><code class="language-emlist">on_true() if cond                if cond
                                   on_true()
                                 end
</code></pre>

<p>The `unless` is the negative version.
Guard statements ( statements which exclude exceptional conditions) can
be conveniently written with it.</p>

<h3 id="the-modifiers-while-and-until">The Modifiers `while` and `until`</h3>

<p>`while` and `until` also have a back notation.</p>

<pre><code class="language-emlist">process() while have_content?
sleep(1) until ready?
</code></pre>

<p>Combining this with `begin` and `end` gives a `do`-`while`-loop like in C.</p>

<pre><code class="language-emlist">begin
  res = get_response(id)
end while need_continue?(res)
</code></pre>

<h3 id="class-definition">Class Definition</h3>

<pre><code class="language-emlist">class C &lt; SuperClass
  ....
end
</code></pre>

<p>Defines the class `C` which inherits from `SuperClass`</p>

<p>We talked quite extensively about classes in Part 1.
This statement will be executed, the class to be defined will
become <code class="highlighter-rouge">self</code> within the statement, arbitrary expressions can be written within. Class
definitions can be nested. They form the foundation of Ruby execution
image.</p>

<h3 id="method-definition">Method Definition</h3>

<pre><code class="language-emlist">def m(arg)
end
</code></pre>

<p>I’ve already written about method definition and won’t add more.
This section is put to make it clear that
they also belong to statements.</p>

<h3 id="singleton-method-definition">Singleton method definition</h3>

<p>We already talked a lot about singleton methods in Part 1.
They do not belong to classes but to objects, in fact, they belong
to singleton classes. We define singleton methods by putting the
receiver in front of the method name. Parameter declaration is done
the same way like with ordinary methods.</p>

<pre><code class="language-emlist">def obj.some_method
end

def obj.some_method2( arg1, arg2, darg = nil, *rest, &amp;block )
end
</code></pre>

<h3 id="definition-of-singleton-methods">Definition of Singleton methods</h3>

<pre><code class="language-emlist">class &lt;&lt; obj
  ....
end
</code></pre>

<p>From the viewpoint of purposes,
it is the statement to define some singleton methods in a bundle.
From the viewpoint of measures,
it is the statement in which the singleton class of `obj` becomes `self` when
executed.
In all over the Ruby program,
this is the only place where a singleton class is exposed.</p>

<pre><code class="language-emlist">class &lt;&lt; obj
  p self  #=&gt; #&gt;   # Singleton Class 「(obj)」
  def a() end   # def obj.a
  def b() end   # def obj.b
end
</code></pre>

<h3 id="multiple-assignment">Multiple Assignment</h3>

<p>With a multiple assignment, several assignments can be done all at once.
The following is the simplest case:</p>

<pre><code class="language-emlist">a, b, c = 1, 2, 3
</code></pre>

<p>It’s exactly the same as the following.</p>

<pre><code class="language-emlist">a = 1
b = 2
c = 3
</code></pre>

<p>Just being concise is not interesting.
in fact, when an array comes in to be mixed,
it becomes something fun for the first time.</p>

<pre><code class="language-emlist">a, b, c = [1, 2, 3]
</code></pre>

<p>This also has the same result as the above.
Furthermore, the right hand side does not need to be a grammatical list or a
literal.
It can also be a variable or a method call.</p>

<pre><code class="language-emlist">tmp = [1, 2, 3]
a, b, c = tmp
ret1, ret2 = some_method()   # some_method might probably return several values
</code></pre>

<p>Precisely speaking it is as follows.
Here we’ll assume <code class="highlighter-rouge">obj</code> is (the object of) the value of the left hand side,</p>

<ol>
  <li>`obj` if it is an array</li>
  <li>if its `to_ary` method is defined, it is used to convert `obj` to an array.</li>
  <li>`[obj]`</li>
</ol>

<p>Decide the right-hand side by following this procedure and perform assignments.
It means the evaluation of the right-hand side and the operation of assignments
are totally independent from each other.</p>

<p>And it goes on, both the left and right hand side can be infinitely nested.</p>

<pre><code class="language-emlist">a, (b, c, d) = [1, [2, 3, 4]]
a, (b, (c, d)) = [1, [2, [3, 4]]]
(a, b), (c, d) = [[1, 2], [3, 4]]
</code></pre>

<p>As the result of the execution of this program,
each line will be `a=1 b=2 c=3 d=4`.</p>

<p>And it goes on. The left hand side can be index or parameter assignments.</p>

<pre><code class="language-emlist">i = 0
arr = []
arr[i], arr[i+1], arr[i+2] = 0, 2, 4
p arr    # [0, 2, 4]

obj.attr0, obj.attr1, obj.attr2 = "a", "b", "c"
</code></pre>

<p>And like with method parameters,
<code class="highlighter-rouge">*</code> can be used to receive in a bundle.</p>

<pre><code class="language-emlist">first, *rest = 0, 1, 2, 3, 4
p first  # 0
p rest   # [1, 2, 3, 4]
</code></pre>

<p>When all of them are used all at once, it’s extremely confusing.</p>

<h4 id="block-parameter-and-multiple-assignment">Block parameter and multiple assignment</h4>

<p>We brushed over block parameters when we were talking about iterators.
But there is a deep relationship between them and multiple assignment.
For instance in the following case.</p>

<pre><code class="language-emlist">array.each do |i|
  ....
end
</code></pre>

<p>Every time when the block is called,
the `yield`ed arguments are multi-assigned to `i`.
Here there’s only one variable on the left hand side, so it does not look like multi assignment.
But if there are two or more variables, it would a little more look like it.
For instance, <code class="highlighter-rouge">Hash#each</code> is an repeated operation on the pairs of keys and values,
so usually we call it like this:</p>

<pre><code class="language-emlist">hash.each do |key, value|
  ....
end
</code></pre>

<p>In this case, each array consist of a key and a value is `yield`ed
from the hash.</p>

<p>Hence we can also does the following thing by using nested multiple assignment.</p>

<pre><code class="language-emlist"># [[key,value],index] are yielded
hash.each_with_index do |(key, value), index|
  ....
end
</code></pre>

<h3 id="alias">`alias`</h3>

<pre><code class="language-emlist">class C
  alias new orig
end
</code></pre>

<p>Defining another method `new` with the same body as the already
defined method `orig`. `alias` are similar to hardlinks in a unix
file system. They are a means of assigning multiple names to one method body.
To say this inversely,
because the names themselves are independent of each other,
even if one method name is overwritten by a subclass method, the
other one still remains with the same behavior.</p>

<h3 id="undef">`undef`</h3>

<pre><code class="language-emlist">class C
  undef method_name
end
</code></pre>

<p>Prohibits the calling of `C#method_name`. It’s not just a simple
revoking of the definition. If there even were a method in the
superclass it would also be forbidden. In other words the method is
exchanged for a sign which says “This method must not be called”.</p>

<p>`undef` is extremely powerful, once it is set it cannot be
deleted from the Ruby level because it is used to cover up contradictions
in the internal structure.
Only one left measure is inheriting and defining a method in the lower class.
Even in that case, calling `super` would cause an error occurring.</p>

<p>The method which corresponds to `unlink` in a file system
is `Module#remove_method`. While defining a class, `self` refers
to that class, we can call it as follows (Remember that `Class` is a
subclass of `Module`.)</p>

<pre><code class="language-emlist">class C
  remove_method(:method_name)
end
</code></pre>

<p>But even with a `remove_method` one cannot cancel the `undef`.
It’s because the sign put up by `undef` prohibits any kind of searches.</p>

<p>((errata: It can be redefined by using `def`))</p>

<h2 id="some-more-small-topics">Some more small topics</h2>

<h3 id="comments">Comments</h3>

<pre><code class="language-emlist"># examples of bad comments.
1 + 1            # compute 1+1.
alias my_id id   # my_id is an alias of id.
</code></pre>

<p>From a `#` to the end of line is a comment.
It doesn’t have a meaning for the program.</p>

<h3 id="embedded-documents">Embedded documents</h3>

<pre><code class="language-emlist">=begin
This is an embedded document.
It's so called because it is embedded in the program.
Plain and simple.
=end
</code></pre>

<p>An embedded document stretches from
an `=begin` outside a string at the beginning of a line
to a `=end`. The interior can be arbitrary.
The program ignores it as a mere comment.</p>

<h3 id="multi-byte-strings">Multi-byte strings</h3>

<p>When the global variable <code class="highlighter-rouge">$KCODE</code> is set to either <code class="highlighter-rouge">EUC</code>, <code class="highlighter-rouge">SJIS</code>
or <code class="highlighter-rouge">UTF8</code>, strings encoded in euc-jp, shift_jis, or utf8 respectively can be
used in a string of a data.</p>

<p>And if the option <code class="highlighter-rouge">-Ke</code>, <code class="highlighter-rouge">-Ks</code> or <code class="highlighter-rouge">-Ku</code> is given to the <code class="highlighter-rouge">ruby</code>
command multibyte strings can be used within the Ruby code.
String literals, regular expressions and even operator names
can contain multibyte characters. Hence it is possible to do
something like this:</p>

<pre><code class="language-emlist">def 表示( arg )
  puts arg
end

表示 'にほんご'
</code></pre>

<p>But I really cannot recommend doing things like that.</p>


    <footer>
      The original work is Copyright © 2002 - 2004 Minero AOKI.
      Translated by Vincent ISAMBART and Clifford Escobar CAOILE
      This work is licensed under a
      <p>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/">Creative Commons Attribution-NonCommercial-ShareAlike2.5 License</a>
      </p>
    </footer>

  </div>
</body>
</html>
