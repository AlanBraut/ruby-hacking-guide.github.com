<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>  Chapter 12: Syntax tree construction |  Ruby Hacking Guide </title>
  <link rel="stylesheet" href="/css/styles.css" />
</head>
<body>

  <div id="main">

    <header>
      <h1><a href="/">Ruby Hacking Guide</a></h1>
    </header>

    <nav role="navigation">
      <ul>
      </ul>
    </nav>

    <h1 id="chapter-12-syntax-tree-construction">Chapter 12: Syntax tree construction</h1>

<h2 id="node">Node</h2>

<h3 id="node-1"><code class="highlighter-rouge">NODE</code></h3>

<p>As I’ve already described, a Ruby program is first converted to a syntax tree.
To be more precise, a syntax tree is a tree structure made of structs called “nodes”.
In <code class="highlighter-rouge">ruby</code>, all nodes are of type <code class="highlighter-rouge">NODE</code>.</p>

<p class="caption">
▼ `NODE`

</p>
<pre><code class="language-longlist"> 128  typedef struct RNode {
 129      unsigned long flags;
 130      char *nd_file;
 131      union {
 132          struct RNode *node;
 133          ID id;
 134          VALUE value;
 135          VALUE (*cfunc)(ANYARGS);
 136          ID *tbl;
 137      } u1;
 138      union {
 139          struct RNode *node;
 140          ID id;
 141          int argc;
 142          VALUE value;
 143      } u2;
 144      union {
 145          struct RNode *node;
 146          ID id;
 147          long state;
 148          struct global_entry *entry;
 149          long cnt;
 150          VALUE value;
 151      } u3;
 152  } NODE;

(node.h)
</code></pre>

<p>Although you might be able to infer from the struct name <code class="highlighter-rouge">RNode</code>, nodes are Ruby objects.
This means the creation and release of nodes are taken care of by the `ruby`’s garbage collector.</p>

<p>Therefore, <code class="highlighter-rouge">flags</code> naturally has the same role as <code class="highlighter-rouge">basic.flags</code> of the object struct.
It means that <code class="highlighter-rouge">T_NODE</code> which is the type of a struct and flags such as <code class="highlighter-rouge">FL_FREEZE</code> are stored in it.
As for <code class="highlighter-rouge">NODE</code>, in addition to these, its node type is stored in <code class="highlighter-rouge">flags</code>.</p>

<p>What does it mean? Since a program could contain various elements
such as <code class="highlighter-rouge">if</code> and <code class="highlighter-rouge">while</code> and <code class="highlighter-rouge">def</code> and so on, there are also various corresponding node types.
The three available union are complicated,
but how these unions are used is decided to only one specific way for each node.
For example, the below table shows the case when it is <code class="highlighter-rouge">NODE_IF</code> that is the node of <code class="highlighter-rouge">if</code>.</p>

<table>
  <thead>
    <tr>
      <th>member</th>
      <th>union member</th>
      <th>role</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">u1</code></td>
      <td><code class="highlighter-rouge">u1.node</code></td>
      <td>the condition expression</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">u2</code></td>
      <td><code class="highlighter-rouge">u2.node</code></td>
      <td>the body of true</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">u3</code></td>
      <td><code class="highlighter-rouge">u3.node</code></td>
      <td>the body of false</td>
    </tr>
  </tbody>
</table>

<p>And, in <code class="highlighter-rouge">node.h</code>, the macros to access each union member are available.</p>

<p class="caption">
▼ the macros to access `NODE`

</p>
<pre><code class="language-longlist"> 166  #define nd_head  u1.node
 167  #define nd_alen  u2.argc
 168  #define nd_next  u3.node
 169
 170  #define nd_cond  u1.node
 171  #define nd_body  u2.node
 172  #define nd_else  u3.node
 173
 174  #define nd_orig  u3.value
                 ：
                 ：

(node.h)
</code></pre>

<p>For example, these are used as follows:</p>

<pre><code class="language-emlist">NODE *head, *tail;
head-&gt;nd_next = tail;    /* head-&gt;u3.node = tail */
</code></pre>

<p>In the source code, it’s almost certain that these macros are used.
A very few exceptions are only the two places where creating <code class="highlighter-rouge">NODE</code> in <code class="highlighter-rouge">parse.y</code>
and where marking <code class="highlighter-rouge">NODE</code> in <code class="highlighter-rouge">gc.c</code>.</p>

<p>By the way, what is the reason why such macros are used?
For one thing, it might be because it’s cumbersome to remember numbers like <code class="highlighter-rouge">u1</code>
that are not meaningful by just themselves.
But what is more important than that is, there should be no problem if the
corresponding number is changed and it’s possible that it will actually be changed.
For example, since a condition clause of <code class="highlighter-rouge">if</code> does not have to be stored in <code class="highlighter-rouge">u1</code>,
someone might want to change it to <code class="highlighter-rouge">u2</code> for some reason. But if <code class="highlighter-rouge">u1</code> is directly used,
he needs to modify a lot of places all over the source codes, it is inconvenient.
Since nodes are all declared as <code class="highlighter-rouge">NODE</code>, it’s hard to find nodes that represent <code class="highlighter-rouge">if</code>.
By preparing the macros to access, this kind of trouble can be avoided
and conversely we can determine the node types from the macros.</p>

<h3 id="node-type">Node Type</h3>

<p>I said that in the <code class="highlighter-rouge">flags</code> of a <code class="highlighter-rouge">NODE</code> struct its node type is stored.
We’ll look at in what form this information is stored.
A node type can be set by <code class="highlighter-rouge">nd_set_type()</code> and obtained by <code class="highlighter-rouge">nd_type()</code>.</p>

<p class="caption">
▼ `nd_type nd_set_type`

</p>
<pre><code class="language-longlist"> 156  #define nd_type(n) (((RNODE(n))-&gt;flags&gt;&gt;FL_USHIFT)&amp;0xff)
 157  #define nd_set_type(n,t) \
 158      RNODE(n)-&gt;flags = ((RNODE(n)-&gt;flags &amp; ~FL_UMASK) \
                             | (((t)&lt;
</code></pre>

<p class="caption">
▼ `FL_USHIFT FL_UMASK`

</p>
<pre><code class="language-longlist"> 418  #define FL_USHIFT    11
 429  #define FL_UMASK  (0xff&lt;
</code></pre>

<p>It won’t be so much trouble if we’ll keep focus on around <code class="highlighter-rouge">nd_type</code>.
Fig.1 shows how it seems like.</p>

<p class="image">
<img src="images/ch_syntree_flagUsage.jpg" alt="(flagUsage)" /><br />
Fig.1: The usage of RNode.flags

</p>
<p>And, since macros cannot be used from debuggers,
the <code class="highlighter-rouge">nodetype()</code> function is also available.</p>

<p class="caption">
▼ `nodetype`

</p>
<pre><code class="language-longlist">4247  static enum node_type
4248  nodetype(node)                  /* for debug */
4249      NODE *node;
4250  {
4251      return (enum node_type)nd_type(node);
4252  }

(parse.y)
</code></pre>

<h3 id="file-name-and-line-number">File Name and Line Number</h3>

<p>The <code class="highlighter-rouge">nd_file</code> of a <code class="highlighter-rouge">NODE</code> holds (the pointer to) the name of the file where the
text that corresponds to this node exists. Since there’s the file name, we
naturally expect that there’s also the line number, but the corresponding member
could not be found around here. Actually, the line number is being embedded to
<code class="highlighter-rouge">flags</code> by the following macro:</p>

<p class="caption">
▼ `nd_line nd_set_line`

</p>
<pre><code class="language-longlist"> 160  #define NODE_LSHIFT (FL_USHIFT+8)
 161  #define NODE_LMASK  (((long)1&lt;&lt;(sizeof(NODE*)*CHAR_BIT-NODE_LSHIFT))-1)
 162  #define nd_line(n) \
          ((unsigned int)((RNODE(n)-&gt;flags &gt;&gt; NODE_LSHIFT) &amp; NODE_LMASK))
 163  #define nd_set_line(n,l) \
 164      RNODE(n)-&gt;flags = ((RNODE(n)-&gt;flags &amp; ~(-1 &lt;&lt; NODE_LSHIFT)) \
                             | (((l)&amp;NODE_LMASK) &lt;&lt; NODE_LSHIFT))

(node.h)
</code></pre>

<p><code class="highlighter-rouge">nd_set_line()</code> is fairly spectacular.
However, as the names suggest, it is certain that <code class="highlighter-rouge">nd_set_line()</code> and <code class="highlighter-rouge">nd_line</code>
works symmetrically. Thus, if we first examine the simpler <code class="highlighter-rouge">nd_line()</code> and grasp
the relationship between the parameters, there’s no need to analyze <code class="highlighter-rouge">nd_set_line()</code>
in the first place.</p>

<p>The first thing is <code class="highlighter-rouge">NODE_LSHIFT</code>, as you can guess from the description of the
node types of the previous section, it is the number of used bits in <code class="highlighter-rouge">flags</code>.
<code class="highlighter-rouge">FL_USHIFT</code> is reserved by system of <code class="highlighter-rouge">ruby</code> (11 bits, <code class="highlighter-rouge">ruby.h</code>), 8 bits are for
its node type.</p>

<p>The next thing is <code class="highlighter-rouge">NODE_LMASK</code>.</p>

<pre><code class="language-emlist">sizeof(NODE*) * CHAR_BIT - NODE_LSHIFT
</code></pre>

<p>This is the number of the rest of the bits.
Let’s assume it is <code class="highlighter-rouge">restbits</code>. This makes the code a lot simpler.</p>

<pre><code class="language-emlist">#define NODE_LMASK  (((long)1 &lt;&lt; restbits) - 1)
</code></pre>

<p>Fig.2 shows what the above code seems to be doing. Note that a borrow occurs
when subtracting 1. We can eventually understand that <code class="highlighter-rouge">NODE_LMASK</code> is a sequence
filled with 1 whose size is the number of the bits that are still available.</p>

<p class="image">
<img src="images/ch_syntree_lmask.jpg" alt="(lmask)" /><br />
Fig.2: `NODE_LMASK`

</p>
<p>Now, let’s look at <code class="highlighter-rouge">nd_line()</code> again.</p>

<pre><code class="language-emlist">(RNODE(n)-&gt;flags &gt;&gt; NODE_LSHIFT) &amp; NODE_LMASK
</code></pre>

<p>By the right shift, the unused space is shifted to the LSB. The bitwise AND
leaves only the unused space. Fig.3 shows how <code class="highlighter-rouge">flags</code> is used. Since <code class="highlighter-rouge">FL_USHIFT</code>
is 11, in 32-bit machine 32-(11+8)=13 bits are available for the line number.</p>

<p class="image">
<img src="images/ch_syntree_flags.jpg" alt="(flags)" /><br />
Fig.3: How `flags` are used at `NODE`

</p>
<p>… This means, if the line numbers becomes beyond 2^13=8192,
the line numbers should wrongly be displayed. Let’s try.</p>

<pre><code class="language-emlist">File.open('overflow.rb', 'w') {|f|
    10000.times { f.puts }
    f.puts 'raise'
}
</code></pre>

<p>With my 686 machine, <code class="highlighter-rouge">ruby overflow.rb</code> properly displayed 1809 as a line number.
I’ve succeeded. However, if you use 64-bit machine, you need to create a little
bigger file in order to successfully fail.</p>

<h3 id="rbnodenewnode"><code class="highlighter-rouge">rb_node_newnode()</code></h3>

<p>Lastly let’s look at the function <code class="highlighter-rouge">rb_node_newnode()</code> that creates a node.</p>

<p class="caption">
▼ `rb_node_newnode()`

</p>
<pre><code class="language-longlist">4228  NODE*
4229  rb_node_newnode(type, a0, a1, a2)
4230      enum node_type type;
4231      NODE *a0, *a1, *a2;
4232  {
4233      NODE *n = (NODE*)rb_newobj();
4234
4235      n-&gt;flags |= T_NODE;
4236      nd_set_type(n, type);
4237      nd_set_line(n, ruby_sourceline);
4238      n-&gt;nd_file = ruby_sourcefile;
4239
4240      n-&gt;u1.node = a0;
4241      n-&gt;u2.node = a1;
4242      n-&gt;u3.node = a2;
4243
4244      return n;
4245  }

(parse.y)
</code></pre>

<p>We’ve seen <code class="highlighter-rouge">rb_newobj()</code> in the Chapter 5: Garbage collection. It is the function to get a
vacant <code class="highlighter-rouge">RVALUE</code>. By attaching the <code class="highlighter-rouge">T_NODE</code> struct-type flag to it,
the initialization as a <code class="highlighter-rouge">VALUE</code> will complete.
Of course, it’s possible that some values that are not of type <code class="highlighter-rouge">NODE*</code> are
passed for <code class="highlighter-rouge">u1 u2 u3</code>, but received as <code class="highlighter-rouge">NODE*</code> for the time being.
Since the syntax trees of <code class="highlighter-rouge">ruby</code> does not contain <code class="highlighter-rouge">double</code> and such,
if the values are received as pointers, it will never be too small in size.</p>

<p>For the rest part, you can forget about the details you’ve learned so far,
and assume <code class="highlighter-rouge">NODE</code> is</p>

<ul>
  <li><code class="highlighter-rouge">flags</code></li>
  <li><code class="highlighter-rouge">nodetype</code></li>
  <li><code class="highlighter-rouge">nd_line</code></li>
  <li><code class="highlighter-rouge">nd_file</code></li>
  <li><code class="highlighter-rouge">u1</code></li>
  <li><code class="highlighter-rouge">u2</code></li>
  <li><code class="highlighter-rouge">u3</code></li>
</ul>

<p>a struct type that has the above seven members.</p>

<h2 id="syntax-tree-construction">Syntax Tree Construction</h2>

<p>The role of the parser is to convert the source code that is a byte sequence to a
syntax tree. Although the grammar passed, it does not finish even half of the task,
so we have to assemble nodes and create a tree.
In this section, we’ll look at the construction process of that syntax tree.</p>

<h3 id="yystype"><code class="highlighter-rouge">YYSTYPE</code></h3>

<p>Essentially this chapter is about actions,
thus <code class="highlighter-rouge">YYSTYPE</code> which is the type of <code class="highlighter-rouge">$$</code> or <code class="highlighter-rouge">$1</code> becomes important.
Let’s look at the <code class="highlighter-rouge">%union</code> of <code class="highlighter-rouge">ruby</code> first.</p>

<p class="caption">
▼ `%union` declaration

</p>
<pre><code class="language-longlist"> 170  %union {
 171      NODE *node;
 172      ID id;
 173      int num;
 174      struct RVarmap *vars;
 175  }

(parse.y)
</code></pre>

<p><code class="highlighter-rouge">struct RVarmap</code> is a struct used by the evaluator and holds a block local variable.
You can tell the rest. The most used one is of course <code class="highlighter-rouge">node</code>.</p>

<h3 id="landscape-with-syntax-trees">Landscape with Syntax Trees</h3>

<p>I mentioned that looking at the fact first is a theory of code reading.
Since what we want to know this time is how the generated syntax tree is,
we should start with looking at the answer (the syntax tree).</p>

<p>It’s also nice using debuggers to observe every time,
but you can visualize the syntax tree more handily
by using the tool <code class="highlighter-rouge">nodedump</code> contained in the attached CD-ROM,
This tool is originally the NodeDump made by <a href="http://www.pragmaticprogrammers.com">Pragmatic Programmers</a>
and remodeled for this book.
The original version shows quite explanatory output,
but this remodeled version deeply and directly displays the appearance of the
syntax tree.</p>

<p>For example, in order to dump the simple expression <code class="highlighter-rouge">m(a)</code>, you can do as follows:</p>

<pre><code class="language-screen">% ruby -rnodedump -e 'm(a)'
NODE_NEWLINE
nd_file = "-e"
nd_nth  = 1
nd_next:
    NODE_FCALL
    nd_mid = 9617 (m)
    nd_args:
        NODE_ARRAY
        nd_alen = 1
        nd_head:
            NODE_VCALL
            nd_mid = 9625 (a)
        nd_next = (null)
</code></pre>

<p>The <code class="highlighter-rouge">-r</code> option is used to specify the library to be load,
and the <code class="highlighter-rouge">-e</code> is used to pass a program.
Then, the syntax tree expression of the program will be dumped.</p>

<p>I’ll briefly explain about how to see the content.
<code class="highlighter-rouge">NODE_NEWLINE</code> and <code class="highlighter-rouge">NODE_FCALL</code> and such are the node types.
What are written at the same indent level of each node are the contents of its node members.
For example, the root is <code class="highlighter-rouge">NODE_NEWLINE</code>, and it has the three members:
<code class="highlighter-rouge">nd_file nd_nth nd_next</code>. <code class="highlighter-rouge">nd_file</code> points to the <code class="highlighter-rouge">"-e"</code> string of C,
and <code class="highlighter-rouge">ng_nth</code> points to the 1 integer of C, and <code class="highlighter-rouge">nd_next</code> holds the next node <code class="highlighter-rouge">NODE_CALL</code>.
But since these explanation in text are probably not intuitive,
I recommend you to also check Fig.4 at the same time.</p>

<p class="image">
<img src="images/ch_syntree_stree.jpg" alt="(stree)" /><br />
Fig.4: Syntax Tree

</p>
<p>I’ll explain the meaning of each node. <code class="highlighter-rouge">NODE_CALL</code> is a Function CALL.
<code class="highlighter-rouge">NODE_ARRAY</code> is as its name suggests the node of array, and here it expresses
the list of arguments. <code class="highlighter-rouge">NODE_VCALL</code> is a Variable or CALL, a reference to
undefined local variable will become this.</p>

<p>Then, what is <code class="highlighter-rouge">NODE_NEWLINE</code> ? This is the node to join the name of the currently
executed file and the line number at runtime and is set for each <code class="highlighter-rouge">stmt</code>.
Therefore, when only thinking about the meaning of the execution, this node can
be ignored. When you <code class="highlighter-rouge">require</code> <code class="highlighter-rouge">nodedump-short</code> instead of <code class="highlighter-rouge">nodedump</code>,
distractions like <code class="highlighter-rouge">NODE_NEWLINE</code> are left out in the first place. Since it is
easier to see if it is simple, <code class="highlighter-rouge">nodedump-short</code> will be used later on except for
when particularly written.</p>

<p>Now, we’ll look at the three type of composing elements in order to grasp how
the whole syntax tree is. The first one is the leaves of a syntax tree. Next,
we’ll look at expressions that are combinations of that leaves, this means they
are branches of a syntax tree.
The last one is the list to list up the statements that is the trunk of a syntax
tree in other words.</p>

<h3 id="leaf">Leaf</h3>

<p>First, let’s start with the edges that are the leaves of the syntax tree.
Literals and variable references and so on, among the rules, they are what
belong to <code class="highlighter-rouge">primary</code> and are particularly simple even among the <code class="highlighter-rouge">primary</code> rules.</p>

<pre><code class="language-screen">% ruby -rnodedump-short -e '1'
NODE_LIT
nd_lit = 1:Fixnum
</code></pre>

<p>1 as a numeric value. There’s not any twist. However, notice that what is
stored in the node is not 1 of C but 1 of Ruby (1 of <code class="highlighter-rouge">Fixnum</code>). This is because …</p>

<pre><code class="language-screen">% ruby -rnodedump-short -e ':sym'
NODE_LIT
nd_lit = 9617:Symbol
</code></pre>

<p>This way, <code class="highlighter-rouge">Symbol</code> is represented by the same <code class="highlighter-rouge">NODE_LIT</code> when it becomes a syntax tree.
As the above example, <code class="highlighter-rouge">VALUE</code> is always stored in <code class="highlighter-rouge">nd_lit</code> so it can be handled
completely in the same way whether it is a <code class="highlighter-rouge">Symbol</code> or a <code class="highlighter-rouge">Fixnum</code> when executing.
In this way, all we need to do when dealing with it are retrieving the value
in <code class="highlighter-rouge">nd_lit</code> and returning it. Since we create a syntax tree in order to execute it,
designing it so that it becomes convenient when executing is the right thing to do.</p>

<pre><code class="language-screen">% ruby -rnodedump-short -e '"a"'
NODE_STR
nd_lit = "a":String
</code></pre>

<p>A string. This is also a Ruby string.
String literals are copied when actually used.</p>

<pre><code class="language-screen">% ruby -rnodedump -e '[0,1]'
NODE_NEWLINE
nd_file = "-e"
nd_nth  = 1
nd_next:
    NODE_ARRAY
    nd_alen = 2
    nd_head:
        NODE_LIT
        nd_lit = 0:Fixnum
    nd_next:
        NODE_ARRAY
        nd_alen = 1
        nd_head:
            NODE_LIT
            nd_lit = 1:Fixnum
        nd_next = (null)
</code></pre>

<p>Array. I can’t say this is a leaf, but let’s allow this to be here because it’s
also a literal. It seems like a list of <code class="highlighter-rouge">NODE_ARRAY</code> hung with each element node.
The reason why only in this case I didn’t use <code class="highlighter-rouge">nodedump-short</code> is …
you will understand after finishing to read this section.</p>

<h3 id="branch">Branch</h3>

<p>Next, we’ll focus on “combinations” that are branches.
<code class="highlighter-rouge">if</code> will be taken as an example.</p>

<h4 id="if"><code class="highlighter-rouge">if</code></h4>

<p>I feel like <code class="highlighter-rouge">if</code> is always used as an example, that’s because its structure is
simple and there’s not any reader who don’t know about <code class="highlighter-rouge">if</code>, so it is convenient
for writers.</p>

<p>Anyway, this is an example of <code class="highlighter-rouge">if</code>.
For example, let’s convert this code to a syntax tree.</p>

<p class="caption">
▼The Source Program

</p>
<pre><code class="language-longlist">if true
  'true expr'
else
  'false expr'
end
</code></pre>

<p class="caption">
▼Its syntax tree expression

</p>
<pre><code class="language-longlist">NODE_IF
nd_cond:
    NODE_TRUE
nd_body:
    NODE_STR
    nd_lit = "true expr":String
nd_else:
    NODE_STR
    nd_lit = "false expr":String
</code></pre>

<p>Here, the previously described <code class="highlighter-rouge">nodedump-short</code> is used, so <code class="highlighter-rouge">NODE_NEWLINE</code>
disappeared. <code class="highlighter-rouge">nd_cond</code> is the condition, <code class="highlighter-rouge">nd_body</code> is the body of the true case,
<code class="highlighter-rouge">nd_else</code> is the body of the false case.</p>

<p>Then, let’s look at the code to build this.</p>

<p class="caption">
▼ `if` rule

</p>
<pre><code class="language-longlist">1373                  | kIF expr_value then
1374                    compstmt
1375                    if_tail
1376                    kEND
1377                      {
1378                          $$ = NEW_IF(cond($2), $4, $5);
1379                          fixpos($$, $2);
1380                      }

(parse.y)
</code></pre>

<p>It seems that <code class="highlighter-rouge">NEW_IF()</code> is the macro to create <code class="highlighter-rouge">NODE_IF</code>. Among the values of
the symbols, <code class="highlighter-rouge">$2 $4 $5</code> are used, thus the correspondences between the symbols
of the rule and <code class="highlighter-rouge">$n</code> are:</p>

<pre><code class="language-emlist">kIF    expr_value  then  compstmt  if_tail  kEND
 $1          $2      $3        $4       $5    $6
NEW_IF(expr_value,       compstmt, if_tail)
</code></pre>

<p>this way. In other words, <code class="highlighter-rouge">expr_value</code> is the condition expression, <code class="highlighter-rouge">compstmt</code>
(<code class="highlighter-rouge">$4</code>) is the case of true, <code class="highlighter-rouge">if_tail</code> is the case of false.</p>

<p>On the other hand, the macros to create nodes are all named <code class="highlighter-rouge">NEW_xxxx</code>, and they
are defined <code class="highlighter-rouge">node.h</code>. Let’s look at <code class="highlighter-rouge">NEW_IF()</code>.</p>

<p class="caption">
▼ `NEW_IF()`

</p>
<pre><code class="language-longlist"> 243  #define NEW_IF(c,t,e) rb_node_newnode(NODE_IF,c,t,e)

(node.h)
</code></pre>

<p>As for the parameters,
it seems that <code class="highlighter-rouge">c</code> represents condition, <code class="highlighter-rouge">t</code> represents then, and <code class="highlighter-rouge">e</code> represents
else respectively. As described at the previous section, the order of
members of a node is not so meaningful, so you don’t need to be careful about
parameter names in this kind of place.</p>

<p>And, the <code class="highlighter-rouge">code()</code> which processes the node of the condition expression in the
action is a semantic analysis function. This will be described later.</p>

<p>Additionally, <code class="highlighter-rouge">fixpos()</code> corrects the line number. <code class="highlighter-rouge">NODE</code> is initialized with
the file name and the line number of the time when it is “created”. However,
for instance, the code of <code class="highlighter-rouge">if</code> should already be parsed by <code class="highlighter-rouge">end</code> by the time
when creating <code class="highlighter-rouge">NODE_IF</code>. Thus, the line number would go wrong if it remains
untouched. Therefore, it needs to be corrected by <code class="highlighter-rouge">fixpos()</code>.</p>

<pre><code class="language-emlist">fixpos(dest, src)
</code></pre>

<p>This way, the line number of the node <code class="highlighter-rouge">dest</code> is set to the one of the node <code class="highlighter-rouge">src</code>.
As for <code class="highlighter-rouge">if</code>, the line number of the condition expression becomes the line number
of the whole <code class="highlighter-rouge">if</code> expression.</p>

<h4 id="elsif"><code class="highlighter-rouge">elsif</code></h4>

<p>Subsequently, let’s look at the rule of <code class="highlighter-rouge">if_tail</code>.</p>

<p class="caption">
▼ `if_tail`

</p>
<pre><code class="language-longlist">1543  if_tail         : opt_else
1544                  | kELSIF expr_value then
1545                    compstmt
1546                    if_tail
1547                      {
1548                          $$ = NEW_IF(cond($2), $4, $5);
1549                          fixpos($$, $2);
1550                      }

1553  opt_else        : none
1554                  | kELSE compstmt
1555                      {
1556                          $$ = $2;
1557                      }

(parse.y)
</code></pre>

<p>First, this rule expresses “a list ends with <code class="highlighter-rouge">opt_else</code> after zero or more
number of <code class="highlighter-rouge">elsif</code> clauses”. That’s because, <code class="highlighter-rouge">if_tail</code> appears again and again
while <code class="highlighter-rouge">elsif</code> continues, it disappears when <code class="highlighter-rouge">opt_else</code> comes in. We can
understand this by extracting arbitrary times.</p>

<pre><code class="language-emlist">if_tail: kELSIF .... if_tail
if_tail: kELSIF .... kELSIF .... if_tail
if_tail: kELSIF .... kELSIF .... kELSIF .... if_tail
if_tail: kELSIF .... kELSIF .... kELSIF .... opt_else
if_tail: kELSIF .... kELSIF .... kELSIF .... kELSE compstmt
</code></pre>

<p>Next, let’s focus on the actions, surprisingly, <code class="highlighter-rouge">elsif</code> uses the same <code class="highlighter-rouge">NEW_IF()</code> as <code class="highlighter-rouge">if</code>.
It means, the below two programs will lose the difference after they become syntax trees.</p>

<pre><code class="language-emlist">if cond1                  if cond1
  body1                     body1
elsif cond2               else
  body2                     if cond2
elsif cond3                   body2
  body3                     else
else                          if cond3
  body4                         body3
end                           else
                                body4
                              end
                            end
                          end
</code></pre>

<p>Come to think of it, in C language and such, there’s no distinction between
the two also at the syntax level. Thus this might be a matter of course.
Alternatively, the conditional operator (<code class="highlighter-rouge">a?b:c</code>) becomes indistinguishable
from <code class="highlighter-rouge">if</code> statement after they become syntax trees.</p>

<p>The precedences was very meaningful when it was in the context of grammar,
but they become unnecessary any more because the structure of a syntax tree
contains that information. And, the difference in appearance such as <code class="highlighter-rouge">if</code> and
the conditional operator become completely meaningless,
its meaning (its behavior) only matters.
Therefore, there’s perfectly no problem if <code class="highlighter-rouge">if</code> and the conditional operator
are the same in its syntax tree expression.</p>

<p>I’ll introduce a few more examples. <code class="highlighter-rouge">add</code> and <code class="highlighter-rouge">&amp;&amp;</code> become the same.
<code class="highlighter-rouge">or</code> and <code class="highlighter-rouge">||</code> are also equal to each other. <code class="highlighter-rouge">not</code> and <code class="highlighter-rouge">!</code>, <code class="highlighter-rouge">if</code> and modifier <code class="highlighter-rouge">if</code>,
and so on. These pairs also become equal to each other.</p>

<h4 id="left-recursive-and-right-recursive">Left Recursive and Right Recursive</h4>

<p>By the way, the symbol of a list was always written at the left side when expressing a list
in Chapter 9: yacc crash course. However, have you noticed it becomes opposite in <code class="highlighter-rouge">if_tail</code> ?
I’ll show only the crucial part again.</p>

<pre><code class="language-emlist">if_tail: opt_else
       | kELSIF ... if_tail
</code></pre>

<p>Surely, it is opposite of the previous examples. <code class="highlighter-rouge">if_tail</code> which is the symbol
of a list is at the right side.</p>

<p>In fact, there’s another established way of expressing lists,</p>

<pre><code class="language-emlist">list: END_ITEM
    | ITEM list
</code></pre>

<p>when you write in this way, it becomes the list that contains continuous zero
or more number of <code class="highlighter-rouge">ITEM</code> and ends with <code class="highlighter-rouge">END_ITEM</code>.</p>

<p>As an expression of a list, whichever is used it does not create a so much difference,
but the way that the actions are executed is fatally different.
With the form that <code class="highlighter-rouge">list</code> is written at the right, the actions are sequentially
executed from the last <code class="highlighter-rouge">ITEM</code>. We’ve already learned about the behavior of the
stack of when <code class="highlighter-rouge">list</code> is at the left,
so let’s try the case that <code class="highlighter-rouge">list</code> is at the right.
The input is 4 <code class="highlighter-rouge">ITEM</code> s and <code class="highlighter-rouge">END_ITEM</code>.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td>empty at first</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ITEM</code></td>
      <td>shift <code class="highlighter-rouge">ITEM</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ITEM ITEM</code></td>
      <td>shift <code class="highlighter-rouge">ITEM</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ITEM ITEM ITEM</code></td>
      <td>shift <code class="highlighter-rouge">ITEM</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ITEM ITEM ITEM ITEM</code></td>
      <td>shift <code class="highlighter-rouge">ITEM</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ITEM ITEM ITEM ITEM END_ITEM</code></td>
      <td>shift <code class="highlighter-rouge">END_ITEM</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ITEM ITEM ITEM ITEM list</code></td>
      <td>reduce <code class="highlighter-rouge">END_ITEM</code> to <code class="highlighter-rouge">list</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ITEM ITEM ITEM list</code></td>
      <td>reduce <code class="highlighter-rouge">ITEM list</code> to <code class="highlighter-rouge">list</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ITEM ITEM list</code></td>
      <td>reduce <code class="highlighter-rouge">ITEM list</code> to <code class="highlighter-rouge">list</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ITEM list</code></td>
      <td>reduce <code class="highlighter-rouge">ITEM list</code> to <code class="highlighter-rouge">list</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">list</code></td>
      <td>reduce <code class="highlighter-rouge">ITEM list</code> to <code class="highlighter-rouge">list</code></td>
    </tr>
    <tr>
      <td> </td>
      <td>accept.</td>
    </tr>
  </tbody>
</table>

<p>When <code class="highlighter-rouge">list</code> was at the left, shifts and reductions were done in turns.
This time, as you see, there are continuous shifts and continuous reductions.</p>

<p>The reason why <code class="highlighter-rouge">if_tail</code> places “<code class="highlighter-rouge">list</code> at the right” is to create a syntax tree
from the bottom up. When creating from the bottom up, the node of <code class="highlighter-rouge">if</code> will be
left in hand in the end. But if defining <code class="highlighter-rouge">if_tail</code> by placing “<code class="highlighter-rouge">list</code> at the left”,
in order to eventually leave the node of <code class="highlighter-rouge">if</code> in hand, it needs to traverse all
links of the <code class="highlighter-rouge">elsif</code> and every time <code class="highlighter-rouge">elsif</code>
is found add it to the end. This is cumbersome. And, slow.
Thus, <code class="highlighter-rouge">if_tail</code> is constructed in the “<code class="highlighter-rouge">list</code> at the right” manner.</p>

<p>Finally, the meaning of the headline is, in grammar terms,
“the left is <code class="highlighter-rouge">list</code>” is called left-recursive,
“the right is <code class="highlighter-rouge">list</code>” is called right-recursive.
These terms are used mainly when reading papers about processing grammars or
writing a book of <code class="highlighter-rouge">yacc</code>.</p>

<h3 id="trunk">Trunk</h3>

<p>Leaf, branch, and finally, it’s trunk.
Let’s look at how the list of statements are joined.</p>

<p class="caption">
▼The Source Program

</p>
<pre><code class="language-longlist">7
8
9
</code></pre>

<p>The dump of the corresponding syntax tree is shown below.
This is not <code class="highlighter-rouge">nodedump-short</code> but in the perfect form.</p>

<p class="caption">
▼Its Syntax Tree

</p>
<pre><code class="language-longlist">NODE_BLOCK
nd_head:
    NODE_NEWLINE
    nd_file = "multistmt"
    nd_nth  = 1
    nd_next:
        NODE_LIT
        nd_lit = 7:Fixnum
nd_next:
    NODE_BLOCK
    nd_head:
        NODE_NEWLINE
        nd_file = "multistmt"
        nd_nth  = 2
        nd_next:
            NODE_LIT
            nd_lit = 8:Fixnum
    nd_next:
        NODE_BLOCK
        nd_head:
            NODE_NEWLINE
            nd_file = "multistmt"
            nd_nth  = 3
            nd_next:
                NODE_LIT
                nd_lit = 9:Fixnum
        nd_next = (null)
</code></pre>

<p>We can see the list of <code class="highlighter-rouge">NODE_BLOCK</code> is created and <code class="highlighter-rouge">NODE_NEWLINE</code> are attached
as headers. (Fig.5)</p>

<p class="image">
<img src="images/ch_syntree_blocklist.jpg" alt="(blocklist)" /><br />
Fig.5: `NODE_BLOCK` and `NODE_NEWLINE`

</p>
<p>It means, for each statement (<code class="highlighter-rouge">stmt</code>) <code class="highlighter-rouge">NODE_NEWLINE</code> is attached,
and when they are multiple, it will be a list of <code class="highlighter-rouge">NODE_BLOCK</code>.
Let’s also see the code.</p>

<p class="caption">
▼ `stmts`

</p>
<pre><code class="language-longlist"> 354  stmts           : none
 355                  | stmt
 356                      {
 357                          $$ = newline_node($1);
 358                      }
 359                  | stmts terms stmt
 360                      {
 361                          $$ = block_append($1, newline_node($3));
 362                      }

(parse.y)
</code></pre>

<p><code class="highlighter-rouge">newline_node()</code> caps <code class="highlighter-rouge">NODE_NEWLINE</code>, <code class="highlighter-rouge">block_append()</code> appends it to the list.
It’s straightforward.
Let’s look at the content only of the <code class="highlighter-rouge">block_append()</code>.</p>

<h4 id="blockappend"><code class="highlighter-rouge">block_append()</code></h4>

<p>It this function, the error checks are in the very middle and obstructive.
Thus I’ll show the code without that part.</p>

<p class="caption">
▼ `block_append()` (omitted)

</p>
<pre><code class="language-longlist">4285  static NODE*
4286  block_append(head, tail)
4287      NODE *head, *tail;
4288  {
4289      NODE *end;
4290
4291      if (tail == 0) return head;
4292      if (head == 0) return tail;
4293
4294      if (nd_type(head) != NODE_BLOCK) {
4295          end = NEW_BLOCK(head);
4296          end-&gt;nd_end = end;    /*（A-1）*/
4297          fixpos(end, head);
4298          head = end;
4299      }
4300      else {
4301          end = head-&gt;nd_end;   /*（A-2）*/
4302      }

          /* ……omitted…… */

4325      if (nd_type(tail) != NODE_BLOCK) {
4326          tail = NEW_BLOCK(tail);
4327          tail-&gt;nd_end = tail;
4328      }
4329      end-&gt;nd_next = tail;
4330      head-&gt;nd_end = tail-&gt;nd_end;   /*（A-3）*/
4331      return head;
4332  }

(parse.y)
</code></pre>

<p>According to the previous syntax tree dump, <code class="highlighter-rouge">NEW_BLOCK</code> was a linked list uses <code class="highlighter-rouge">nd_next</code>.
Being aware of it while reading, it can be read “if either <code class="highlighter-rouge">head</code> or <code class="highlighter-rouge">tail</code> is not <code class="highlighter-rouge">NODE_BLOCK</code>,
wrap it with <code class="highlighter-rouge">NODE_BLOCK</code> and join the lists each other.”</p>

<p>Additionally, on (A-1~3), the <code class="highlighter-rouge">nd_end</code> of the <code class="highlighter-rouge">NODE_BLOCK</code> of the head of the
list always points to the <code class="highlighter-rouge">NODE_BLOCK</code> of the tail of the list. This is probably
because in this way we don’t have to traverse all elements when adding an
element to the tail (Fig.6).
Conversely speaking, when you need to add elements later, <code class="highlighter-rouge">NODE_BLOCK</code> is suitable.</p>

<p class="image">
<img src="images/ch_syntree_append.jpg" alt="(append)" /><br />
Fig.6: Appending is easy.

</p>
<p>### The two types of lists</p>

<p>Now, I’ve explained the outline so far.
Because the structure of syntax tree will also appear in Part 3 in large amounts,
we won’t go further as long as we are in Part 2.
But before ending, there’s one more thing I’d like to talk about.
It is about the two general-purpose lists.</p>

<p>The two general-purpose lists mean <code class="highlighter-rouge">BLOCK</code> and <code class="highlighter-rouge">LIST</code>.
<code class="highlighter-rouge">BLOCK</code> is, as previously described, a linked list of <code class="highlighter-rouge">NODE_BLOCK</code> to join the statements.
<code class="highlighter-rouge">LIST</code> is, although it is called <code class="highlighter-rouge">LIST</code>, a list of <code class="highlighter-rouge">NODE_ARRAY</code>.
This is what is used for array literals.
<code class="highlighter-rouge">LIST</code> is used to store the arguments of a method or the list of multiple assignments.</p>

<p>As for the difference between the two lists,
looking at the usage of the nodes is helpful to understand.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">NODE_BLOCK</code></td>
      <td><code class="highlighter-rouge">nd_head</code></td>
      <td>holding an element</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="highlighter-rouge">nd_end</code></td>
      <td>pointing to the <code class="highlighter-rouge">NODE_BLOCK</code> of the end of the list</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="highlighter-rouge">nd_next</code></td>
      <td>pointing to the next <code class="highlighter-rouge">NODE_BLOCK</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">NODE_ARRAY</code></td>
      <td><code class="highlighter-rouge">nd_head</code></td>
      <td>holding an element</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="highlighter-rouge">nd_alen</code></td>
      <td>the length of the list that follows this node</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="highlighter-rouge">nd_next</code></td>
      <td>pointing to the next <code class="highlighter-rouge">NODE_ARRAY</code></td>
    </tr>
  </tbody>
</table>

<p>The usage differs only in the second elements that are <code class="highlighter-rouge">nd_end</code> and <code class="highlighter-rouge">nd_alen</code>.
And this is exactly the significance of the existence of each type of the two nodes.
Since its size can be stored in <code class="highlighter-rouge">NODE_ARRAY</code>, we use an <code class="highlighter-rouge">ARRAY</code> list
when the size of the list will frequently be required.
Otherwise, we use a <code class="highlighter-rouge">BLOCK</code> list that is very fast to join.
I don’t describe this topic in details because the codes that use them is
necessary to understand the significance but not shown here,
but when the codes appear in Part 3,
I’d like you to recall this and think “Oh, this uses the length”.</p>

<h2 id="semantic-analysis">Semantic Analysis</h2>

<p>As I briefly mentioned at the beginning of Part 2, there are two types of analysis
that are appearance analysis and semantic analysis.
The appearance analysis is mostly done by <code class="highlighter-rouge">yacc</code>, the rest is doing the semantic
analysis inside actions.</p>

<h3 id="errors-inside-actions">Errors inside actions</h3>

<p>What does the semantic analysis precisely mean?
For example, there are type checks in a language that has types.
Alternatively, check if variables with the same name are not defined multiple times,
and check if variables are not used before their definitions,
and check if the procedure being used is defined,
and check if <code class="highlighter-rouge">return</code> is not used outside of procedures, and so on.
These are part of the semantic analysis.</p>

<p>What kind of semantic analysis is done in the current <code class="highlighter-rouge">ruby</code> ?
Since the error checks occupies almost all of semantic analysis in <code class="highlighter-rouge">ruby</code>,
searching the places where generating errors seems a good way.
In a parser of <code class="highlighter-rouge">yacc</code>, <code class="highlighter-rouge">yyerror()</code> is supposed to be called when an error occurs.
Conversely speaking, there’s an error where <code class="highlighter-rouge">yyerror()</code> exists.
So, I made a list of the places where calling <code class="highlighter-rouge">yyerror()</code> inside the actions.</p>

<ul>
  <li>an expression not having its value (void value expression) at a place where a value is required</li>
  <li>an <code class="highlighter-rouge">alias</code> of <code class="highlighter-rouge">$n</code></li>
  <li><code class="highlighter-rouge">BEGIN</code> inside of a method</li>
  <li><code class="highlighter-rouge">END</code> inside of a method</li>
  <li><code class="highlighter-rouge">return</code> outside of methods</li>
  <li>a local variable at a place where constant is required</li>
  <li>a <code class="highlighter-rouge">class</code> statement inside of a method</li>
  <li>an invalid parameter variable (<code class="highlighter-rouge">$gvar</code> and <code class="highlighter-rouge">CONST</code> and such)</li>
  <li>parameters with the same name appear twice</li>
  <li>an invalid receiver of a singleton method (<code class="highlighter-rouge">def ().method</code> and such)</li>
  <li>a singleton method definition on literals</li>
  <li>an odd number of a list for hash literals</li>
  <li>an assignment to <code class="highlighter-rouge">self/nil/true/false/__FILE__/__LINE__</code></li>
  <li>a constant assignment inside of a method</li>
  <li>a multiple assignment inside of a conditional expression</li>
</ul>

<p>These checks can roughly be categorized by each purpose as follows:</p>

<ul>
  <li>for the better error message</li>
  <li>in order not to make the rule too complex</li>
  <li>the others (pure semantic analysis)</li>
</ul>

<p>For example, “<code class="highlighter-rouge">return</code> outside of a method” is a check in order not to make the
rule too complex. Since this error is a problem of the structure, it can be
dealt with by grammar.
For example, it’s possible by defining the rules separately for both inside and
outside of methods and making the list of all what are allowed and what are not
allowed respectively. But this is in any way cumbersome and rejecting it in an
action is far more concise.</p>

<p>And, “an assignment to <code class="highlighter-rouge">self</code>” seems a check for the better error message.
In comparison to “<code class="highlighter-rouge">return</code> outside of methods”, rejecting it by grammar is much easier,
but if it is rejected by the parser, the output would be just <code class="highlighter-rouge">"parse error"</code>.
Comparing to it, the current</p>

<pre><code class="language-screen">% ruby -e 'self = 1'
-e:1: Can't change the value of self
self = 1
      ^
</code></pre>

<p>this error is much more friendly.</p>

<p>Of course, we can not always say that an arbitrary rule is exactly “for this purpose”.
For example, as for “<code class="highlighter-rouge">return</code> outside of methods”,
this can also be considered that this is a check “for the better error message”.
The purposes are overlapping each other.</p>

<p>Now, the problem is “a pure semantic analysis”,
in Ruby there are few things belong to this category.
In the case of a typed language, the type analysis is a big event, but
because variables are not typed in Ruby, it is meaningless.
What is standing out instead is the cheek of an expression that has its value.</p>

<p>To put “having its value” precisely,
it is “you can obtain a value as a result of evaluating it”.
<code class="highlighter-rouge">return</code> and <code class="highlighter-rouge">break</code> do not have values by themselves. Of course, a value is
passed to the place where <code class="highlighter-rouge">return</code> to, but not any values are left at the place
where <code class="highlighter-rouge">return</code> is written.
Therefore, for example, the next expression is odd,</p>

<pre><code class="language-emlist">i = return(1)
</code></pre>

<p>Since this kind of expressions are clearly due to misunderstanding or simple mistakes,
it’s better to reject when compiling.
Next, we’ll look at <code class="highlighter-rouge">value_expr</code> which is one of the functions to check if it takes a value.</p>

<h3 id="valueexpr"><code class="highlighter-rouge">value_expr()</code></h3>

<p><code class="highlighter-rouge">value_expr()</code> is the function to check if it is an <code class="highlighter-rouge">expr</code> that has a value.</p>

<p class="caption">
▼ `value_expr()`

</p>
<pre><code class="language-longlist">4754  static int
4755  value_expr(node)
4756      NODE *node;
4757  {
4758      while (node) {
4759          switch (nd_type(node)) {
4760            case NODE_CLASS:
4761            case NODE_MODULE:
4762            case NODE_DEFN:
4763            case NODE_DEFS:
4764              rb_warning("void value expression");
4765              return Qfalse;
4766
4767            case NODE_RETURN:
4768            case NODE_BREAK:
4769            case NODE_NEXT:
4770            case NODE_REDO:
4771            case NODE_RETRY:
4772              yyerror("void value expression");
4773              /* or "control never reach"? */
4774              return Qfalse;
4775
4776            case NODE_BLOCK:
4777              while (node-&gt;nd_next) {
4778                  node = node-&gt;nd_next;
4779              }
4780              node = node-&gt;nd_head;
4781              break;
4782
4783            case NODE_BEGIN:
4784              node = node-&gt;nd_body;
4785              break;
4786
4787            case NODE_IF:
4788              if (!value_expr(node-&gt;nd_body)) return Qfalse;
4789              node = node-&gt;nd_else;
4790              break;
4791
4792            case NODE_AND:
4793            case NODE_OR:
4794              node = node-&gt;nd_2nd;
4795              break;
4796
4797            case NODE_NEWLINE:
4798              node = node-&gt;nd_next;
4799              break;
4800
4801            default:
4802              return Qtrue;
4803          }
4804      }
4805
4806      return Qtrue;
4807  }

(parse.y)
</code></pre>

<h4 id="algorithm">Algorithm</h4>

<p>Summary: It sequentially checks the nodes of the tree, if it hits “an expression
certainly not having its value”, it means the tree does not have any value.
Then it warns about that by using <code class="highlighter-rouge">rb_warning()</code> and return <code class="highlighter-rouge">Qfalse</code>. If it
finishes to traverse the entire tree without hitting any “an expression not
having its value”, it means the tree does have a value. Thus it returns <code class="highlighter-rouge">Qtrue</code>.</p>

<p>Here, notice that it does not always need to check the whole tree.
For example, let’s assume <code class="highlighter-rouge">value_expr()</code> is called on the argument of a method.
Here:</p>

<p class="caption">
▼ check the value of `arg` by using `value_expr()`

</p>
<pre><code class="language-longlist">1055  arg_value       : arg
1056                      {
1057                          value_expr($1);
1058                          $$ = $1;
1059                      }

(parse.y)
</code></pre>

<p>Inside of this argument <code class="highlighter-rouge">$1</code>, there can also be other nesting method calls again.
But, the argument of the inside method must have been already checked with
<code class="highlighter-rouge">value_expr()</code>, so you don’t have to check it again.</p>

<p>Let’s think more generally. Assume an arbitrary grammar element <code class="highlighter-rouge">A</code> exists,
and assume <code class="highlighter-rouge">value_expr()</code> is called against its all composing elements,
the necessity to check the element <code class="highlighter-rouge">A</code> again would disappear.</p>

<p>Then, for example, how is <code class="highlighter-rouge">if</code> ? Is it possible to be handled as if <code class="highlighter-rouge">value_expr()</code>
has already called for all elements? If I put only the bottom line, it isn’t.
That is because, since <code class="highlighter-rouge">if</code> is a statement (which does not use a value),
the main body should not have to return a value.
For example, in the next case:</p>

<pre><code class="language-emlist">def method
  if true
    return 1
  else
    return 2
  end
  5
end
</code></pre>

<p>This <code class="highlighter-rouge">if</code> statement does not need a value.<br />
But in the next case, its value is necessary.</p>

<pre><code class="language-emlist">def method( arg )
  tmp = if arg
        then 3
        else 98
        end
  tmp * tmp / 3.5
end
</code></pre>

<p>So, in this case, the <code class="highlighter-rouge">if</code> statement must be checked when checking the entire
assignment expression. This kind of things are laid out in the <code class="highlighter-rouge">switch</code>
statement of <code class="highlighter-rouge">value_expr()</code>.</p>

<h4 id="removing-tail-recursion">Removing Tail Recursion</h4>

<p>By the way, when looking over the whole <code class="highlighter-rouge">value_expr</code>, we can see that there’s
the following pattern appears frequently:</p>

<pre><code class="language-emlist">while (node) {
    switch (nd_type(node)) {
      case NODE_XXXX:
        node = node-&gt;nd_xxxx;
        break;
         ：
         ：
    }
}
</code></pre>

<p>This expression will also carry the same meaning after being modified to the below:</p>

<pre><code class="language-emlist">return value_expr(node-&gt;nd_xxxx)
</code></pre>

<p>A code like this which does a recursive call just before <code class="highlighter-rouge">return</code> is called a
tail recursion. It is known that this can generally be converted to <code class="highlighter-rouge">goto</code>.
This method is often used when optimizing.
As for Scheme, it is defined in specifications that tail recursions must be
removed by language processors. This is because recursions are often used
instead of loops in Lisp-like languages.</p>

<p>However, be careful that tail recursions are only when “calling just before <code class="highlighter-rouge">return</code>”.
For example, take a look at the <code class="highlighter-rouge">NODE_IF</code> of <code class="highlighter-rouge">value_expr()</code>,</p>

<pre><code class="language-emlist">if (!value_expr(node-&gt;nd_body)) return Qfalse;
node = node-&gt;nd_else;
break;
</code></pre>

<p>As shown above, the first time is a recursive call.
Rewriting this to the form of using <code class="highlighter-rouge">return</code>,</p>

<pre><code class="language-emlist">return value_expr(node-&gt;nd_body) &amp;&amp; value_expr(node-&gt;nd_else);
</code></pre>

<p>If the left <code class="highlighter-rouge">value_expr()</code> is false, the right <code class="highlighter-rouge">value_expr()</code> is also executed.
In this case, the left <code class="highlighter-rouge">value_expr()</code> is not “just before” <code class="highlighter-rouge">return</code>.
Therefore, it is not a tail recursion.
Hence, it can’t be extracted to <code class="highlighter-rouge">goto</code>.</p>

<h3 id="the-whole-picture-of-the-value-check">The whole picture of the value check</h3>

<p>As for value checks, we won’t read the functions further.
You might think it’s too early, but all of the other functions are, as the same
as <code class="highlighter-rouge">value_expr()</code>, step-by-step one-by-one only traversing and checking nodes,
so they are completely not interesting.
However, I’d like to cover the whole picture at least,
so I finish this section by just showing the call graph of the relevant functions (Fig.7).</p>

<p class="image">
<img src="images/ch_syntree_callgraph.jpg" alt="(callgraph)" /><br />
Fig.7: the call graph of the value check functions

</p>
<p>Local Variables
—————</p>

<h3 id="local-variable-definitions">Local Variable Definitions</h3>

<p>The variable definitions in Ruby are really various.
As for constants and class variables, these are defined on the first assignment.
As for instance variables and global variables, as all names can be considered
that they are already defined, you can refer them without assigning beforehand
(although it produces warnings).</p>

<p>The definitions of local variables are again completely different from the above all.
A local variable is defined when its assignment appears on the program.
For example, as follows:</p>

<pre><code class="language-emlist">lvar = nil
p lvar      # being defined
</code></pre>

<p>In this case, as the assignment to <code class="highlighter-rouge">lvar</code> is written at the first line,
in this moment <code class="highlighter-rouge">lvar</code> is defined.
When it is undefined, it ends up with a runtime exception <code class="highlighter-rouge">NameError</code> as follows:</p>

<pre><code class="language-emlist">% ruby lvar.rb
lvar.rb:1: undefined local variable or method `lvar'
for # (NameError)
</code></pre>

<p>Why does it say <code class="highlighter-rouge">"local variable or method"</code>?
As for methods, the parentheses of the arguments can be omitted when calling,
so when there’s not any arguments, it can’t be distinguished from local variables.
To resolve this situation, <code class="highlighter-rouge">ruby</code> tries to call it as a method when it finds
an undefined local variable. Then if the corresponding method is not found, it
generates an error such as the above one.</p>

<p>By the way, it is defined when “it appears”, this means it is defined even
though it was not assigned. The initial value of a defined variable is nil.</p>

<pre><code class="language-emlist">if false
  lvar = "this assigment will never be executed"
end
p lvar   # shows nil
</code></pre>

<p>Moreover, since it is defined “when” it “appears”, the definition has to be
before the reference in a symbol sequence.
For example, in the next case, it is not defined.</p>

<pre><code class="language-emlist">p lvar       # not defined !
lvar = nil   # although appearing here ...
</code></pre>

<p>Be careful about the point of “in the symbol sequence”.
It has completely nothing to do with the order of evaluations.
For example, for the next code, naturally the condition expression is evaluated first,
but in the symbol sequence, at the moment when <code class="highlighter-rouge">p</code> appears the assignment
to <code class="highlighter-rouge">lvar</code> has not appeared yet.
Therefore, this produces <code class="highlighter-rouge">NameError</code>.</p>

<pre><code class="language-emlist">p(lvar) if lvar = true
</code></pre>

<p>What we’ve learned by now is that the local variables are extremely influenced
by the appearances. When a symbol sequence that expresses an assignment appears,
it will be defined in the appearance order. Based on this information, we can
infer that <code class="highlighter-rouge">ruby</code> seems to define local variables while parsing because the
order of the symbol sequence does not exist after leaving the parser.
And in fact, it is true. In <code class="highlighter-rouge">ruby</code>, the parser defines local variables.</p>

<h3 id="block-local-variables">Block Local Variables</h3>

<p>The local variables newly defined in an iterator block are called block local
variables or dynamic variables. Block local variables are, in language
specifications, identical to local variables. However, these two differ in
their implementations.
We’ll look at how is the difference from now on.</p>

<h3 id="the-data-structure">The data structure</h3>

<p>We’ll start with the local variable table <code class="highlighter-rouge">struct local_vars</code>.</p>

<p class="caption">
▼ `struct local_vars`

</p>
<pre><code class="language-longlist">5174  static struct local_vars {
5175      ID *tbl;                    /* the table of local variable names */
5176      int nofree;                 /* whether it is used from outside */
5177      int cnt;                    /* the size of the tbl array */
5178      int dlev;                   /* the nesting level of dyna_vars */
5179      struct RVarmap* dyna_vars;  /* block local variable names */
5180      struct local_vars *prev;
5181  } *lvtbl;

(parse.y)
</code></pre>

<p>The member name <code class="highlighter-rouge">prev</code> indicates that the <code class="highlighter-rouge">struct local_vars</code> is a
opposite-direction linked list. … Based on this, we can expect a stack.
The simultaneously declared global variable <code class="highlighter-rouge">lvtbl</code> points to <code class="highlighter-rouge">local_vars</code> that
is the top of that stack.</p>

<p>And, <code class="highlighter-rouge">struct RVarmap</code> is defined in <code class="highlighter-rouge">env.h</code>,
and is available to other files and is also used by the evaluator.
This is used to store the block local variables.</p>

<p class="caption">
▼ `struct RVarmap`

</p>
<pre><code class="language-longlist">  52  struct RVarmap {
  53      struct RBasic super;
  54      ID id;                  /* the variable name */
  55      VALUE val;              /* its value */
  56      struct RVarmap *next;
  57  };

(env.h)
</code></pre>

<p>Since there’s <code class="highlighter-rouge">struct RBasic</code> at the top, this is a Ruby object.
It means it is managed by the garbage collector.
And since it is joined by the <code class="highlighter-rouge">next</code> member, it is probably a linked list.</p>

<p>Based on the observation we’ve done and the information that will be explained,
Fig.8 illustrates the image of both structs while executing the parser.</p>

<p class="image">
<img src="images/ch_syntree_localvars.jpg" alt="(localvars)" /><br />
Fig.8: The image of local variable tables at runtime

</p>
<p>### Local Variable Scope</p>

<p>When looking over the list of function names of <code class="highlighter-rouge">parse.y</code>,
we can find functions such as <code class="highlighter-rouge">local_push() local_pop() local_cnt()</code> are laid out.
In whatever way of thinking, they appear to be relating to a local variable.
Moreover, because the names are <code class="highlighter-rouge">push pop</code>, it is clearly a stack.
So first, let’s find out the places where using these functions.</p>

<p class="caption">
▼ `local_push() local_pop()` used examples

</p>
<pre><code class="language-longlist">1475                  | kDEF fname
1476                      {
1477                          $$ = cur_mid;
1478                          cur_mid = $2;
1479                          in_def++;
1480                          local_push(0);
1481                      }
1482                    f_arglist
1483                    bodystmt
1484                    kEND
1485                      {
1486                          /* NOEX_PRIVATE for toplevel */
1487                          $$ = NEW_DEFN($2, $4, $5,
                                  class_nest?NOEX_PUBLIC:NOEX_PRIVATE);
1488                          if (is_attrset_id($2))
                                  $$-&gt;nd_noex = NOEX_PUBLIC;
1489                          fixpos($$, $4);
1490                          local_pop();
1491                          in_def--;
1492                          cur_mid = $3;
1493                      }

(parse.y)
</code></pre>

<p>At <code class="highlighter-rouge">def</code>, I could find the place where it is used. It can also be found in class
definitions and singleton class definitions, and module definitions.
In other words, it is the place where the scope of local variables is cut.
Moreover, as for how they are used,
it does <code class="highlighter-rouge">push</code> where the method definition starts and does <code class="highlighter-rouge">pop</code> when the definition ends.
This means, as we expected, it is almost certain that the functions start with
<code class="highlighter-rouge">local_</code> are relating to local variables. And it is also revealed that the part
between <code class="highlighter-rouge">push</code> and <code class="highlighter-rouge">pop</code> is probably a local variable scope.</p>

<p>Moreover, I also searched <code class="highlighter-rouge">local_cnt()</code>.</p>

<p class="caption">
▼ `NEW_LASGN()`

</p>
<pre><code class="language-longlist"> 269  #define NEW_LASGN(v,val) rb_node_newnode(NODE_LASGN,v,val,local_cnt(v))

(node.h)
</code></pre>

<p>This is found in <code class="highlighter-rouge">node.h</code>. Even though there are also the places where using in <code class="highlighter-rouge">parse.y</code>,
I found it in the other file. Thus, probably I’m in desperation.</p>

<p>This <code class="highlighter-rouge">NEW_LASGN</code> is “new local assignment”. This should mean the node of an
assignment to a local variable. And also considering the place where using it,
the parameter <code class="highlighter-rouge">v</code> is apparently the local variable name. <code class="highlighter-rouge">val</code> is probably
(a syntax tree that represents). the right-hand side value</p>

<p>Based on the above observations, <code class="highlighter-rouge">local_push()</code> is at the beginning of the local variable,
<code class="highlighter-rouge">local_cnt()</code> is used to add a local variable if there’s a local variable assignment in the halfway,
<code class="highlighter-rouge">local_pop()</code> is used when ending the scope.
This perfect scenario comes out. (Fig.9)</p>

<p class="image">
<img src="images/ch_syntree_localtbl.jpg" alt="(localtbl)" /><br />
Fig.9: the flow of the local variable management

</p>
<p>Then, let’s look at the content of the function.</p>

<h3 id="push-and-pop"><code class="highlighter-rouge">push</code> and <code class="highlighter-rouge">pop</code></h3>

<p class="caption">
▼ `local_push()`

</p>
<pre><code class="language-longlist">5183  static void
5184  local_push(top)
5185      int top;
5186  {
5187      struct local_vars *local;
5188
5189      local = ALLOC(struct local_vars);
5190      local-&gt;prev = lvtbl;
5191      local-&gt;nofree = 0;
5192      local-&gt;cnt = 0;
5193      local-&gt;tbl = 0;
5194      local-&gt;dlev = 0;
5195      local-&gt;dyna_vars = ruby_dyna_vars;
5196      lvtbl = local;
5197      if (!top) {
5198          /* preserve the variable table of the previous scope into val  */
5199          rb_dvar_push(0, (VALUE)ruby_dyna_vars);
5200          ruby_dyna_vars-&gt;next = 0;
5201      }
5202  }

(parse.y)
</code></pre>

<p>As we expected, it seems that <code class="highlighter-rouge">struct local_vars</code> is used as a stack.
Also, we can see <code class="highlighter-rouge">lvtbl</code> is pointing to the top of the stack.
The lines relates to <code class="highlighter-rouge">rb_dvar_push()</code> will be read later, so it is left untouched for now.</p>

<p>Subsequently, we’ll look at <code class="highlighter-rouge">local_pop()</code> and <code class="highlighter-rouge">local_tbl()</code> at the same time.</p>

<p class="caption">
▼ `local_tbl local_pop`

</p>
<pre><code class="language-longlist">5218  static ID*
5219  local_tbl()
5220  {
5221      lvtbl-&gt;nofree = 1;
5222      return lvtbl-&gt;tbl;
5223  }

5204  static void
5205  local_pop()
5206  {
5207      struct local_vars *local = lvtbl-&gt;prev;
5208
5209      if (lvtbl-&gt;tbl) {
5210          if (!lvtbl-&gt;nofree) free(lvtbl-&gt;tbl);
5211          else lvtbl-&gt;tbl[0] = lvtbl-&gt;cnt;
5212      }
5213      ruby_dyna_vars = lvtbl-&gt;dyna_vars;
5214      free(lvtbl);
5215      lvtbl = local;
5216  }

(parse.y)
</code></pre>

<p>I’d like you to look at <code class="highlighter-rouge">local_tbl()</code>.
This is the function to obtain the current local variable table (<code class="highlighter-rouge">lvtbl-&gt;tbl</code>).
By calling this, the <code class="highlighter-rouge">nofree</code> of the current table becomes true.
The meaning of <code class="highlighter-rouge">nofree</code> seems naturally “Don’t <code class="highlighter-rouge">free()</code>”.
In other words, this is like reference counting, “this table will be used, so
please don’t <code class="highlighter-rouge">free()</code>”. Conversely speaking,
when <code class="highlighter-rouge">local_tbl()</code> was not called with a table even once,
that table will be freed at the moment when being popped and be discarded.
For example, this situation probably happens when a method without any local variables.</p>

<p>However, the “necessary table” here means <code class="highlighter-rouge">lvtbl-&gt;tbl</code>.
As you can see, <code class="highlighter-rouge">lvtbl</code> itself will be freed at the same moment when being popped.
It means only the generated <code class="highlighter-rouge">lvtbl-&gt;tbl</code> is used in the evaluator.
Then, the structure of <code class="highlighter-rouge">lvtbl-&gt;tbl</code> is becoming important.
Let’s look at the function <code class="highlighter-rouge">local_cnt()</code> (which seems) to add variables
which is probably helpful to understand how the structure is.</p>

<p>And before that, I’d like you to remember that <code class="highlighter-rouge">lvtbl-&gt;cnt</code> is stored
at the index 0 of the <code class="highlighter-rouge">lvtbl-&gt;tbl</code>.</p>

<h3 id="adding-variables">Adding variables</h3>

<p>The function (which seems) to add a local variable is <code class="highlighter-rouge">local_cnt()</code>.</p>

<p class="caption">
▼ `local_cnt()`

</p>
<pre><code class="language-longlist">5246  static int
5247  local_cnt(id)
5248      ID id;
5249  {
5250      int cnt, max;
5251
5252      if (id == 0) return lvtbl-&gt;cnt;
5253
5254      for (cnt=1, max=lvtbl-&gt;cnt+1; cnttbl[cnt] == id) return cnt-1;
5256      }
5257      return local_append(id);
5258  }

(parse.y)
</code></pre>

<p>This scans <code class="highlighter-rouge">lvtbl-&gt;tbl</code> and searches what is equals to <code class="highlighter-rouge">id</code>.
If the searched one is found, it straightforwardly returns <code class="highlighter-rouge">cnt-1</code>.
If nothing is found, it does <code class="highlighter-rouge">local_append()</code>.
<code class="highlighter-rouge">local_append()</code> must be, as it is called <code class="highlighter-rouge">append</code>, the procedure to append.
In other words, <code class="highlighter-rouge">local_cnt()</code> checks if the variable was already registered,
if it was not, adds it by using <code class="highlighter-rouge">local_append()</code> and returns it.</p>

<p>What is the meaning of the return value of this function? <code class="highlighter-rouge">lvtbl-&gt;tbl</code> seems an
array of the variables, so there’re one-to-one correspondences between the
variable names and “their index - 1 (<code class="highlighter-rouge">cnt-1</code>)”. (Fig.10)</p>

<p class="image">
<img src="images/ch_syntree_lvtbltbl.jpg" alt="(lvtbltbl)" /><br />
Fig.10: The correspondences between the variable names and the return values

</p>
<p>Moreover, this return value is calculated so that the start point becomes 0,
the local variable space is probably an array.
And, this returns the index to access that array.
If it is not, like the instance variables or constants,
(the ID of) the variable name could have been used as a key in the first place.</p>

<p>You might want to know why it is avoiding index 0 (the loop start
from <code class="highlighter-rouge">cnt=1</code>) for some reasons, it is probably to store a value at <code class="highlighter-rouge">local_pop()</code>.</p>

<p>Based on the knowledge we’ve learned, we can understand the role of <code class="highlighter-rouge">local_append()</code>
without actually looking at the content.
It registers a local variable and returns
“(the index of the variable in <code class="highlighter-rouge">lvtbl-&gt;tbl</code>) - 1”.
It is shown below, let’s make sure.</p>

<p class="caption">
▼ `local_append()`

</p>
<pre><code class="language-longlist">5225  static int
5226  local_append(id)
5227      ID id;
5228  {
5229      if (lvtbl-&gt;tbl == 0) {
5230          lvtbl-&gt;tbl = ALLOC_N(ID, 4);
5231          lvtbl-&gt;tbl[0] = 0;
5232          lvtbl-&gt;tbl[1] = '_';
5233          lvtbl-&gt;tbl[2] = '~';
5234          lvtbl-&gt;cnt = 2;
5235          if (id == '_') return 0;
5236          if (id == '~') return 1;
5237      }
5238      else {
5239          REALLOC_N(lvtbl-&gt;tbl, ID, lvtbl-&gt;cnt+2);
5240      }
5241
5242      lvtbl-&gt;tbl[lvtbl-&gt;cnt+1] = id;
5243      return lvtbl-&gt;cnt++;
5244  }

(parse.y)
</code></pre>

<p>It seems definitely true. <code class="highlighter-rouge">lvtbl-&gt;tbl</code> is an array of the local variable names,
and its index - 1 is the return value (local variable ID).</p>

<p>Note that it increases <code class="highlighter-rouge">lvtbl-&gt;cnt</code>.
Since the code to increase <code class="highlighter-rouge">lvtbl-&gt;cnt</code> only exists here,
from only this code its meaning can be decided.
Then, what is the meaning? It is,
since “<code class="highlighter-rouge">lvtbl-&gt;cnt</code> increases by 1 when a new variable is added”,
“<code class="highlighter-rouge">lvtbl-&gt;cnt</code> holds the number of local variables in this scope”.</p>

<p>Finally, I’ll explain about <code class="highlighter-rouge">tbl[1]</code> and <code class="highlighter-rouge">tbl[2]</code>. These <code class="highlighter-rouge">'_'</code> and <code class="highlighter-rouge">'~'</code> are,
as you can guess if you are familiar with Ruby,
the special variables named <code class="highlighter-rouge">$_</code> and <code class="highlighter-rouge">$~</code>.
Though their appearances are identical to global variables,
they are actually local variables.
Even If you didn’t explicitly use it, when the methods such as <code class="highlighter-rouge">Kernel#gets</code> are called,
these variables are implicitly assigned,
thus it’s necessary that the spaces are always allocated.</p>

<h3 id="summary-of-local-variables">Summary of local variables</h3>

<p>Since the description of local variables were complex in various ways,
let’s summarize it.</p>

<p>First, It seems the local variables are different from the other variables
because they are not managed with <code class="highlighter-rouge">st_table</code>.
Then, where are they stored in? It seems the answer is an array.
Moreover, it is stored in a different array for each scope.</p>

<p>The array is <code class="highlighter-rouge">lvtbl-&gt;tbl</code>, and the index 0 holds the <code class="highlighter-rouge">lvtbl-&gt;cnt</code> which is set
at <code class="highlighter-rouge">local_pop()</code>. In other words, it holds the number of the local variables.
The index 1 or more hold the local variable names defined in the scope.
Fig.11 shows the final appearance we expect.</p>

<p class="image">
<img src="images/ch_syntree_tbl.jpg" alt="(tbl)" /><br />
Fig.11: correspondences between local variable names and the return values

</p>
<p>### Block Local Variables</p>

<p>The rest is <code class="highlighter-rouge">dyna_vars</code> which is a member of <code class="highlighter-rouge">struct local_vars</code>.
In other words, this is about the block local variables.
I thought that there must be the functions to do something with this,
looked over the list of the function names,
and found them as expected.
There are the suspicious functions named <code class="highlighter-rouge">dyna_push() dyna_pop() dyna_in_block()</code>.
Moreover, here is the place where these are used.</p>

<p class="caption">
▼ an example using `dyna_push dyna_pop`

</p>
<pre><code class="language-longlist">1651  brace_block     : '{'
1652                      {
1653                          $$ = dyna_push();
1654                      }
1655                    opt_block_var
1656                    compstmt '}'
1657                      {
1658                          $$ = NEW_ITER($3, 0, $4);
1659                          fixpos($$, $4);
1660                          dyna_pop($2);
1661                      }

(parse.y)
</code></pre>

<p><code class="highlighter-rouge">push</code> at the beginning of an iterator block, <code class="highlighter-rouge">pop</code> at the end.
This must be the process of block local variables.</p>

<p>Now, we are going to look at the functions.</p>

<p class="caption">
▼ `dyna_push()`

</p>
<pre><code class="language-longlist">5331  static struct RVarmap*
5332  dyna_push()
5333  {
5334      struct RVarmap* vars = ruby_dyna_vars;
5335
5336      rb_dvar_push(0, 0);
5337      lvtbl-&gt;dlev++;
5338      return vars;
5339  }

(parse.y)
</code></pre>

<p>Increasing <code class="highlighter-rouge">lvtbl-&gt;dlev</code> seems the mark indicates the existence of the block
local variable scope.
Meanwhile, <code class="highlighter-rouge">rb_dvar_push()</code> is …</p>

<p class="caption">
▼ `rb_dvar_push()`

</p>
<pre><code class="language-longlist"> 691  void
 692  rb_dvar_push(id, value)
 693      ID id;
 694      VALUE value;
 695  {
 696      ruby_dyna_vars = new_dvar(id, value, ruby_dyna_vars);
 697  }

(eval.c)
</code></pre>

<p>It creates a <code class="highlighter-rouge">struct RVarmap</code> that has the variable name <code class="highlighter-rouge">id</code> and the value
<code class="highlighter-rouge">val</code> as its members, adds it to the top of the global variable <code class="highlighter-rouge">ruby_dyna_vars</code>.
This is again and again the form of cons.
In <code class="highlighter-rouge">dyna_push()</code>, <code class="highlighter-rouge">ruby_dyan_vars</code> is not set aside,
it seems it adds directly to the <code class="highlighter-rouge">ruby_dyna_vars</code> of the previous scope.</p>

<p>Moreover, the value of the <code class="highlighter-rouge">id</code> member of the <code class="highlighter-rouge">RVarmap</code> to be added here is 0.
Although it was not seriously discussed in this book,
the <code class="highlighter-rouge">ID</code> of <code class="highlighter-rouge">ruby</code> will never be 0 while it is normally created by <code class="highlighter-rouge">rb_intern()</code>.
Thus, we can infer that this <code class="highlighter-rouge">RVarmap</code>, as it is like <code class="highlighter-rouge">NUL</code> or <code class="highlighter-rouge">NULL</code>,
probably has a role as sentinel.
If we think based on this assumption, we can describe the reason why the holder
of a variable (<code class="highlighter-rouge">RVarmap</code>) is added even though not any variables are added.</p>

<p>Next, <code class="highlighter-rouge">dyna_pop()</code>.</p>

<p class="caption">
▼ `dyna_pop()`

</p>
<pre><code class="language-longlist">5341  static void
5342  dyna_pop(vars)
5343      struct RVarmap* vars;
5344  {
5345      lvtbl-&gt;dlev--;
5346      ruby_dyna_vars = vars;
5347  }

(parse.y)
</code></pre>

<p>By reducing <code class="highlighter-rouge">lvtbl-&gt;dlev</code>, it writes down the fact that the block local
variable scope ended.
It seems that something is done by using the argument,
let’s see this later at once.</p>

<p>The place to add a block local variable has not appeared yet.
Something like <code class="highlighter-rouge">local_cnt()</code> of local variables is missing.
So, I did plenty of <code class="highlighter-rouge">grep</code> with <code class="highlighter-rouge">dvar</code> and <code class="highlighter-rouge">dyna</code>, and this code was found.</p>

<p class="caption">
▼ `assignable()` (partial)

</p>
<pre><code class="language-longlist">4599  static NODE*
4600  assignable(id, val)
4601      ID id;
4602      NODE *val;
4603  {
                            ：
4634              rb_dvar_push(id, Qnil);
4635              return NEW_DASGN_CURR(id, val);

(parse.y)
</code></pre>

<p><code class="highlighter-rouge">assignable()</code> is the function to create a node relates to assignments,
this citation is the fragment of that function only contains the part to deal
with block local variables.
It seems that it adds a new variable (to <code class="highlighter-rouge">ruby_dyna_vars</code>)
by using <code class="highlighter-rouge">rb_dvar_push()</code> that we’ve just seen.</p>

<h3 id="rubydynavars-in-the-parser"><code class="highlighter-rouge">ruby_dyna_vars</code> in the parser</h3>

<p>Now, taking the above all into considerations, let’s imagine the appearance of
<code class="highlighter-rouge">ruby_dyna_vars</code> at the moment when a local variable scope is finished to be
parsed.</p>

<p>First, as I said previously,
the <code class="highlighter-rouge">RVarmap</code> of <code class="highlighter-rouge">id=0</code> which is added at the beginning of a block scope is a
sentinel which represents a break between two block scopes.
We’ll call this “the header of <code class="highlighter-rouge">ruby_dyna_vars</code>”.</p>

<p>Next, among the previously shown actions of the rule of the iterator block,
I’d like you to focus on this part:</p>

<pre><code class="language-emlist">$$ = dyna_push();    /* what assigned into $$ is ... */
        ：
        ：
dyna_pop($2);        /* …… appears at $2 */
</code></pre>

<p><code class="highlighter-rouge">dyna_push()</code> returns the <code class="highlighter-rouge">ruby_dyna_vars</code> at the moment.
<code class="highlighter-rouge">dyna_pop()</code> put the argument into <code class="highlighter-rouge">ruby_dyna_vars</code>.
This means <code class="highlighter-rouge">ruby_dyna_vars</code> would be saved and restored for each the block local
variable scope.
Therefore, when parsing the following program,</p>

<pre><code class="language-emlist">iter {
    a = nil
    iter {
        b = nil
        iter {
            c = nil
            # nesting level 3
        }
        bb = nil
        # nesting level 2
        iter {
            e = nil
        }
    }
    # nesting level 1
}
</code></pre>

<p>Fig.12 shows the <code class="highlighter-rouge">ruby_dyna_vars</code> in this situation.</p>

<p class="image">
<img src="images/ch_syntree_dynavars.jpg" alt="(dynavars)" /><br />
Fig.12: `ruby_dyna_vars` when all scopes are finished to be parsed

</p>
<p>This structure is fairly smart.
That’s because the variables of the higher levels can naturally be accessed by
traversing over all of the list even if the nesting level is deep.
This way has the simpler searching process than creating a different table for
each level.</p>

<p>Plus, in the figure, it looks like <code class="highlighter-rouge">bb</code> is hung at a strange place,
but this is correct.
When a variable is found at the nest level which is decreased after increased once,
it is attached to the subsequent of the list of the original level.
Moreover, in this way, the specification of local variable that
“only the variables which already exist in the symbol sequence are defined”
is expressed in a natural form.</p>

<p>And finally, at each cut of local variable scopes (this is not of block local
variable scopes), this link is entirely saved or restored to <code class="highlighter-rouge">lvtbl-&gt;dyna_vars</code>.
I’d like you to go back a little and check <code class="highlighter-rouge">local_push()</code> and <code class="highlighter-rouge">local_pop()</code>.</p>

<p>By the way, although creating the <code class="highlighter-rouge">ruby_dyna_vars</code> list was a huge task,
it is by itself not used at the evaluator. This list is used only to check the
existence of the variables and will be garbage collected at the same moment
when parsing is finished. And after entering the evaluator, another chain is
created again.
There’s a quite deep reason for this, … we’ll see around this once again in
Part 3.</p>


    <footer>
      The original work is Copyright © 2002 - 2004 Minero AOKI.
      Translated by Vincent ISAMBART and Clifford Escobar CAOILE
      This work is licensed under a
      <p>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/">Creative Commons Attribution-NonCommercial-ShareAlike2.5 License</a>
      </p>
    </footer>

  </div>
</body>
</html>
