---
layout: default
---


h1. Preface: Introduction

h2. Characteristics of Ruby

Some of the readers may have already been familiar with Ruby,
but (I hope) there are also many readers who have not. First let's go though a
rough summary of the characteristics of Ruby for such people. 


Hereafter capital "Ruby" refers to Ruby as a language specification, and lowercase
"@ruby@" refers to @ruby@ command as an implementation.

h4. Development style

Ruby is a language that is being developped by the hand of Yukihiro Matsumoto as
an individual. Unlike C or Java or Scheme, it does not have any standard.
The specification is merely
shown as an implementation as @ruby@, and its varying continuously.
For good or bad, it's free.


Furthermore @ruby@ itself is a free software.
It's probably necessary to mention at least the two points here:
The source code is open in public and distributed free of charge.
Thanks to such condition, an attempt like this book can be approved.


If you'd like to know the exact lisence, you can read @README@ and @LEGAL@.
For the time being, I'd like you to remember that you can do at least the
following things:


* You can redistribute source code of @ruby@
* You can modify source code of @ruby@
* You can redistribute a copy of source code with your modification


There is no need for special permission and payment in all these cases. 


By the way, the purpose of this book is to read the original @ruby@,
thus the target source is the one not modified unless it is particulary
specified. However, white spaces, new lines and comments were added or removed
without asking.


h4. It's conservative

Ruby is a very conservative language. It is equipped with only carefully chosen
features that have been tested and washed out in a variety of languages.
Therefore it doesn't have plenty of fresh and experimental features very much.
So it has a tendency to appeal to programmers who put importance on practical
functionalities. The dyed-in-the-wool hackers like Scheme and Haskell lovers
don't seem to find appeal in ruby, at least in a short glance.


The library is conservative in the same way. Clear and unabbreviated names are
given for new functions, while names that appears in C and Perl libraries have
been taken from them. For example, @printf@, @getpwent@, @sub@, and @tr@.


It is also conservative in implementation. Assembler is not its option for
seeking speed. Portability is always considered a higher priority when it
conflicts with speed. 

h4. It is an object-oriented language

Ruby is an object-oriented language. It is absolutely impossible to exclude it
from the features of Ruby.


I will not give a page to this book about what an object-oriented language is.
To tell about an object-oriented feature about Ruby, the expression of the code
that just going to be explained is the exact sample.

h4. It is a script language

Ruby is a script language. It seems also absolutely impossible to exclude this
from the features of Ruby. To gain agreement of
everyone, an introduction of Ruby must include "object-oriented" and "script
language". 


However, what is a "script language" for example? I couldn't figure out the
definition successfully. For example, John K. Ousterhout, the author of Tcl/Tk,
gives a definition as "executable language using @#!@ on UNIX". There are other
definitions depending on the view points, such as one that can express a useful
program with only one line, or that can execute the code by passing a program
file from the command line, etc. 


However, I dare to use another definition, because I don't find much interest
in "what" a script language.
I have the only one measure to decide to call it a script language,
that is, whether no one would complain about calling it a script language.
To fulfill this definition, I would define the meaning of "script language" as
follows. 


A language that its author calls it a "script language".


I'm sure this definition will have no failure. And Ruby fulfills this point. 
Therefore I call Ruby a "script language". 

h4. It's an interpreter

@ruby@ is an interpreter. That's the fact. But why it's an interpreter?  For
example, couldn't it be made as a compiler?
It must be because in some points being an interpreter is better than being
a compiler ... at least for ruby, it must be better.
Well, what is good about being an interpreter?


As a preparation step to investigating into it, let's start by thinking about
the difference between an interpreter and a compiler. If the matter is to
attempt a theoretical comparison in the process how a program is executed,
there's no difference between an interpreter language and a compile language.
Because it works by letting CPU interpret the code compiled to the machine
language, it may be possible to say it works as an interpretor.
Then where is the place that actually makes a difference?
It is a more practical place, in the process of development.


I know somebody, as soon as hearing "in the process of development", would
claim using a stereotypical phrase, that an interpreter reduces effort of
compilation that makes the development procedure easier. But I don't think it's
accurate. A language could possibly be planned so that it won't show the
process of compilation. Actually, Delphi can compile a project by hitting just
F5. A claim about a long time for compilation is derived from the size of the
project or optimization of the codes. Compilation itself doesn't owe a negative
side. 


Well, why people perceive an interpreter and compiler so much different like
this? I think that it is because the language developers so far have chosen
either implementation based on the trait of each language. In other words,
if it is a language for a comparatively small purpose such as a daily routine,
it would be an interpretor.
If it is for a large project where a number of people are involved in the
development and accuracy is required,
it would be a compiler.
That may be because of the speed, as well as the ease of creating a language.


Therefore, I think "it's handy because it's an interpreter" is an outsized myth.
Being an interpreter doesn't necessarily contribute the readiness in usage;
seeking readiness in usage naturally makes your path toward building an
interpreter language.


Anyway, @ruby@ is an interpreter; it has an important fact about where this
book is facing, so I emphasize it here again.
Though I don't know about "it's handy because it is an interpreter",
anyway @ruby@ is implemented as an interpreter.

h4. High portability

Even with a problem that fundamentally the interfaces are Unix-centered, I
would insist @ruby@ possesses a high portability.
It doesn't require any extremely unfamiliar library.
It has only a few parts written in assembler.
Therefore porting to a new platform is comparatively easy. Namely, it works
on the following platforms currently. 


* Linux
* Win32 (Windows 95, 98, Me, NT, 2000, XP)
* Cygwin
* djgpp
* FreeBSD
* NetBSD
* OpenBSD
* BSD/OS
* Mac OS X
* Solaris
* Tru64 UNIX
* HP-UX
* AIX
* VMS
* UX/4800
* BeOS
* OS/2 (emx)
* Psion


I heard that the main machine of the author Matsumoto is Linux.
Thus when using Linux, you will not fail to compile any time.


Furthermore, you can expect a stable functionality on a (typical) Unix environment.
Considering the release cycle of packages, the primary option
for the environment to hit around @ruby@ should fall on a branch of PC UNIX,
  currently. 


On the other hand, the Win32 environment tends to cause problems definitely.
The large gaps in the targeting OS model tend to cause problems around the
machine stack and the linker. Yet, recently Windows hackers have contributed to
make better support. I use a native ruby on Windows 2000 and Me. Once it gets
successfully run, it doesn't seem to show special concerns like frequent
crashing. The main problems on Windows may be the gaps in the specifications. 


Another type of OS that many people may be interested in should probably be Mac
OS (prior to v9) and handheld OS like Palm. 


Around @ruby 1.2@ and before, it supported legacy Mac OS, but the development
seems to be in suspension. Even a compiling can't get through. The biggest
cause is that the compiler environment of legacy Mac OS and the decrease of
developers. Talking about Mac OS X, there's no worries because the body is
UNIX. 


There seem to be discussions the portability to Palm several branches, but I
have never heard of a successful project. I guess the difficulty lies in the
necessity of settling down the specification-level standards such as @stdio@ on
the Palm platform, rather than the processes of actual implementation. Well I
saw a porting to Psion has been done. ([ruby-list:36028]). 


How about hot stories about VM seen in Java and .NET?
Because I'd like to talk about them combining together with the implementation,
this topic will be in the final chapter.


h4. Automatic memory control

Functionally it's called GC, or Garbage Collection. Saying it in C-language,
this feature allows you to skip @free()@ after @malloc()@.  Unused memory is
detected by the system automatically, and will be released. It's so convenient
that once you get used to GC you won't be willing to do such manual
memory control again. 


The topics about GC have been common because of its popularity in recent
languages with GC as a standard set, and it is fun that
its algorithms can still be improved further.

h4. Typeless variables

The variables in Ruby don't have types. The reason is probably typeless
variables conforms more with polymorphism, which is one of the strongest
advantages of an object-oriented language.  Of course a language with variable
type has a way to deal with polymorphism.  What I mean here is a typeless
variables have better conformance. 


The level of "better conformance" in this case refers to synonyms like "handy".
It's sometimes corresponds to crucial importance, sometimes it doesn't matter
practically. Yet, this is certainly an appealing point if a language seeks for
"handy and easy", and Ruby does. 

h4. Most of syntactic elements are expressions

This topic is probably difficult to understand instantly without a little
supplemental explanation.  For example, the following C-language program
results in a syntactic error.

<pre class="emlist"> 
result = if (cond) { process(val); } else { 0; }
</pre>

Because the C-language syntax defines @if@ as a statement.
But you can write it as follows.

<pre class="emlist"> 
result = cond ? process(val) : 0;
</pre>

This rewrite is possible because the conditional operator (@a?b:c@) is defined
as an expression.


On the other hand, in Ruby, you can write as follows because @if@ is an expression.

<pre class="emlist"> 
result = if cond then process(val) else nil end
</pre>

Roughly speaking, if it can be an argument of a function or a method,
you can consider it as an expression.

Of course, there are other languages whose syntactic elements are mostly expressions.
Lisp is the best example. Because of the characteristic around this,
there seems many people who feel like "Ruby is similar to Lisp".

h4. Iterators

Ruby has iterators. What is an iterator? Before getting into iterators, I should
mention the necessity of using an alternative term, because the word "iterator" is
disliked recently. However, I don't have a good alternative. So let us keep calling
it "iterator" for the time being. 

Well again, what is an iterator? If you know higher-order function,
for the time being, you can regard it as something similar to it.
In C-language, the counterpart would be passing a function pointer as an argument.
In C++, it would be a method to which the operation part of STL's @Iterator@ is enclosed.
If you know @sh@ or @Perl@,
it's good to imagine something like a custom @for@ statement which we can define.

Yet, the above are merely examples of "similar" concepts. All of them are similar,
but they are not identical to Ruby's iterator. I will expand the precise story
when it's a good time later. 

h4. Written in C-language

Being written in C-language is not notable these days, but it's still a
characteristic for sure.
At least it is not written in Haskell or PL/I,
thus there's the high possibility that the ordinary people can read it.
(Whether it is truly so, I'd like you confirm it by yourself.)

Well, I just said it's in C-language, but the actual language version which ruby is
targetting is basically K&R C.  Until a little while ago, there were a decent number
of - not plenty though - K&R-only-environment.
But recently, there are a few environments which do not accept programs
written in ANSI C, technically there's no problem to move on to ANSI C.
However, also because of the author Matsumoto's personal preference,
it is still written in K&R style.

For this reason, the function definition is all in K&R style, and the prototype
declarations are not so seriously written.
If you carelessly specify @-Wall@ option of @gcc@,
there would be plenty of warnings shown.
If you try to compile it with a C++ compiler,
it would warn prototype mismatch and could not compile.
... These kind of stories are often reported to the mailing list.


h4. Extension library

We can write a Ruby library in C and load it at runtime without recompiling Ruby.
This type of library is called "Ruby extension library" or just "Extension library". 

Not only the fact that we can write it in C,
but the very small difference in the code expression between Ruby-level and
C-level is also a significant trait.
As for the operations available in Ruby,
we can also use them in C in the almost same way.
See the following example.

<pre class="emlist"> 
# Method call
obj.method(arg)                                 # Ruby
rb_funcall(obj, rb_intern("method"), 1, arg);   # C

# Block call
yield arg        # Ruby
rb_yield(arg);   # C

# Raising exception
raise ArgumentError, 'wrong number of arguments'       # Ruby
rb_raise(rb_eArgError, "wrong number of arguments");   # C

# Generating an object
arr = Array.new             # Ruby
VALUE arr = rb_ary_new();   # C
</pre>

It's good because it provides easiness in composing an extension library, and actually
it makes an indispensable prominence of @ruby@. However, it's also a burden for @ruby@
implementation. You can see the affects of it in many places. The affects to GC and
thread-processing is eminent. 

h4. Thread

Ruby is equipped with thread. Assuming a very few people knowing none about thread these
days, I will omit an explanation about the thread itself. I will start a story in detail. 

`ruby`'s thread is a user-level thread that is originally written. The characteristic of
this implementation is a very high portability in both specification and implementation.
Surprisingly a MS-DOS can run the thread. Furthermore, you can expect the same response
in any environment. Many people mention that this point is the best feature of @ruby@.

However, as a trade off for such an extremeness of portability, @ruby@ abandons the speed.
It's, say, probably the slowest of all user-level thread implementations in this world.
The tendency of @ruby@ implementation may be seen here the most clearly.

h2. Technique to read source code

Well. After an introduction of @ruby@, we are about to start reading source code. But wait. 

Any programmer has to read a source code somewhere, but I guess there are not many occasions
that someone teaches you the concrete ways how to read. Why?
Does it mean you can naturally read a program if you can write a program?

But I can't think reading the program written by other people is so easy.
In the same way as writing programs, there must be techniques and theories in reading programs.
And they are necessary. Therefore, before starting to ready @ruby@, I'd like to expand a general
summary of an approach you need to take in reading a source code. 

h3. Principles

At first, I mention the principle. 

h4. Decide a goal


<blockquote>
An important key to reading the source code is to set a concrete goal. 
</blockquote>


This is a word by the author of Ruby, Matsumoto. Indeed, his word is very convincing for me.
When the motivation is a spontaneous idea "May be I should read a kernel, at least...",
you would get source code expanded or explanatory books ready on the desk. But not knowing
what to do, the studies are to be left untouched. Haven't you? On the other hand, when you
have in mind "I'm sure there is a bug somewhere in this tool. I need to quickly fix it and
make it work. Otherwise I will not be able to make the deadline...", you will probably be
able to fix the code in a blink, even if it's written by someone else. Haven't you? 

The difference in these two cases is motivation you have. In order to know something,
you at least have to know what you want to know. Therefore, the first step of all is
to figure out what you want to know in explicit words. 

However, of course this is not all needed to make it your own "technique".
Because "technique" needs to be a common method that anybody can make use of it by following it.
In the following section, I will explain how to bring the first step into the landing place
where you achieve the goal finally. 

h4. Visualising the goal

Now let us suppose that our final goal is set "Understand all about @ruby@". This is certainly
considered as "one set goal", but apparently it will not be useful for reading the source code
actually. It will not be a trigger of any concrete action. Therefore, your first job will be to
drag down the vague goal to the level of a concrete thing. 

Then, what will the method be? Firstly, it's good if you pretend that you are the composer of
the program. You can utilize your knowledge in writing a program, in this case. For example,
when you are reading a traditional "structured" programming by somebody, you will analyze it
hiring the strategies of structured programming too. That is, you will divide the target into
pieces, little by little. For another example, suppose you are reading a GUI program that walks
around in an event loop, you can just start looking at the event loop before studying the roles
of the event handlers. In another case, you will look up what "M" is for in MVC (Model View Controller). 

Secondly, keep in mind the methods of analysis. Everybody might have certain analysis methods,
but they are often done based on experience and relying inspiration. It's crucially important
to give it to the notion how to read source code well. 

Well, what are such methods like? I will explain it in the next section. 

h3. Analysis methods

The methods to read source code can be roughly divided into two; one is a static method and
the other is dynamic method. Static method is to read and analyze the source code without
running the program. Dynamic method is to watch the actual behavior using tools like a debugger. 

It's better to start studying a program by dynamic analysis. That is because what you can see
there is the "fact". The results from static analysis, due to the fact of not running the program
actually, may well be "prediction" to a greater or lesser extent. If you want to know the truth,
you should start from watching the fact. 

Of course, you don't know whether the results of dynamic analysis are the fact really.
The debugger could run with a bug, or the CPU may not be working properly due to overheat.
The conditions of your configuration could be wrong. However, the results of static analysis
should at least be closer to the fact than dynamic analysis. 

h3. Dynamic analysis

h4. Use the target program

You can't start without the target program. First of all, you need to know in advance what
the program is like, and what are expected behaviors. 

h4. Follow the behavior using the debugger

If you want to see the paths of code execution and the data structure produced as a result,
it's quicker to look at the result by running the program actually than to emulate the behavior
in your brain. In order to do so easily, use the debugger. 

However, there is not adequate tools unfortunately, especially in free software,
that can generate the picture of the data structure at execution. A snapshot of the comparatively
simpler structure may be obtained by converting text data obtained instantly into a picture using
graphviz\footnote{graphviz……See doc/graphviz.html in the attached CD-ROM}.
But it's very difficult to find a way for general purpose and real time analysis. 

h4. Tracer

You can use the tracer if you want to trace the procedures that code goes through.  In case of C-language, there is a tool named ctrace\footnote{ctrace……http://www.vicente.org/ctrace}.  For tracing a system call, you can use tools like strace\footnote{strace……http://www.wi.leidenuniv.nl/~wichert/strace/}, truss, and ktrace. 

h4. Print everywhere

There is a word "printf debugging". This method also works for analysis other than debugging.
If you are watching the history of one variable, for example, it may be easier to understand
to look at the dump of the result of the print statements embed, than to track the variable
with a debugger.

h4. Understanding code by modifying it

Say for example, you do not understand some part of the code or a particular parameter,
just make a small change and then re-run the program.
By trying out small changes and seeing how they affect the code you will understand how it works.

It goes without saying, you should have an original binary to compare your changes to.

h3. Static analysis

h4. The importance of names

Static analysis is simply source code analysis. Therefore, source code analysis is
really an analysis of names. File names, function names, variable names, type names,
member names -- A program is just a bunch of names.

One of the most powerful tools for creating abstractions in programming is naming.
This may seem obvious but keeping this in mind will make reading much more efficient.

Also, I'd like to mention something about coding rules.
For example, in C language, @extern@ function often uses prefix to distinguish the type of functions.
And in object-oriented programs, the name of member fields in a function often includes prefix,
which is really important information (e.g. @rb_str_length@).

h4. Read documents

Sometimes a document describes the internal structure is included.
Especially be careful of a file named @HACKING@ etc.

h4. Read the directory structure

You should read in what policy the directories are devided.
You can grasp the overview about how the program is structured, and what the parts are.

h4. Read the configuration of the files

While browsing the name of the functions, see how the file files are divided.
You should pay attention to the file names because they are like comments
whose lifetime is very long.

Another important viewpoint is to locate a module in the file.
Functions for the module are thought to be located in a series.
So, you can understand the module's structure from the order of functions.

h4. Investigate abbreviations

As you encounter ambiguous abbreviations, make a list of them and investigate
each of them as early as possible. For example, suppose @GC@ is short for Garbage Collection.
But the context will be very different if it's actually short for Graphic Context.

Abbreviations for a program are generally made by the methods like taking
the initial letters or dropping the vowels. Note especially the fact that
popular abbreviations in the fields of the program's target are used without notice.
You should be familiar with them at an early stage.

h4. Understand data structure

If you find both data and code, you should first investigate the data structure.
In other words, when exploring code in C, it's better to start with the header file.
When reading filenames, you should use your imagination as much as possible.
For example, if you find @frame.h@, it would probably be the stack frame definition.

Also, you can understand many things from the type and member name in a structure.
For example, if you find the member @next@, which points to its own type, then it
will be a linked list. Similarly, when you find members such as @parent@, @children@,
and @sibling@, then it must be a tree structure. When @prev@, it will be a stack.

h4. Understanding the relationship between functions

After names, the next most important thing to understand is the relationships between
functions. It's very useful to visualize the relationship between functions and
their callers with a tool called a "call graph". I highly recommend you use one.

A text-based tool is sufficient, but call graph tool that generates an actual graph is even better.
There are not so many tools that generate these graphs, though and most are shareware, not OSS or freeware.
I often use graphviz to generate these graphs.
I also implemented a small Ruby parser to generate output for graphviz, then graphviz generates the graph.

h4. Read functions

動作を読んで、関数のやることを一言で説明できるようにする。関数関連図を
見ながらパートごとに読んでいくのがいい。


関数を読むときに重要なのは「何を読むか」ではなく「何を読まないか」であ
る。どれだけコードを削るかで読みやすさが決まると言ってよい。具体的に何
を削ればいいか、というのは実際に見せてみないとわかりづらいので本文で解
説する。


それとコーディングスタイルが気にいらないときは@indent@のようなツールを
使って変換してしまえばいい。

h4. 好みに書き換えてみる

人間の身体というのは不思議なもので、できるだけ身体のいろんな場所を使い
ながらやったことは記憶に残りやすい。パソコンのキーボードより原稿用紙の
ほうがいい、という人が少なからずいるのは、単なる懐古趣味ではなくそうい
うことも関係しているのではないかと思う。


そういうわけで単にモニタで読むというのは非常に身体に残りにくいので、
書き換えながら読む。そうするとわりと早く身体がコードに馴染んでくること
が多い。気にくわない名前やコードがあったら書き換える。わかりづらい略語
は置換して省略しないようにしてしまえばよい。


ただし当然のことだが書き換えるときはオリジナルのソースは別に残しておき、
途中で辻褄が合わないと思ったら元のソースを見て確認すること。でないと自
分の単純ミスで何時間も悩む羽目になる。それに書き換えるのはあくまで馴染
むためであって書き換えること自体が目的ではないので熱中しすぎないように
注意してほしい。

h3. 歴史を読む

プログラムにはたいてい変更個所の履歴を書いた文書が付いている。例えば
GNUのソフトウェアだと必ず@ChangeLog@というファイルがある。これは
「プログラムがそうなっている理由」を知るのには最高に役に立つ。


またCVSやSCCSのようなバージョン管理システムを使っていてしかもそれにア
クセスできる場合は、@ChangeLog@以上に利用価値が高い。CVSを例に取ると、特
定の行を最後に変更した場所を表示する@cvs annotate@、指定した版からの差分
を取る@cvs diff@などが便利だ。


さらに、開発用のメーリングリストやニュースグループがある場合はその過去
ログを入手してすぐに検索できるようにしておく。変更の理由がズバリ載って
いることが多いからだ。もちろんWeb上で検索できるならそれでもいい。

h3. 静的解析用ツール

いろいろな目的のためにいろいろなツールがあるので一口には言えないが、筆
者が一つだけ選ぶとしたら@global@をお勧めする。なんと言っても他の用途に応
用しやすい作りになっているところがポイントだ。例えば同梱されている
@gctags@は本当はタグファイルを作るためのツールなのだが、
これを使ってファイルに含まれる関数名のリストを取ることもできる。

<pre class="screen">
~/src/ruby % gctags class.c | awk '{print $1}'
SPECIAL_SINGLETON
SPECIAL_SINGLETON
clone_method
include_class_new
ins_methods_i
ins_methods_priv_i
ins_methods_prot_i
method_list
        ：
        ：
</pre>

とは言えこれはあくまでも筆者のお勧めなので読者は自分の好きなツールを使っ
てもらえばいい。ただその時は最低でも次の機能を備えているものを選ぶように
すべきだ。


ファイルに含まれる関数名をリストアップする
関数名や変数名から位置を探す（さらにそこに飛べるとなおよい）
関数クロスリファレンス

h2. ビルド

h3. 対象バージョン

本書で解説している@ruby@のバージョンは1.7の2002-09-12版である。@ruby@はマ
イナーバージョンが偶数だと安定版で奇数だと開発版だから、1.7は開発版と
いうことになる。しかも9月12日は特に何かの区切りというわけではないの
で、該当バージョンの公式パッケージは配布されていない。従ってこの版を入
手するには本書添付のCD-ROMまたはサポートサイト
footnote{本書のサポートサイト......@http://i.loveruby.net/ja/rhg/@}
から入手するか、後述のCVSを使うしかない。


安定版の1.6でなく1.7にした理由は、1.7のほうが仕様・実装ともに整理され
ていて扱いやすいことが一つ。次に、開発版先端のほうがCVSが使いやすい。
さらに、わりと近いうちに次の安定版の1.8が出そうな雰囲気になってきたこと。
そして最後に、最先端を見ていくほうが気分的に楽しい。

h3. ソースコードを入手する

添付CD-ROMに解説対象の版のアーカイブを収録した。
CD-ROMのトップディレクトリに

<pre class="emlist"> 
ruby-rhg.tar.gz
ruby-rhg.zip
ruby-rhg.lzh
</pre>

の三種類が置いてあるので、便利なものを選んで使ってほしい。
もちろん中身はどれも同じだ。例えば@tar.gz@のアーカイブなら
次のように展開すればいいだろう。

<pre class="screen">
~/src % mount /mnt/cdrom
~/src % gzip -dc /mnt/cdrom/ruby-rhg.tar.gz | tar xf -
~/src % umount /mnt/cdrom
</pre>

h3. コンパイルする

ソースコードを見るだけでも「読む」ことはできる。しかしプログラムを知る
ためには実際にそれを使い、改造し、実験してみることが必要だ。実験をする
なら見ているソースコードと同じものを使わなければ意味がないので、当然自
分でコンパイルすることになる。


そこでここからはコンパイルの方法を説明する。まずはUNIX系OSの場合から話
を始めよう。Windows上ではいろいろあるので次の項でまとめて話す。ただし
CygwinはWindows上ではあるがほとんどUNIXなので、こちらの話を読んでほし
い。

h4. UNIX系OSでのビルド

さて、UNIX系OSなら普通Cコンパイラは標準装備なので、次の手順でやれば
たいがい通ってしまう。
@~/src/ruby@にソースコードが展開されているとする。

<pre class="screen">
~/src/ruby % ./configure
~/src/ruby % make
~/src/ruby % su
~/src/ruby # make install
</pre>

以下、いくつか注意すべき点を述べる。


Cygwin、UX/4800など一部のプラットフォームでは@configure@の段階で
@--enable-shared@オプションを付けないとリンクに失敗する。
@--enable-shared@というのは@ruby@のほとんどを共有ライブラリ
（@libruby.so@）としてコマンドの外に出すオプションである。

<pre class="screen">
~/src/ruby % ./configure --enable-shared
</pre>

ビルドに関するより詳しいチュートリアルを添付CD-ROMの
@doc/build.html@に入れたので、それを読みながらやってみてほしい。

h4. Windowsでのビルド

Windowsでのビルドとなるとどうも話がややこしくなる。
問題の根源はビルド環境が複数あることだ。


Visual C++
MinGW
Cygwin
Borland C++ Compiler


まずCygwin環境はWindowsよりもUNIXに条件が近いのでUNIX系のビルド手順に
従えばいい。


Visual C++でコンパイルする場合はVisual C++ 5.0以上が
必要である。バージョン6か.NETならまず問題ないだろう。


MinGW、Minimalist GNU for WindowsというのはGNUのコンパイル環境（ようするに
@gcc@と@binutils@）をWindowsに移植したものだ。CygwinがUNIX環境全体を移植し
たのに対し、MinGWはあくまでコンパイルのためのツールだけを移植してある。
またMinGWでコンパイルしたプログラムは実行時に特別なDLLを必要としない。
つまりMinGWでコンパイルした@ruby@はVisual C++版と全く同じに扱える。


また個人利用ならばBorland C++ Compilerのバージョン5.5がBorlandのサイト
footnote{Borlandのサイト：@http://www.borland.co.jp@}
から無料でダウンロードできる。@ruby@がサポートしたのがかなり最近なのが
多少不安だが、本書出版前に行ったビルドテストでは特に問題は出ていない。


さて以上四つの環境のうちどれを選べばいいだろうか。まず基本的には
Visual C++版が最も問題が出にくいのでそれをお勧めする。UNIXの経験がある
ならCygwin一式入れてCygwinを使うのもよい。UNIXの経験がなくVisual C++も
持っていない場合はMinGWを使うのがいいだろう。


以下ではVisual C++とMinGWでのビルド方法について説明するが、
あくまで概要だけに留めた。より細かい解説とBorland C++ Compilerでの
ビルド方法は添付CD-ROMの@doc/build.html@に収録したので適宜そちらも
参照してほしい。

h4. Visual C++

Visual C++と言っても普通はIDEは使わず、DOSプロンプトからビルドする。そ
のときはまずVisual C++自体を動かせるようにするために環境変数の初期化を
しなければいけない。Visual C++にそのためのバッチファイルが付いてくるの
で、まずはそれを実行しよう。

<pre class="screen">
C:> cd "Program FilesMicrosoft Visual Studio .NETVc7bin"
C:Program FilesMicrosoft Visual Studio .NETVc7bin> vcvars32
</pre>

これはVisual C++.NETの場合だ。バージョン6なら以下の場所にある。

<pre class="emlist"> 
C:Program FilesMicrosoft Visual StudioVC98bin
</pre>

@vcvars32@を実行したらその後は@ruby@のソースツリーの中のフォルダ
@win32@に移動してビルドすればいい。以下、ソースツリーは@C:src@に
あるとしよう。

<pre class="screen">
C:> cd srcruby
C:srcruby> cd win32
C:srcrubywin32> configure
C:srcrubywin32> nmake
C:srcrubywin32> nmake DESTDIR="C:Program Filesruby" install
</pre>

これで@C:Program Filesrubybin@に@ruby@コマンドが、
@C:Program Filesrubylib@以下にRubyのライブラリが、
それぞれインストールされる。@ruby@はレジストリなどは一切使わない
ので、アンインストールするときは@C:ruby@以下を消せばよい。

h4. MinGW

前述のようにMinGWはコンパイル環境のみなので、一般的なUNIXのツール、
例えば@sed@や@sh@が存在しない。しかし@ruby@のビルドにはそれが必要なので
それをどこかから調達しなければならない。それにはまた二つの方法が
存在する。CygwinとMSYS（Minimal SYStem）である。


だがMSYSのほうは本書の出版前に行ったビルド大会でトラブルが続出してしまっ
たのでお勧めできない。対照的にCygwinを使う方法だと非常に素直に通った。
従って本書ではCygwinを使う方法を説明する。


まずCygwinの@setup.exe@でMinGWと開発ツール一式を入れておく。
CygwinとMinGWは添付CD-ROMにも収録した
footnote{CygwinとMinGW......添付CD-ROMの@doc/win.html@を参照}。
あとはCygwinの@bash@プロンプトから以下のように打てばよい。

<pre class="screen">
~/src/ruby % ./configure --with-gcc='gcc -mno-cygwin' 
                                 --enable-shared i386-mingw32
~/src/ruby % make
~/src/ruby % make install
</pre>

これだけだ。ここでは@configure@の行を折り返しているが実際には一行に
入れる。またバックスラッシュを入れる必要はない。インストール先は
コンパイルしたドライブの@usrlocal@以下になる。このあたりはかなり
ややこしいことが起こっていて説明が長くなるので、
添付CD-ROMの@doc/build.html@で徹底的に説明しよう。

h2. ビルド詳細

ここまでが@README@的な解説である。今度はこれまでやったことが具体的に
何をしているのか、つっこんで見ていこう。ただしここの話は部分的に
かなり高度な知識が必要になる。わからない場合はいきなり次の節に
飛んでほしい。本書全体を読んでから戻ってきてもらえばわかるように
なっているはずだ。


さて、どのプラットフォームでも@ruby@のビルドは三段階に分かれている。
即ち@configure@、@make@、@make install@だ。@make install@はいいとして、
@configure@と@make@の段階について解説しよう。

h3. @configure@

まず@configure@である。この中身はシェルスクリプトになっており、これ
でシステムのパラメータを検出する。例えば「ヘッダファイル@setjmp.h@が存
在するか」とか、「@alloca()@は使えるか」ということを調べてくれる。調べ
る方法は意外と単純である。


チェック対象方法
コマンド実際に実行してみて@$?@を見る
ヘッダファイル@if [ -f $includedir/stdio.h ]@
関数小さいプログラムをコンパイルしてみてリンクが成功するかどうか試す


違いを検出したら、それをどうにかしてこちらに伝えてもらわないと
いけない。その方法は、まず@Makefile@が一つ。パラメータを@@PARAM@@の
ように埋め込んだ@Makefile.in@を置いておくと、それを実際の値に変換
した@Makefile@を生成してくれる。例えば次のように。

<pre class="emlist"> 
Makefile.in:  CFLAGS = @CFLAGS@
                     ↓
Makefile   :  CFLAGS = -g -O2
</pre>

もう一つ、関数やヘッダファイルがあるかどうかといった情報を
ヘッダファイルにして出力してくれる。出力ファイルの名前は変更
できるのでプログラムによって違うが、@ruby@では@config.h@である。
@configure@を実行した後にこのファイルができていることを確かめてほしい。
中身はこんな感じだ。

▼@config.h@
<pre class="longlist">
         ：
         ：
#define HAVE_SYS_STAT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_UNISTD_H 1
#define _FILE_OFFSET_BITS 64
#define HAVE_LONG_LONG 1
#define HAVE_OFF_T 1
#define SIZEOF_INT 4
#define SIZEOF_SHORT 2
         ：
         ：
</pre>

どれも意味はわかりやすい。@HAVE_xxxx_H@ならヘッダファイルが存在するか
どうかのチェックだろうし、@SIZEOF_SHORT@ならCの@short@型が何バイトかを
示しているに違いない。同じく@SIZEOF_INT@なら@int@のバイト長だし、
@HAVE_OFF_T@は@offset_t@型が定義されているかを示している。これに限らず
@configure@では「ある／ない」の情報は@HAVE_xxxx@というマクロで定義される
（する）。


以上のことからわかるように、@configure@は違いを検出してはくれるが、
その違いを自動的に吸収してくれるわけではない。ここで定義された値を
使って差を埋めるのはあくまで各プログラマの仕事である。例えば次の
ように。


▼@HAVE_@マクロの典型的な使いかた
<pre class="longlist">
  24  #ifdef HAVE_STDLIB_H
  25  # include 
  26  #endif
(ruby.h)
</pre>
h3. @autoconf@

@configure@は@ruby@の専用ツールではない。関数があるか、ヘッダファイルが
あるか......といったテストには明らかに規則性があるのだから、プログラムを
書く人がみんなでそれぞれに別のものを書くのは無駄だ。


そこで登場するのが@autoconf@というツールである。@configure.in@とか
@configure.ac@というファイルに「こういうチェックがしたいんだ」と
書いておき、それを@autoconf@で処理すると適切な@configure@を作ってくれる。
@configure.in@の@.in@は@input@の略だろう。@Makefile@と@Makefile.in@の関係と
同じである。@.ac@のほうはもちろん@AutoConf@の略だ。


ここまでを絵にすると図1のようになる。

!images/ch_abstract_build.jpg([build])!
図1: @Makefile@ができるまで


もっと詳しいことが知りたい読者には『GNU Autoconf/Automake/Libtool』
footnote{『GNU Autoconf/Automake/Libtool』Gary V.Vaughan, Ben Elliston, Tom Tromey, Ian Lance Taylor共著、でびあんぐる監訳、オーム社}
をお勧めする。


ところで@ruby@の@configure@は言ったとおり@autoconf@を使って生成してい
るのだが、世の中にある@configure@が必ずしも@autoconf@で生成されている
とは限らない。手書きだったり、別の自動生成ツールを使っていたりすること
もある。なんにせよ、最終的に@Makefile@や@config.h@やその他いろいろがで
きればそれでいいのだ。

h3. @make@

第二段階、@make@では何をするのだろうか。もちろん@ruby@のソースコードを
コンパイルするわけだが、@make@の出力を見ているとどうもその他にいろいろ
やっているように見える。その過程を簡単に説明しておこう。


@ruby@自体を構成するソースコードをコンパイルする。
@ruby@の主要部分を集めたスタティックライブラリ@libruby.a@を作る。
常にスタティックリンクされる@ruby@「@miniruby@」を作る。
@--enable-shared@のときは共有ライブラリ@libruby.so@を作る。
@miniruby@を使って拡張ライブラリ（@ext/@以下）をコンパイルする。
最後に、本物の@ruby@を生成する。


@miniruby@と@ruby@の生成が分かれているのには二つ理由がある。一つめは拡張ラ
イブラリのコンパイルに@ruby@が必要になることだ。@--enable-shared@の場合は
@ruby@自身がダイナミックリンクされるので、ライブラリのロードパスの関係で
すぐに動かせないかもしれない。そこでスタティックリンクした@miniruby@を作り、
ビルドの過程ではそちらを使うようにする。


二つめの理由は、共有ライブラリが使えないプラットフォームでは拡張ライブ
ラリを@ruby@自体にスタティックリンクしてしまう場合があるということだ。そ
の場合、@ruby@は拡張ライブラリを全てコンパイルしてからでないと作れないが、
拡張ライブラリは@ruby@がないとコンパイルできない。そのジレンマを解消する
ために@miniruby@を使うのである。

h2. CVS

本書の添付CD-ROMに入っている@ruby@のアーカイブにしても公式のリリースパッ
ケージにしても、それは@ruby@という、変化しつづているプログラムのほんの一
瞬の姿をとらえたスナップショットにすぎない。@ruby@がどう変わってきたか、
どうしてそうだったのか、ということはここには記述されていない。では過去
も含めた全体を見るにはどうしたらいいだろうか。CVSを使えばそれができる。

h3. CVSとは

CVSを一言で言うとエディタのundoリストである。
ソースコードをCVSの管理下に入れておけばいつでも昔の姿に戻せるし、誰が、
どこを、いつ、どう変えたのかすぐにわかる。一般にそういうことをしてくれ
るプログラムのことをソースコード管理システムと言うが、オープンソースの
世界で一番有名なソースコード管理システムがCVSである。


@ruby@もやはりCVSで管理されているのでCVSの仕組みと使いかたについて少し説
明しよう。まずCVSの最重要概念はレポジトリとワーキングコピーである。
CVSはエディタのundoリストのようなものと言ったが、そのためには歴代の変更の
記録を
どこかに残しておかないといけない。それを全部まとめて保存しておく場所が
「CVSレポジトリ」である。


ぶっちゃけて言うと、過去のソースコードを全部集めてあるのがレポジトリで
ある。もちろんそれはあくまで概念であって、実際には容量を節約するために、
最新の姿一つと、そこに至るまでの変更差分（ようするにパッチ）の形で集積
されている。なんにしてもファイルの過去の姿をどの時点だろうと取り出せる
ようになっていればそれでいいのだ。


一方、レポジトリからある一点を選んでファイルを取り出したものが
「ワーキングコピー」だ。レポジトリは一つだけだがワーキングコピーは
いくつあってもいい（図2）。

!images/ch_abstract_repo.jpg([repo])!
図2: レポジトリとワーキングコピー


自分がソースコードを変更したいときはまずワーキングコピーを取り出して、
それをエディタなどで編集してからレポジトリに「戻す」。するとレポジトリ
に変更が記録される。レポジトリからワーキングコピーを取り出すことを
「チェックアウト（checkout）」、戻すことを「チェックイン
（checkin）」
または「コミット（commit）」と言う（図3）。チェックインするとレ
ポジトリに変更が記録されて、いつでもそれを取り出せるようになる。

!images/ch_abstract_ci.jpg([ci])!
図3: チェックインとチェックアウト


そしてCVS最大の特徴はCVSレポジトリにネットワーク越しにアクセスできると
いうところだ。つまりレポジトリを保持するサーバが一つあればインターネッ
ト越しに誰でもどこからでもチェックアウト・チェックインすることができる。
ただし普通はチェックインにはアクセス制限がかかっているので無制限
にできるというわけではない。

h4. リビジョン

レポジトリから特定の版を取り出すにはどうしたらいいだろうか。一つには時
刻で指定する方法がある。「この当時の最新版をくれ」と要求するとそれを選
んでくれるわけだ。しかし実際には時刻で指定することはあまりない。普通は
「リビジョン（revision）」というものを使う。


「リビジョン」は「バージョン」とほとんど同じ意味である。ただ普通はプロ
ジェクト自体に「バージョン」が付いているので、バージョンという言葉を使
うと紛らわしい。そこでもうちょっと細かい単位を意図してリビジョンという
言葉を使う。


CVSでは、レポジトリに入れたばかりのファイルはリビジョン1.1である。
チェックアウトして、変更して、チェックインするとリビジョン1.2になる。
その次は1.3になる。その次は1.4になる。

h4. CVSの簡単な使用例

以上をふまえてごくごく簡単にCVSの使いかたを話す。まず@cvs@コマンドがな
いとどうにもならないのでインストールしておいてほしい。添付CD-ROMにも
@cvs@のソースコードを収録した
footnote{@cvs@：@archives/cvs-1.11.2.tar.gz@}。
@cvs@のインストールの方法はあまりにも本筋から外れるのでここでは書かな
い。


インストールしたら試しに@ruby@のソースコードをチェックアウトしてみよう。
インターネットに接続中に次のように打つ。

<pre class="screen">
% cvs -d :pserver:anonymous@cvs.ruby-lang.org:/src login
CVS Password: anonymous
% cvs -d :pserver:anonymous@cvs.ruby-lang.org:/src checkout ruby
</pre>

何もオプションを付けないと自動的に最新版がチェックアウトされるので、
@ruby/@以下に@ruby@の真の最新版が現れているはずだ。


また、とある日の版を取り出すには@cvs checkout@に@-D@オプションをつけれ
ばいい。次のように打てば本書が解説しているバージョンのワーキングコピー
が取り出せる。

<pre class="screen">
% cvs -d :pserver:anonymous@cvs.ruby-lang.org:/src checkout -D2002-09-12 ruby
</pre>

このとき、オプションは必ず@checkout@の直後に書かないといけないことに注
意。先に「@ruby@」を書いてしまうと「モジュールがない」という変なエラー
になる。


ちなみにこの例のようなanonymousアクセスだとチェックインはできないようになっている。
チェックインの練習をするには適当に（ローカルの）レポジトリを作って
Hello, World!プログラムでも入れてみるのがいいだろう。具体的な入れかた
はここには書かない。@cvs@に付いてくるマニュアルが結構親切だ。日本語の書
籍ならオーム社の『CVSによるオープンソース開発』
footnote{『CVSによるオープンソース開発』Karl Fogel, Moshe Bar共著、竹内利佳訳、オーム社}
をお勧めする。

h2. @ruby@の構成
h3. 物理構造

さてそろそろソースコードを見ていこうと思うのだが、まず最初にしなければ
ならないことはなんだろうか。それはディレクトリ構造を眺めることである。
たいていの場合ディレクトリ構造すなわちソースツリーはそのままプログラム
のモジュール構造を示している。いきなり@grep@で@main()@を探して頭から処理順
に読んでいく、なんていうのは賢くない。もちろん@main()@を探すのも大切だが、
まずはのんびりと@ls@したり@head@したりして全体の様子をつかもう。


以下はCVSレポジトリからチェックアウトした直後の
トップディレクトリの様子だ。
スラッシュで終わっているのはサブディレクトリである。

<pre class="emlist"> 
COPYING        compar.c       gc.c           numeric.c      sample/
COPYING.ja     config.guess   hash.c         object.c       signal.c
CVS/           config.sub     inits.c        pack.c         sprintf.c
ChangeLog      configure.in   install-sh     parse.y        st.c
GPL            cygwin/        instruby.rb    prec.c         st.h
LEGAL          defines.h      intern.h       process.c      string.c
LGPL           dir.c          io.c           random.c       struct.c
MANIFEST       djgpp/         keywords       range.c        time.c
Makefile.in    dln.c          lex.c          re.c           util.c
README         dln.h          lib/           re.h           util.h
README.EXT     dmyext.c       main.c         regex.c        variable.c
README.EXT.ja  doc/           marshal.c      regex.h        version.c
README.ja      enum.c         math.c         ruby.1         version.h
ToDo           env.h          misc/          ruby.c         vms/
array.c        error.c        missing/       ruby.h         win32/
bcc32/         eval.c         missing.h      rubyio.h       x68/
bignum.c       ext/           mkconfig.rb    rubysig.h
class.c        file.c         node.h         rubytest.rb
</pre>

最近はプログラム自体が大きくなってきてサブディレクトリが細かく分割され
ているソフトウェアも多いが、@ruby@はかなり長いことトップディレクトリ
一筋である。あまりにファイル数が多いと困るが、この程度なら慣れればな
んでもない。


トップレベルのファイルは六つに分類できる。即ち


ドキュメント
@ruby@自身のソースコード
@ruby@ビルド用のツール
標準添付拡張ライブラリ
標準添付Rubyライブラリ
その他


である。ソースコードとビルドツールが重要なのは当然として、その他に
我々の役に立ちそうなものを挙げておこう。


@ChangeLog@


@ruby@への変更の記録。変更の理由を調べるうえでは非常に重要。


@README.EXT README.EXT.ja@


拡張ライブラリの作成方法が書いてあるのだが、その一環として
@ruby@自身の実装に関することも書いてある。

h3. ソースコードの腑分け

ここからは@ruby@自身のソースコードについてさらに細かく分割していく。
主要なファイルについては@README.EXT@に分類が書いてあったので
それに従う。記載がないものは筆者が分類した。

h4. Ruby言語のコア

@class.c@クラス関連API
@error.c@例外関連API
@eval.c@評価器
@gc.c@ガーベージコレクタ
@lex.c@予約語テーブル
@object.c@オブジェクトシステム
@parse.y@パーサ
@variable.c@定数、グローバル変数、クラス変数
@ruby.h@@ruby@の主要マクロとプロトタイプ
@intern.h@@ruby@のC APIのプロトタイプ。@intern@はinternalの略だと思われるが、ここに載っている関数を拡張ライブラリで使うのは別に構わない。
@rubysig.h@シグナル関係のマクロを収めたヘッダファイル
@node.h@構文木ノード関連の定義
@env.h@評価器のコンテキストを表現する構造体の定義


@ruby@インタプリタのコアを構成する部分。本書が解説するのは
ここのファイルがほとんどである。@ruby@全体のファイル数と比べれば
非常に少ないが、バイトベースでは全体の50%近くを占める。
特に@eval.c@は200Kバイト、@parse.y@が100Kバイトと大きい。

h4. ユーティリティ

@dln.c@動的ローダ
@regex.c@正規表現エンジン
@st.c@ハッシュテーブル
@util.c@基数変換やソートなどのライブラリ


@ruby@にとってのユーティリティという意味。ただしユーティリティという
言葉からは想像できないほど大きいものもある。例えば@regex.c@は120Kバイトだ。

h4. @ruby@コマンドの実装

@dmyext.c@拡張ライブラリ初期化ルーチンのダミー（DumMY EXTention）
@inits.c@コアとライブラリの初期化ルーチンのエントリポイント
@main.c@コマンドのエントリポイント（@libruby@には不要）
@ruby.c@@ruby@コマンドの主要部分（@libruby@にも必要）
@version.c@@ruby@のバージョン


コマンドラインで@ruby@と打って実行するときの@ruby@コマンドの実装。コマンドライン
オプションの解釈などを行っている部分だ。@ruby@コマンド以外に@ruby@コアを利
用するコマンドとしては@mod_ruby@や@vim@が挙げられる。これらのコマンドは
ライブラリ@libruby@（@.a@/@.so@/@.dll@など）とリンクして動作する。

h4. クラスライブラリ

@array.c@@class Array@
@bignum.c@@class Bignum@
@compar.c@@module Comparable@
@dir.c@@class Dir@
@enum.c@@module Enumerable@
@file.c@@class File@
@hash.c@@class Hash@（実体は@st.c@）
@io.c@@class IO@
@marshal.c@@module Marshal@
@math.c@@module Math@
@numeric.c@@class Numeric@、@Integer@、@Fixnum@、@Float@
@pack.c@@Array#pack@、@String#unpack@
@prec.c@@module Precision@
@process.c@@module Process@
@random.c@@Kernel#srand()@、@rand()@
@range.c@@class Range@
@re.c@@class Regexp@（実体は@regex.c@）
@signal.c@@module Signal@
@sprintf.c@@ruby@専用の@sprintf()@
@string.c@@class String@
@struct.c@@class Struct@
@time.c@@class Time@


Rubyのクラスライブラリの実装。ここにあるものは基本的に通常の
Ruby拡張ライブラリと全く同じ方法で実装されている。つまりこの
ライブラリが拡張ライブラリの書きかたの例にもなっているということだ。

h4. プラットフォーム依存ファイル

@bcc32/@Borland C++（Win32）
@beos/@BeOS
@cygwin/@Cygwin（Win32でのUNIXエミュレーションレイヤー）
@djgpp/@djgpp（DOS用のフリーな開発環境）
@vms/@VMS（かつてDECがリリースしていたOS）
@win32/@Visual C++（Win32）
@x68/@Sharp X680x0系（OSはHuman68k）


各プラットフォーム特有のコードが入っている。

h4. フォールバック関数
<pre class="emlist"> 
missing/
</pre>

各種プラットフォームにない関数を補うためのファイル。
主に@libc@の関数が多い。

h3. 論理構造

さて、以上四つのグループのうちコアはさらに大きく三つに分けられる。
一つめはRubyのオブジェクト世界を作りだす「オブジェクト空間（object space）」。
二つめはRubyプログラム（テキスト）を内部形式に変換する「パーサ（parser）」。
三つめはRubyプログラムを駆動する「評価器（evaluator）」。
パーサも評価器もオブジェクト空間の上に成立し、
パーサがプログラムを内部形式に変換し、
評価器がプログラムを駆動する。
順番に解説していこう。

h4. オブジェクト空間

一つめのオブジェクト空間。これは非常に、理解しやすい。なぜならこれが扱
うものは基本的にメモリ上のモノが全てであり、関数を使って直接表示したり
操作したりすることができるからだ。従って本書ではまずここから解説を
始める。第2章から
第7章までが第一部である。

h4. パーサ

二つめのパーサ。これは説明が必要だろう。


@ruby@コマンドはRuby言語のインタプリタである。つまり起動時にテキストの入
力を解析し、それに従って実行する。だから@ruby@はテキストとして書かれたプ
ログラムの意味を解釈できなければいけないのだが、不幸にしてテキストとい
うのはコンピュータにとっては非常に理解しづらいものである。コンピュータ
にとってはテキストファイルはあくまでバイト列であって、それ以上ではない。
そこからテキストの意味を読みとるには何か特別な仕掛けが必要になる。そ
の仕掛けがパーサだ。このパーサを通すことでRubyプログラム（であるテキス
ト）は@ruby@専用の、プログラムから扱いやすい内部表現に変換される。


その内部表現とは具体的には「構文木」というものだ。構文木はプログラムを
ツリー構造で表現したもので、例えば@if@文ならば図4のように
表現される。

!images/ch_abstract_syntree.jpg([syntree])!
図4: @if@文と、それに対応する構文木


パーサの解説は第二部『構文解析』で行う。
第二部は第10章から第12章までだ。
対象となるファイルは@parse.y@だけである。

h4. 評価器

オブジェクトは実際に触ることができるのでわかりやすい。パーサにしてもやっ
ていること自体はようするにデータ形式の変換なんだから、まあわかる。しか
し三つめの評価器、こいつはつかみどころが全くない。


評価器がやるのは構文木に従ってプログラムを「実行」していくことだ。と言
うと簡単そうに見えるのだが、では「実行する」とはどういうことか、ちゃん
と考えるとこれが結構難しい。@if@文を実行するとはどういうことだろうか。
@while@文を実行するとはどういうことだろうか。ローカル変数に代入するとは
どういうことだろうか。メソッドを呼ぶとはどういうことだろうか。その
全てにキチンキチンと答えを出していかなければ評価器はわからないのだ。


本書では第三部『評価』で評価器を扱う。対象ファイルは@eval.c@だ。
「評価器」は英語でevaluatorと言うので、それを省略して@eval@である。

さて、@ruby@の作りについて簡単に説明してきたが、プログラムの動作なんてい
くら概念を説明してもわかりにくいものだ。次の章ではまず実際に@ruby@を使う
ことから始めるとしよう。


御意見・御感想・誤殖の指摘などは
"青木峰郎 ":mailto:aamine@loveruby.net
までお願いします。


"『Rubyソースコード完全解説』
":http://direct.ips.co.jp/directsys/go_x_TempChoice.cfm?sh_id=EE0040&spm_id=1&GM_ID=1721"はインプレスダイレクトで御予約・御購入いただけます (書籍紹介ページへ飛びます)。":http://direct.ips.co.jp/directsys/go_x_TempChoice.cfm?sh_id=EE0040&spm_id=1&GM_ID=1721

Copyright (c) 2002-2004 Minero Aoki, All rights reserved.

